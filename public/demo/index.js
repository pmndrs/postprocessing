(function () {
  'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var _ENCODINGS;

  if (Number.EPSILON === undefined) {
    Number.EPSILON = Math.pow(2, -52);
  }

  if (Number.isInteger === undefined) {
    Number.isInteger = function (value) {
      return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
    };
  }

  if (Math.sign === undefined) {
    Math.sign = function (x) {
      return x < 0 ? -1 : x > 0 ? 1 : +x;
    };
  }

  if ('name' in Function.prototype === false) {
    Object.defineProperty(Function.prototype, 'name', {
      get: function get() {
        return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
      }
    });
  }

  if (Object.assign === undefined) {
    Object.assign = function (target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var output = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];

        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }

      return output;
    };
  }

  var REVISION = '113';
  var CullFaceNone = 0;
  var CullFaceBack = 1;
  var CullFaceFront = 2;
  var PCFShadowMap = 1;
  var PCFSoftShadowMap = 2;
  var VSMShadowMap = 3;
  var FrontSide = 0;
  var BackSide = 1;
  var DoubleSide = 2;
  var FlatShading = 1;
  var NoColors = 0;
  var FaceColors = 1;
  var VertexColors = 2;
  var NoBlending = 0;
  var NormalBlending = 1;
  var AdditiveBlending = 2;
  var SubtractiveBlending = 3;
  var MultiplyBlending = 4;
  var CustomBlending = 5;
  var AddEquation = 100;
  var SubtractEquation = 101;
  var ReverseSubtractEquation = 102;
  var MinEquation = 103;
  var MaxEquation = 104;
  var ZeroFactor = 200;
  var OneFactor = 201;
  var SrcColorFactor = 202;
  var OneMinusSrcColorFactor = 203;
  var SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = 205;
  var DstAlphaFactor = 206;
  var OneMinusDstAlphaFactor = 207;
  var DstColorFactor = 208;
  var OneMinusDstColorFactor = 209;
  var SrcAlphaSaturateFactor = 210;
  var NeverDepth = 0;
  var AlwaysDepth = 1;
  var LessDepth = 2;
  var LessEqualDepth = 3;
  var EqualDepth = 4;
  var GreaterEqualDepth = 5;
  var GreaterDepth = 6;
  var NotEqualDepth = 7;
  var MultiplyOperation = 0;
  var MixOperation = 1;
  var AddOperation = 2;
  var NoToneMapping = 0;
  var LinearToneMapping = 1;
  var ReinhardToneMapping = 2;
  var Uncharted2ToneMapping = 3;
  var CineonToneMapping = 4;
  var ACESFilmicToneMapping = 5;
  var UVMapping = 300;
  var CubeReflectionMapping = 301;
  var CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = 304;
  var SphericalReflectionMapping = 305;
  var CubeUVReflectionMapping = 306;
  var CubeUVRefractionMapping = 307;
  var RepeatWrapping = 1000;
  var ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = 1002;
  var NearestFilter = 1003;
  var NearestMipmapNearestFilter = 1004;
  var NearestMipmapLinearFilter = 1005;
  var LinearFilter = 1006;
  var LinearMipmapNearestFilter = 1007;
  var LinearMipmapLinearFilter = 1008;
  var UnsignedByteType = 1009;
  var ByteType = 1010;
  var ShortType = 1011;
  var UnsignedShortType = 1012;
  var IntType = 1013;
  var UnsignedIntType = 1014;
  var FloatType = 1015;
  var HalfFloatType = 1016;
  var UnsignedShort4444Type = 1017;
  var UnsignedShort5551Type = 1018;
  var UnsignedShort565Type = 1019;
  var UnsignedInt248Type = 1020;
  var AlphaFormat = 1021;
  var RGBFormat = 1022;
  var RGBAFormat = 1023;
  var LuminanceFormat = 1024;
  var LuminanceAlphaFormat = 1025;
  var DepthFormat = 1026;
  var DepthStencilFormat = 1027;
  var RedFormat = 1028;
  var RedIntegerFormat = 1029;
  var RGFormat = 1030;
  var RGIntegerFormat = 1031;
  var RGBIntegerFormat = 1032;
  var RGBAIntegerFormat = 1033;
  var RGB_S3TC_DXT1_Format = 33776;
  var RGBA_S3TC_DXT1_Format = 33777;
  var RGBA_S3TC_DXT3_Format = 33778;
  var RGBA_S3TC_DXT5_Format = 33779;
  var RGB_PVRTC_4BPPV1_Format = 35840;
  var RGB_PVRTC_2BPPV1_Format = 35841;
  var RGBA_PVRTC_4BPPV1_Format = 35842;
  var RGBA_PVRTC_2BPPV1_Format = 35843;
  var RGB_ETC1_Format = 36196;
  var RGBA_ASTC_4x4_Format = 37808;
  var RGBA_ASTC_5x4_Format = 37809;
  var RGBA_ASTC_5x5_Format = 37810;
  var RGBA_ASTC_6x5_Format = 37811;
  var RGBA_ASTC_6x6_Format = 37812;
  var RGBA_ASTC_8x5_Format = 37813;
  var RGBA_ASTC_8x6_Format = 37814;
  var RGBA_ASTC_8x8_Format = 37815;
  var RGBA_ASTC_10x5_Format = 37816;
  var RGBA_ASTC_10x6_Format = 37817;
  var RGBA_ASTC_10x8_Format = 37818;
  var RGBA_ASTC_10x10_Format = 37819;
  var RGBA_ASTC_12x10_Format = 37820;
  var RGBA_ASTC_12x12_Format = 37821;
  var LoopOnce = 2200;
  var LoopRepeat = 2201;
  var LoopPingPong = 2202;
  var InterpolateDiscrete = 2300;
  var InterpolateLinear = 2301;
  var InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = 2401;
  var WrapAroundEnding = 2402;
  var TrianglesDrawMode = 0;
  var TriangleStripDrawMode = 1;
  var TriangleFanDrawMode = 2;
  var LinearEncoding = 3000;
  var sRGBEncoding = 3001;
  var GammaEncoding = 3007;
  var RGBEEncoding = 3002;
  var LogLuvEncoding = 3003;
  var RGBM7Encoding = 3004;
  var RGBM16Encoding = 3005;
  var RGBDEncoding = 3006;
  var BasicDepthPacking = 3200;
  var RGBADepthPacking = 3201;
  var TangentSpaceNormalMap = 0;
  var ObjectSpaceNormalMap = 1;
  var KeepStencilOp = 7680;
  var AlwaysStencilFunc = 519;
  var StaticDrawUsage = 35044;
  var DynamicDrawUsage = 35048;

  function EventDispatcher() {}

  Object.assign(EventDispatcher.prototype, {
    addEventListener: function addEventListener(type, listener) {
      if (this._listeners === undefined) this._listeners = {};
      var listeners = this._listeners;

      if (listeners[type] === undefined) {
        listeners[type] = [];
      }

      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    },
    hasEventListener: function hasEventListener(type, listener) {
      if (this._listeners === undefined) return false;
      var listeners = this._listeners;
      return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    },
    removeEventListener: function removeEventListener(type, listener) {
      if (this._listeners === undefined) return;
      var listeners = this._listeners;
      var listenerArray = listeners[type];

      if (listenerArray !== undefined) {
        var index = listenerArray.indexOf(listener);

        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    },
    dispatchEvent: function dispatchEvent(event) {
      if (this._listeners === undefined) return;
      var listeners = this._listeners;
      var listenerArray = listeners[event.type];

      if (listenerArray !== undefined) {
        event.target = this;
        var array = listenerArray.slice(0);

        for (var i = 0, l = array.length; i < l; i++) {
          array[i].call(this, event);
        }
      }
    }
  });
  var _lut = [];

  for (var i = 0; i < 256; i++) {
    _lut[i] = (i < 16 ? '0' : '') + i.toString(16);
  }

  var MathUtils = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function generateUUID() {
      var d0 = Math.random() * 0xffffffff | 0;
      var d1 = Math.random() * 0xffffffff | 0;
      var d2 = Math.random() * 0xffffffff | 0;
      var d3 = Math.random() * 0xffffffff | 0;
      var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];
      return uuid.toUpperCase();
    },
    clamp: function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    },
    euclideanModulo: function euclideanModulo(n, m) {
      return (n % m + m) % m;
    },
    mapLinear: function mapLinear(x, a1, a2, b1, b2) {
      return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    },
    lerp: function lerp(x, y, t) {
      return (1 - t) * x + t * y;
    },
    smoothstep: function smoothstep(x, min, max) {
      if (x <= min) return 0;
      if (x >= max) return 1;
      x = (x - min) / (max - min);
      return x * x * (3 - 2 * x);
    },
    smootherstep: function smootherstep(x, min, max) {
      if (x <= min) return 0;
      if (x >= max) return 1;
      x = (x - min) / (max - min);
      return x * x * x * (x * (x * 6 - 15) + 10);
    },
    randInt: function randInt(low, high) {
      return low + Math.floor(Math.random() * (high - low + 1));
    },
    randFloat: function randFloat(low, high) {
      return low + Math.random() * (high - low);
    },
    randFloatSpread: function randFloatSpread(range) {
      return range * (0.5 - Math.random());
    },
    degToRad: function degToRad(degrees) {
      return degrees * MathUtils.DEG2RAD;
    },
    radToDeg: function radToDeg(radians) {
      return radians * MathUtils.RAD2DEG;
    },
    isPowerOfTwo: function isPowerOfTwo(value) {
      return (value & value - 1) === 0 && value !== 0;
    },
    ceilPowerOfTwo: function ceilPowerOfTwo(value) {
      return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    },
    floorPowerOfTwo: function floorPowerOfTwo(value) {
      return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    },
    setQuaternionFromProperEuler: function setQuaternionFromProperEuler(q, a, b, c, order) {
      var cos = Math.cos;
      var sin = Math.sin;
      var c2 = cos(b / 2);
      var s2 = sin(b / 2);
      var c13 = cos((a + c) / 2);
      var s13 = sin((a + c) / 2);
      var c1_3 = cos((a - c) / 2);
      var s1_3 = sin((a - c) / 2);
      var c3_1 = cos((c - a) / 2);
      var s3_1 = sin((c - a) / 2);

      if (order === 'XYX') {
        q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      } else if (order === 'YZY') {
        q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      } else if (order === 'ZXZ') {
        q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      } else if (order === 'XZX') {
        q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      } else if (order === 'YXY') {
        q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      } else if (order === 'ZYZ') {
        q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      } else {
        console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.');
      }
    }
  };

  function Vector2(x, y) {
    this.x = x || 0;
    this.y = y || 0;
  }

  Object.defineProperties(Vector2.prototype, {
    "width": {
      get: function get() {
        return this.x;
      },
      set: function set(value) {
        this.x = value;
      }
    },
    "height": {
      get: function get() {
        return this.y;
      },
      set: function set(value) {
        this.y = value;
      }
    }
  });
  Object.assign(Vector2.prototype, {
    isVector2: true,
    set: function set(x, y) {
      this.x = x;
      this.y = y;
      return this;
    },
    setScalar: function setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    },
    setX: function setX(x) {
      this.x = x;
      return this;
    },
    setY: function setY(y) {
      this.y = y;
      return this;
    },
    setComponent: function setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;

        case 1:
          this.y = value;
          break;

        default:
          throw new Error('index is out of range: ' + index);
      }

      return this;
    },
    getComponent: function getComponent(index) {
      switch (index) {
        case 0:
          return this.x;

        case 1:
          return this.y;

        default:
          throw new Error('index is out of range: ' + index);
      }
    },
    clone: function clone() {
      return new this.constructor(this.x, this.y);
    },
    copy: function copy(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    },
    add: function add(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
        return this.addVectors(v, w);
      }

      this.x += v.x;
      this.y += v.y;
      return this;
    },
    addScalar: function addScalar(s) {
      this.x += s;
      this.y += s;
      return this;
    },
    addVectors: function addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    },
    addScaledVector: function addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      return this;
    },
    sub: function sub(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
        return this.subVectors(v, w);
      }

      this.x -= v.x;
      this.y -= v.y;
      return this;
    },
    subScalar: function subScalar(s) {
      this.x -= s;
      this.y -= s;
      return this;
    },
    subVectors: function subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    },
    multiply: function multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    },
    multiplyScalar: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    },
    divide: function divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    },
    divideScalar: function divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    },
    applyMatrix3: function applyMatrix3(m) {
      var x = this.x,
          y = this.y;
      var e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6];
      this.y = e[1] * x + e[4] * y + e[7];
      return this;
    },
    min: function min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    },
    max: function max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    },
    clamp: function clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    },
    clampScalar: function clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      return this;
    },
    clampLength: function clampLength(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    },
    floor: function floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    },
    ceil: function ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    },
    round: function round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    },
    roundToZero: function roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    },
    negate: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    },
    dot: function dot(v) {
      return this.x * v.x + this.y * v.y;
    },
    cross: function cross(v) {
      return this.x * v.y - this.y * v.x;
    },
    lengthSq: function lengthSq() {
      return this.x * this.x + this.y * this.y;
    },
    length: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    manhattanLength: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function normalize() {
      return this.divideScalar(this.length() || 1);
    },
    angle: function angle() {
      var angle = Math.atan2(this.y, this.x);
      if (angle < 0) angle += 2 * Math.PI;
      return angle;
    },
    distanceTo: function distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function distanceToSquared(v) {
      var dx = this.x - v.x,
          dy = this.y - v.y;
      return dx * dx + dy * dy;
    },
    manhattanDistanceTo: function manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    },
    setLength: function setLength(length) {
      return this.normalize().multiplyScalar(length);
    },
    lerp: function lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      return this;
    },
    lerpVectors: function lerpVectors(v1, v2, alpha) {
      return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    },
    equals: function equals(v) {
      return v.x === this.x && v.y === this.y;
    },
    fromArray: function fromArray(array, offset) {
      if (offset === undefined) offset = 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    },
    toArray: function toArray(array, offset) {
      if (array === undefined) array = [];
      if (offset === undefined) offset = 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    },
    fromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {
      if (offset !== undefined) {
        console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
      }

      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    },
    rotateAround: function rotateAround(center, angle) {
      var c = Math.cos(angle),
          s = Math.sin(angle);
      var x = this.x - center.x;
      var y = this.y - center.y;
      this.x = x * c - y * s + center.x;
      this.y = x * s + y * c + center.y;
      return this;
    }
  });

  function Matrix3() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (arguments.length > 0) {
      console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
  }

  Object.assign(Matrix3.prototype, {
    isMatrix3: true,
    set: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      var te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    },
    identity: function identity() {
      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
      return this;
    },
    clone: function clone() {
      return new this.constructor().fromArray(this.elements);
    },
    copy: function copy(m) {
      var te = this.elements;
      var me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    },
    setFromMatrix4: function setFromMatrix4(m) {
      var me = m.elements;
      this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
      return this;
    },
    multiply: function multiply(m) {
      return this.multiplyMatrices(this, m);
    },
    premultiply: function premultiply(m) {
      return this.multiplyMatrices(m, this);
    },
    multiplyMatrices: function multiplyMatrices(a, b) {
      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;
      var a11 = ae[0],
          a12 = ae[3],
          a13 = ae[6];
      var a21 = ae[1],
          a22 = ae[4],
          a23 = ae[7];
      var a31 = ae[2],
          a32 = ae[5],
          a33 = ae[8];
      var b11 = be[0],
          b12 = be[3],
          b13 = be[6];
      var b21 = be[1],
          b22 = be[4],
          b23 = be[7];
      var b31 = be[2],
          b32 = be[5],
          b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    },
    multiplyScalar: function multiplyScalar(s) {
      var te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    },
    determinant: function determinant() {
      var te = this.elements;
      var a = te[0],
          b = te[1],
          c = te[2],
          d = te[3],
          e = te[4],
          f = te[5],
          g = te[6],
          h = te[7],
          i = te[8];
      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    },
    getInverse: function getInverse(matrix, throwOnDegenerate) {
      if (matrix && matrix.isMatrix4) {
        console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
      }

      var me = matrix.elements,
          te = this.elements,
          n11 = me[0],
          n21 = me[1],
          n31 = me[2],
          n12 = me[3],
          n22 = me[4],
          n32 = me[5],
          n13 = me[6],
          n23 = me[7],
          n33 = me[8],
          t11 = n33 * n22 - n32 * n23,
          t12 = n32 * n13 - n33 * n12,
          t13 = n23 * n12 - n22 * n13,
          det = n11 * t11 + n21 * t12 + n31 * t13;

      if (det === 0) {
        var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

        if (throwOnDegenerate === true) {
          throw new Error(msg);
        } else {
          console.warn(msg);
        }

        return this.identity();
      }

      var detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    },
    transpose: function transpose() {
      var tmp,
          m = this.elements;
      tmp = m[1];
      m[1] = m[3];
      m[3] = tmp;
      tmp = m[2];
      m[2] = m[6];
      m[6] = tmp;
      tmp = m[5];
      m[5] = m[7];
      m[7] = tmp;
      return this;
    },
    getNormalMatrix: function getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).getInverse(this).transpose();
    },
    transposeIntoArray: function transposeIntoArray(r) {
      var m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    },
    setUvTransform: function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      var c = Math.cos(rotation);
      var s = Math.sin(rotation);
      this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    },
    scale: function scale(sx, sy) {
      var te = this.elements;
      te[0] *= sx;
      te[3] *= sx;
      te[6] *= sx;
      te[1] *= sy;
      te[4] *= sy;
      te[7] *= sy;
      return this;
    },
    rotate: function rotate(theta) {
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var te = this.elements;
      var a11 = te[0],
          a12 = te[3],
          a13 = te[6];
      var a21 = te[1],
          a22 = te[4],
          a23 = te[7];
      te[0] = c * a11 + s * a21;
      te[3] = c * a12 + s * a22;
      te[6] = c * a13 + s * a23;
      te[1] = -s * a11 + c * a21;
      te[4] = -s * a12 + c * a22;
      te[7] = -s * a13 + c * a23;
      return this;
    },
    translate: function translate(tx, ty) {
      var te = this.elements;
      te[0] += tx * te[2];
      te[3] += tx * te[5];
      te[6] += tx * te[8];
      te[1] += ty * te[2];
      te[4] += ty * te[5];
      te[7] += ty * te[8];
      return this;
    },
    equals: function equals(matrix) {
      var te = this.elements;
      var me = matrix.elements;

      for (var i = 0; i < 9; i++) {
        if (te[i] !== me[i]) return false;
      }

      return true;
    },
    fromArray: function fromArray(array, offset) {
      if (offset === undefined) offset = 0;

      for (var i = 0; i < 9; i++) {
        this.elements[i] = array[i + offset];
      }

      return this;
    },
    toArray: function toArray(array, offset) {
      if (array === undefined) array = [];
      if (offset === undefined) offset = 0;
      var te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
  });

  var _canvas;

  var ImageUtils = {
    getDataURL: function getDataURL(image) {
      var canvas;

      if (typeof HTMLCanvasElement == 'undefined') {
        return image.src;
      } else if (image instanceof HTMLCanvasElement) {
        canvas = image;
      } else {
        if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        _canvas.width = image.width;
        _canvas.height = image.height;

        var context = _canvas.getContext('2d');

        if (image instanceof ImageData) {
          context.putImageData(image, 0, 0);
        } else {
          context.drawImage(image, 0, 0, image.width, image.height);
        }

        canvas = _canvas;
      }

      if (canvas.width > 2048 || canvas.height > 2048) {
        return canvas.toDataURL('image/jpeg', 0.6);
      } else {
        return canvas.toDataURL('image/png');
      }
    }
  };
  var textureId = 0;

  function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    Object.defineProperty(this, 'id', {
      value: textureId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
    this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;
    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
    this.format = format !== undefined ? format : RGBAFormat;
    this.internalFormat = null;
    this.type = type !== undefined ? type : UnsignedByteType;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding !== undefined ? encoding : LinearEncoding;
    this.version = 0;
    this.onUpdate = null;
  }

  Texture.DEFAULT_IMAGE = undefined;
  Texture.DEFAULT_MAPPING = UVMapping;
  Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Texture,
    isTexture: true,
    updateMatrix: function updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(source) {
      this.name = source.name;
      this.image = source.image;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.internalFormat = source.internalFormat;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.encoding = source.encoding;
      return this;
    },
    toJSON: function toJSON(meta) {
      var isRootObject = meta === undefined || typeof meta === 'string';

      if (!isRootObject && meta.textures[this.uuid] !== undefined) {
        return meta.textures[this.uuid];
      }

      var output = {
        metadata: {
          version: 4.5,
          type: 'Texture',
          generator: 'Texture.toJSON'
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };

      if (this.image !== undefined) {
        var image = this.image;

        if (image.uuid === undefined) {
          image.uuid = MathUtils.generateUUID();
        }

        if (!isRootObject && meta.images[image.uuid] === undefined) {
          var url;

          if (Array.isArray(image)) {
            url = [];

            for (var i = 0, l = image.length; i < l; i++) {
              url.push(ImageUtils.getDataURL(image[i]));
            }
          } else {
            url = ImageUtils.getDataURL(image);
          }

          meta.images[image.uuid] = {
            uuid: image.uuid,
            url: url
          };
        }

        output.image = image.uuid;
      }

      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }

      return output;
    },
    dispose: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    },
    transformUv: function transformUv(uv) {
      if (this.mapping !== UVMapping) return uv;
      uv.applyMatrix3(this.matrix);

      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;

          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;

          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }

            break;
        }
      }

      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;

          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;

          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }

            break;
        }
      }

      if (this.flipY) {
        uv.y = 1 - uv.y;
      }

      return uv;
    }
  });
  Object.defineProperty(Texture.prototype, "needsUpdate", {
    set: function set(value) {
      if (value === true) this.version++;
    }
  });

  function Vector4(x, y, z, w) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w !== undefined ? w : 1;
  }

  Object.defineProperties(Vector4.prototype, {
    "width": {
      get: function get() {
        return this.z;
      },
      set: function set(value) {
        this.z = value;
      }
    },
    "height": {
      get: function get() {
        return this.w;
      },
      set: function set(value) {
        this.w = value;
      }
    }
  });
  Object.assign(Vector4.prototype, {
    isVector4: true,
    set: function set(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    },
    setScalar: function setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    },
    setX: function setX(x) {
      this.x = x;
      return this;
    },
    setY: function setY(y) {
      this.y = y;
      return this;
    },
    setZ: function setZ(z) {
      this.z = z;
      return this;
    },
    setW: function setW(w) {
      this.w = w;
      return this;
    },
    setComponent: function setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;

        case 1:
          this.y = value;
          break;

        case 2:
          this.z = value;
          break;

        case 3:
          this.w = value;
          break;

        default:
          throw new Error('index is out of range: ' + index);
      }

      return this;
    },
    getComponent: function getComponent(index) {
      switch (index) {
        case 0:
          return this.x;

        case 1:
          return this.y;

        case 2:
          return this.z;

        case 3:
          return this.w;

        default:
          throw new Error('index is out of range: ' + index);
      }
    },
    clone: function clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.w !== undefined ? v.w : 1;
      return this;
    },
    add: function add(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
        return this.addVectors(v, w);
      }

      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    },
    addScalar: function addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      this.w += s;
      return this;
    },
    addVectors: function addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    },
    addScaledVector: function addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      this.w += v.w * s;
      return this;
    },
    sub: function sub(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
        return this.subVectors(v, w);
      }

      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    },
    subScalar: function subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      this.w -= s;
      return this;
    },
    subVectors: function subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    },
    multiplyScalar: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    },
    applyMatrix4: function applyMatrix4(m) {
      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    },
    divideScalar: function divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    },
    setAxisAngleFromQuaternion: function setAxisAngleFromQuaternion(q) {
      this.w = 2 * Math.acos(q.w);
      var s = Math.sqrt(1 - q.w * q.w);

      if (s < 0.0001) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q.x / s;
        this.y = q.y / s;
        this.z = q.z / s;
      }

      return this;
    },
    setAxisAngleFromRotationMatrix: function setAxisAngleFromRotationMatrix(m) {
      var angle,
          x,
          y,
          z,
          epsilon = 0.01,
          epsilon2 = 0.1,
          te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10];

      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          this.set(1, 0, 0, 0);
          return this;
        }

        angle = Math.PI;
        var xx = (m11 + 1) / 2;
        var yy = (m22 + 1) / 2;
        var zz = (m33 + 1) / 2;
        var xy = (m12 + m21) / 4;
        var xz = (m13 + m31) / 4;
        var yz = (m23 + m32) / 4;

        if (xx > yy && xx > zz) {
          if (xx < epsilon) {
            x = 0;
            y = 0.707106781;
            z = 0.707106781;
          } else {
            x = Math.sqrt(xx);
            y = xy / x;
            z = xz / x;
          }
        } else if (yy > zz) {
          if (yy < epsilon) {
            x = 0.707106781;
            y = 0;
            z = 0.707106781;
          } else {
            y = Math.sqrt(yy);
            x = xy / y;
            z = yz / y;
          }
        } else {
          if (zz < epsilon) {
            x = 0.707106781;
            y = 0.707106781;
            z = 0;
          } else {
            z = Math.sqrt(zz);
            x = xz / z;
            y = yz / z;
          }
        }

        this.set(x, y, z, angle);
        return this;
      }

      var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
      if (Math.abs(s) < 0.001) s = 1;
      this.x = (m32 - m23) / s;
      this.y = (m13 - m31) / s;
      this.z = (m21 - m12) / s;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    },
    min: function min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      this.w = Math.min(this.w, v.w);
      return this;
    },
    max: function max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      this.w = Math.max(this.w, v.w);
      return this;
    },
    clamp: function clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      this.w = Math.max(min.w, Math.min(max.w, this.w));
      return this;
    },
    clampScalar: function clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      this.w = Math.max(minVal, Math.min(maxVal, this.w));
      return this;
    },
    clampLength: function clampLength(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    },
    floor: function floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    },
    ceil: function ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    },
    round: function round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    },
    roundToZero: function roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
      return this;
    },
    negate: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    },
    dot: function dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },
    lengthSq: function lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    },
    manhattanLength: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function normalize() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function setLength(length) {
      return this.normalize().multiplyScalar(length);
    },
    lerp: function lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      this.w += (v.w - this.w) * alpha;
      return this;
    },
    lerpVectors: function lerpVectors(v1, v2, alpha) {
      return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    },
    equals: function equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    },
    fromArray: function fromArray(array, offset) {
      if (offset === undefined) offset = 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    },
    toArray: function toArray(array, offset) {
      if (array === undefined) array = [];
      if (offset === undefined) offset = 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    },
    fromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {
      if (offset !== undefined) {
        console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
      }

      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      this.w = attribute.getW(index);
      return this;
    }
  });

  function WebGLRenderTarget(width, height, options) {
    this.width = width;
    this.height = height;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options = options || {};
    this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.image = {};
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
  }

  WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: WebGLRenderTarget,
    isWebGLRenderTarget: true,
    setSize: function setSize(width, height) {
      if (this.width !== width || this.height !== height) {
        this.width = width;
        this.height = height;
        this.texture.image.width = width;
        this.texture.image.height = height;
        this.dispose();
      }

      this.viewport.set(0, 0, width, height);
      this.scissor.set(0, 0, width, height);
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(source) {
      this.width = source.width;
      this.height = source.height;
      this.viewport.copy(source.viewport);
      this.texture = source.texture.clone();
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.depthTexture = source.depthTexture;
      return this;
    },
    dispose: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  });

  function WebGLMultisampleRenderTarget(width, height, options) {
    WebGLRenderTarget.call(this, width, height, options);
    this.samples = 4;
  }

  WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
    constructor: WebGLMultisampleRenderTarget,
    isWebGLMultisampleRenderTarget: true,
    copy: function copy(source) {
      WebGLRenderTarget.prototype.copy.call(this, source);
      this.samples = source.samples;
      return this;
    }
  });

  function Quaternion(x, y, z, w) {
    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._w = w !== undefined ? w : 1;
  }

  Object.assign(Quaternion, {
    slerp: function slerp(qa, qb, qm, t) {
      return qm.copy(qa).slerp(qb, t);
    },
    slerpFlat: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      var x0 = src0[srcOffset0 + 0],
          y0 = src0[srcOffset0 + 1],
          z0 = src0[srcOffset0 + 2],
          w0 = src0[srcOffset0 + 3],
          x1 = src1[srcOffset1 + 0],
          y1 = src1[srcOffset1 + 1],
          z1 = src1[srcOffset1 + 2],
          w1 = src1[srcOffset1 + 3];

      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        var s = 1 - t,
            cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
            dir = cos >= 0 ? 1 : -1,
            sqrSin = 1 - cos * cos;

        if (sqrSin > Number.EPSILON) {
          var sin = Math.sqrt(sqrSin),
              len = Math.atan2(sin, cos * dir);
          s = Math.sin(s * len) / sin;
          t = Math.sin(t * len) / sin;
        }

        var tDir = t * dir;
        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir;

        if (s === 1 - t) {
          var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }

      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
  });
  Object.defineProperties(Quaternion.prototype, {
    x: {
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;

        this._onChangeCallback();
      }
    },
    y: {
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;

        this._onChangeCallback();
      }
    },
    z: {
      get: function get() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;

        this._onChangeCallback();
      }
    },
    w: {
      get: function get() {
        return this._w;
      },
      set: function set(value) {
        this._w = value;

        this._onChangeCallback();
      }
    }
  });
  Object.assign(Quaternion.prototype, {
    isQuaternion: true,
    set: function set(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;

      this._onChangeCallback();

      return this;
    },
    clone: function clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    },
    copy: function copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;

      this._onChangeCallback();

      return this;
    },
    setFromEuler: function setFromEuler(euler, update) {
      if (!(euler && euler.isEuler)) {
        throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
      }

      var x = euler._x,
          y = euler._y,
          z = euler._z,
          order = euler.order;
      var cos = Math.cos;
      var sin = Math.sin;
      var c1 = cos(x / 2);
      var c2 = cos(y / 2);
      var c3 = cos(z / 2);
      var s1 = sin(x / 2);
      var s2 = sin(y / 2);
      var s3 = sin(z / 2);

      if (order === 'XYZ') {
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
      } else if (order === 'YXZ') {
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
      } else if (order === 'ZXY') {
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
      } else if (order === 'ZYX') {
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
      } else if (order === 'YZX') {
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
      } else if (order === 'XZY') {
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
      }

      if (update !== false) this._onChangeCallback();
      return this;
    },
    setFromAxisAngle: function setFromAxisAngle(axis, angle) {
      var halfAngle = angle / 2,
          s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);

      this._onChangeCallback();

      return this;
    },
    setFromRotationMatrix: function setFromRotationMatrix(m) {
      var te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33,
          s;

      if (trace > 0) {
        s = 0.5 / Math.sqrt(trace + 1.0);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
        this._w = (m32 - m23) / s;
        this._x = 0.25 * s;
        this._y = (m12 + m21) / s;
        this._z = (m13 + m31) / s;
      } else if (m22 > m33) {
        s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
        this._w = (m13 - m31) / s;
        this._x = (m12 + m21) / s;
        this._y = 0.25 * s;
        this._z = (m23 + m32) / s;
      } else {
        s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
        this._w = (m21 - m12) / s;
        this._x = (m13 + m31) / s;
        this._y = (m23 + m32) / s;
        this._z = 0.25 * s;
      }

      this._onChangeCallback();

      return this;
    },
    setFromUnitVectors: function setFromUnitVectors(vFrom, vTo) {
      var EPS = 0.000001;
      var r = vFrom.dot(vTo) + 1;

      if (r < EPS) {
        r = 0;

        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }

      return this.normalize();
    },
    angleTo: function angleTo(q) {
      return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
    },
    rotateTowards: function rotateTowards(q, step) {
      var angle = this.angleTo(q);
      if (angle === 0) return this;
      var t = Math.min(1, step / angle);
      this.slerp(q, t);
      return this;
    },
    inverse: function inverse() {
      return this.conjugate();
    },
    conjugate: function conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;

      this._onChangeCallback();

      return this;
    },
    dot: function dot(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    },
    lengthSq: function lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    },
    normalize: function normalize() {
      var l = this.length();

      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }

      this._onChangeCallback();

      return this;
    },
    multiply: function multiply(q, p) {
      if (p !== undefined) {
        console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
        return this.multiplyQuaternions(q, p);
      }

      return this.multiplyQuaternions(this, q);
    },
    premultiply: function premultiply(q) {
      return this.multiplyQuaternions(q, this);
    },
    multiplyQuaternions: function multiplyQuaternions(a, b) {
      var qax = a._x,
          qay = a._y,
          qaz = a._z,
          qaw = a._w;
      var qbx = b._x,
          qby = b._y,
          qbz = b._z,
          qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

      this._onChangeCallback();

      return this;
    },
    slerp: function slerp(qb, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(qb);
      var x = this._x,
          y = this._y,
          z = this._z,
          w = this._w;
      var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }

      if (cosHalfTheta >= 1.0) {
        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;
        return this;
      }

      var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

      if (sqrSinHalfTheta <= Number.EPSILON) {
        var s = 1 - t;
        this._w = s * w + t * this._w;
        this._x = s * x + t * this._x;
        this._y = s * y + t * this._y;
        this._z = s * z + t * this._z;
        this.normalize();

        this._onChangeCallback();

        return this;
      }

      var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;

      this._onChangeCallback();

      return this;
    },
    equals: function equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    },
    fromArray: function fromArray(array, offset) {
      if (offset === undefined) offset = 0;
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];

      this._onChangeCallback();

      return this;
    },
    toArray: function toArray(array, offset) {
      if (array === undefined) array = [];
      if (offset === undefined) offset = 0;
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    },
    _onChange: function _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    },
    _onChangeCallback: function _onChangeCallback() {}
  });

  var _vector = new Vector3();

  var _quaternion = new Quaternion();

  function Vector3(x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
  }

  Object.assign(Vector3.prototype, {
    isVector3: true,
    set: function set(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    },
    setScalar: function setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    },
    setX: function setX(x) {
      this.x = x;
      return this;
    },
    setY: function setY(y) {
      this.y = y;
      return this;
    },
    setZ: function setZ(z) {
      this.z = z;
      return this;
    },
    setComponent: function setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;

        case 1:
          this.y = value;
          break;

        case 2:
          this.z = value;
          break;

        default:
          throw new Error('index is out of range: ' + index);
      }

      return this;
    },
    getComponent: function getComponent(index) {
      switch (index) {
        case 0:
          return this.x;

        case 1:
          return this.y;

        case 2:
          return this.z;

        default:
          throw new Error('index is out of range: ' + index);
      }
    },
    clone: function clone() {
      return new this.constructor(this.x, this.y, this.z);
    },
    copy: function copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    },
    add: function add(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
        return this.addVectors(v, w);
      }

      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    },
    addScalar: function addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    },
    addVectors: function addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    },
    addScaledVector: function addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    },
    sub: function sub(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
        return this.subVectors(v, w);
      }

      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    },
    subScalar: function subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    },
    subVectors: function subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    },
    multiply: function multiply(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
        return this.multiplyVectors(v, w);
      }

      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    },
    multiplyScalar: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    },
    multiplyVectors: function multiplyVectors(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    },
    applyEuler: function applyEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
      }

      return this.applyQuaternion(_quaternion.setFromEuler(euler));
    },
    applyAxisAngle: function applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
    },
    applyMatrix3: function applyMatrix3(m) {
      var x = this.x,
          y = this.y,
          z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    },
    applyNormalMatrix: function applyNormalMatrix(m) {
      return this.applyMatrix3(m).normalize();
    },
    applyMatrix4: function applyMatrix4(m) {
      var x = this.x,
          y = this.y,
          z = this.z;
      var e = m.elements;
      var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    },
    applyQuaternion: function applyQuaternion(q) {
      var x = this.x,
          y = this.y,
          z = this.z;
      var qx = q.x,
          qy = q.y,
          qz = q.z,
          qw = q.w;
      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z;
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    },
    project: function project(camera) {
      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    },
    unproject: function unproject(camera) {
      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    },
    transformDirection: function transformDirection(m) {
      var x = this.x,
          y = this.y,
          z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    },
    divide: function divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    },
    divideScalar: function divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    },
    min: function min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    },
    max: function max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    },
    clamp: function clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    },
    clampScalar: function clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      return this;
    },
    clampLength: function clampLength(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    },
    floor: function floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    },
    ceil: function ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    },
    round: function round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    },
    roundToZero: function roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      return this;
    },
    negate: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    },
    dot: function dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    },
    lengthSq: function lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    manhattanLength: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function normalize() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function setLength(length) {
      return this.normalize().multiplyScalar(length);
    },
    lerp: function lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    },
    lerpVectors: function lerpVectors(v1, v2, alpha) {
      return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    },
    cross: function cross(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
        return this.crossVectors(v, w);
      }

      return this.crossVectors(this, v);
    },
    crossVectors: function crossVectors(a, b) {
      var ax = a.x,
          ay = a.y,
          az = a.z;
      var bx = b.x,
          by = b.y,
          bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    },
    projectOnVector: function projectOnVector(v) {
      var denominator = v.lengthSq();
      if (denominator === 0) return this.set(0, 0, 0);
      var scalar = v.dot(this) / denominator;
      return this.copy(v).multiplyScalar(scalar);
    },
    projectOnPlane: function projectOnPlane(planeNormal) {
      _vector.copy(this).projectOnVector(planeNormal);

      return this.sub(_vector);
    },
    reflect: function reflect(normal) {
      return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
    },
    angleTo: function angleTo(v) {
      var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0) return Math.PI / 2;
      var theta = this.dot(v) / denominator;
      return Math.acos(MathUtils.clamp(theta, -1, 1));
    },
    distanceTo: function distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function distanceToSquared(v) {
      var dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    },
    manhattanDistanceTo: function manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    },
    setFromSpherical: function setFromSpherical(s) {
      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    },
    setFromSphericalCoords: function setFromSphericalCoords(radius, phi, theta) {
      var sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    },
    setFromCylindrical: function setFromCylindrical(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    },
    setFromCylindricalCoords: function setFromCylindricalCoords(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    },
    setFromMatrixPosition: function setFromMatrixPosition(m) {
      var e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    },
    setFromMatrixScale: function setFromMatrixScale(m) {
      var sx = this.setFromMatrixColumn(m, 0).length();
      var sy = this.setFromMatrixColumn(m, 1).length();
      var sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    },
    setFromMatrixColumn: function setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    },
    setFromMatrix3Column: function setFromMatrix3Column(m, index) {
      return this.fromArray(m.elements, index * 3);
    },
    equals: function equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    },
    fromArray: function fromArray(array, offset) {
      if (offset === undefined) offset = 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    },
    toArray: function toArray(array, offset) {
      if (array === undefined) array = [];
      if (offset === undefined) offset = 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    },
    fromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {
      if (offset !== undefined) {
        console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
      }

      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
  });

  var _v1 = new Vector3();

  var _m1 = new Matrix4();

  var _zero = new Vector3(0, 0, 0);

  var _one = new Vector3(1, 1, 1);

  var _x = new Vector3();

  var _y = new Vector3();

  var _z = new Vector3();

  function Matrix4() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

    if (arguments.length > 0) {
      console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
  }

  Object.assign(Matrix4.prototype, {
    isMatrix4: true,
    set: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      var te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    },
    identity: function identity() {
      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    },
    clone: function clone() {
      return new Matrix4().fromArray(this.elements);
    },
    copy: function copy(m) {
      var te = this.elements;
      var me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      te[9] = me[9];
      te[10] = me[10];
      te[11] = me[11];
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      te[15] = me[15];
      return this;
    },
    copyPosition: function copyPosition(m) {
      var te = this.elements,
          me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    },
    extractBasis: function extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    },
    makeBasis: function makeBasis(xAxis, yAxis, zAxis) {
      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      return this;
    },
    extractRotation: function extractRotation(m) {
      var te = this.elements;
      var me = m.elements;

      var scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();

      var scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();

      var scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();

      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    },
    makeRotationFromEuler: function makeRotationFromEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
      }

      var te = this.elements;
      var x = euler.x,
          y = euler.y,
          z = euler.z;
      var a = Math.cos(x),
          b = Math.sin(x);
      var c = Math.cos(y),
          d = Math.sin(y);
      var e = Math.cos(z),
          f = Math.sin(z);

      if (euler.order === 'XYZ') {
        var ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler.order === 'YXZ') {
        var ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
        te[0] = ce + df * b;
        te[4] = de * b - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b;
        te[2] = cf * b - de;
        te[6] = df + ce * b;
        te[10] = a * c;
      } else if (euler.order === 'ZXY') {
        var ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
        te[0] = ce - df * b;
        te[4] = -a * f;
        te[8] = de + cf * b;
        te[1] = cf + de * b;
        te[5] = a * e;
        te[9] = df - ce * b;
        te[2] = -a * d;
        te[6] = b;
        te[10] = a * c;
      } else if (euler.order === 'ZYX') {
        var ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
        te[0] = c * e;
        te[4] = be * d - af;
        te[8] = ae * d + bf;
        te[1] = c * f;
        te[5] = bf * d + ae;
        te[9] = af * d - be;
        te[2] = -d;
        te[6] = b * c;
        te[10] = a * c;
      } else if (euler.order === 'YZX') {
        var ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler.order === 'XZY') {
        var ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = ac * f + bd;
        te[5] = a * e;
        te[9] = ad * f - bc;
        te[2] = bc * f - ad;
        te[6] = b * e;
        te[10] = bd * f + ac;
      }

      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    },
    makeRotationFromQuaternion: function makeRotationFromQuaternion(q) {
      return this.compose(_zero, q, _one);
    },
    lookAt: function lookAt(eye, target, up) {
      var te = this.elements;

      _z.subVectors(eye, target);

      if (_z.lengthSq() === 0) {
        _z.z = 1;
      }

      _z.normalize();

      _x.crossVectors(up, _z);

      if (_x.lengthSq() === 0) {
        if (Math.abs(up.z) === 1) {
          _z.x += 0.0001;
        } else {
          _z.z += 0.0001;
        }

        _z.normalize();

        _x.crossVectors(up, _z);
      }

      _x.normalize();

      _y.crossVectors(_z, _x);

      te[0] = _x.x;
      te[4] = _y.x;
      te[8] = _z.x;
      te[1] = _x.y;
      te[5] = _y.y;
      te[9] = _z.y;
      te[2] = _x.z;
      te[6] = _y.z;
      te[10] = _z.z;
      return this;
    },
    multiply: function multiply(m, n) {
      if (n !== undefined) {
        console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
        return this.multiplyMatrices(m, n);
      }

      return this.multiplyMatrices(this, m);
    },
    premultiply: function premultiply(m) {
      return this.multiplyMatrices(m, this);
    },
    multiplyMatrices: function multiplyMatrices(a, b) {
      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;
      var a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
      var a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
      var a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
      var a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
      var b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
      var b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
      var b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
      var b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    },
    multiplyScalar: function multiplyScalar(s) {
      var te = this.elements;
      te[0] *= s;
      te[4] *= s;
      te[8] *= s;
      te[12] *= s;
      te[1] *= s;
      te[5] *= s;
      te[9] *= s;
      te[13] *= s;
      te[2] *= s;
      te[6] *= s;
      te[10] *= s;
      te[14] *= s;
      te[3] *= s;
      te[7] *= s;
      te[11] *= s;
      te[15] *= s;
      return this;
    },
    determinant: function determinant() {
      var te = this.elements;
      var n11 = te[0],
          n12 = te[4],
          n13 = te[8],
          n14 = te[12];
      var n21 = te[1],
          n22 = te[5],
          n23 = te[9],
          n24 = te[13];
      var n31 = te[2],
          n32 = te[6],
          n33 = te[10],
          n34 = te[14];
      var n41 = te[3],
          n42 = te[7],
          n43 = te[11],
          n44 = te[15];
      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    },
    transpose: function transpose() {
      var te = this.elements;
      var tmp;
      tmp = te[1];
      te[1] = te[4];
      te[4] = tmp;
      tmp = te[2];
      te[2] = te[8];
      te[8] = tmp;
      tmp = te[6];
      te[6] = te[9];
      te[9] = tmp;
      tmp = te[3];
      te[3] = te[12];
      te[12] = tmp;
      tmp = te[7];
      te[7] = te[13];
      te[13] = tmp;
      tmp = te[11];
      te[11] = te[14];
      te[14] = tmp;
      return this;
    },
    setPosition: function setPosition(x, y, z) {
      var te = this.elements;

      if (x.isVector3) {
        te[12] = x.x;
        te[13] = x.y;
        te[14] = x.z;
      } else {
        te[12] = x;
        te[13] = y;
        te[14] = z;
      }

      return this;
    },
    getInverse: function getInverse(m, throwOnDegenerate) {
      var te = this.elements,
          me = m.elements,
          n11 = me[0],
          n21 = me[1],
          n31 = me[2],
          n41 = me[3],
          n12 = me[4],
          n22 = me[5],
          n32 = me[6],
          n42 = me[7],
          n13 = me[8],
          n23 = me[9],
          n33 = me[10],
          n43 = me[11],
          n14 = me[12],
          n24 = me[13],
          n34 = me[14],
          n44 = me[15],
          t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
          t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
          t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
          t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

      if (det === 0) {
        var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

        if (throwOnDegenerate === true) {
          throw new Error(msg);
        } else {
          console.warn(msg);
        }

        return this.identity();
      }

      var detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    },
    scale: function scale(v) {
      var te = this.elements;
      var x = v.x,
          y = v.y,
          z = v.z;
      te[0] *= x;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x;
      te[7] *= y;
      te[11] *= z;
      return this;
    },
    getMaxScaleOnAxis: function getMaxScaleOnAxis() {
      var te = this.elements;
      var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    },
    makeTranslation: function makeTranslation(x, y, z) {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
      return this;
    },
    makeRotationX: function makeRotationX(theta) {
      var c = Math.cos(theta),
          s = Math.sin(theta);
      this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
      return this;
    },
    makeRotationY: function makeRotationY(theta) {
      var c = Math.cos(theta),
          s = Math.sin(theta);
      this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
      return this;
    },
    makeRotationZ: function makeRotationZ(theta) {
      var c = Math.cos(theta),
          s = Math.sin(theta);
      this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    },
    makeRotationAxis: function makeRotationAxis(axis, angle) {
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      var t = 1 - c;
      var x = axis.x,
          y = axis.y,
          z = axis.z;
      var tx = t * x,
          ty = t * y;
      this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
      return this;
    },
    makeScale: function makeScale(x, y, z) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
      return this;
    },
    makeShear: function makeShear(x, y, z) {
      this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
      return this;
    },
    compose: function compose(position, quaternion, scale) {
      var te = this.elements;
      var x = quaternion._x,
          y = quaternion._y,
          z = quaternion._z,
          w = quaternion._w;
      var x2 = x + x,
          y2 = y + y,
          z2 = z + z;
      var xx = x * x2,
          xy = x * y2,
          xz = x * z2;
      var yy = y * y2,
          yz = y * z2,
          zz = z * z2;
      var wx = w * x2,
          wy = w * y2,
          wz = w * z2;
      var sx = scale.x,
          sy = scale.y,
          sz = scale.z;
      te[0] = (1 - (yy + zz)) * sx;
      te[1] = (xy + wz) * sx;
      te[2] = (xz - wy) * sx;
      te[3] = 0;
      te[4] = (xy - wz) * sy;
      te[5] = (1 - (xx + zz)) * sy;
      te[6] = (yz + wx) * sy;
      te[7] = 0;
      te[8] = (xz + wy) * sz;
      te[9] = (yz - wx) * sz;
      te[10] = (1 - (xx + yy)) * sz;
      te[11] = 0;
      te[12] = position.x;
      te[13] = position.y;
      te[14] = position.z;
      te[15] = 1;
      return this;
    },
    decompose: function decompose(position, quaternion, scale) {
      var te = this.elements;

      var sx = _v1.set(te[0], te[1], te[2]).length();

      var sy = _v1.set(te[4], te[5], te[6]).length();

      var sz = _v1.set(te[8], te[9], te[10]).length();

      var det = this.determinant();
      if (det < 0) sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];

      _m1.copy(this);

      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      _m1.elements[0] *= invSX;
      _m1.elements[1] *= invSX;
      _m1.elements[2] *= invSX;
      _m1.elements[4] *= invSY;
      _m1.elements[5] *= invSY;
      _m1.elements[6] *= invSY;
      _m1.elements[8] *= invSZ;
      _m1.elements[9] *= invSZ;
      _m1.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(_m1);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    },
    makePerspective: function makePerspective(left, right, top, bottom, near, far) {
      if (far === undefined) {
        console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
      }

      var te = this.elements;
      var x = 2 * near / (right - left);
      var y = 2 * near / (top - bottom);
      var a = (right + left) / (right - left);
      var b = (top + bottom) / (top - bottom);
      var c = -(far + near) / (far - near);
      var d = -2 * far * near / (far - near);
      te[0] = x;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    },
    makeOrthographic: function makeOrthographic(left, right, top, bottom, near, far) {
      var te = this.elements;
      var w = 1.0 / (right - left);
      var h = 1.0 / (top - bottom);
      var p = 1.0 / (far - near);
      var x = (right + left) * w;
      var y = (top + bottom) * h;
      var z = (far + near) * p;
      te[0] = 2 * w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = 2 * h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = -2 * p;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    },
    equals: function equals(matrix) {
      var te = this.elements;
      var me = matrix.elements;

      for (var i = 0; i < 16; i++) {
        if (te[i] !== me[i]) return false;
      }

      return true;
    },
    fromArray: function fromArray(array, offset) {
      if (offset === undefined) offset = 0;

      for (var i = 0; i < 16; i++) {
        this.elements[i] = array[i + offset];
      }

      return this;
    },
    toArray: function toArray(array, offset) {
      if (array === undefined) array = [];
      if (offset === undefined) offset = 0;
      var te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
  });

  var _matrix = new Matrix4();

  var _quaternion$1 = new Quaternion();

  function Euler(x, y, z, order) {
    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._order = order || Euler.DefaultOrder;
  }

  Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
  Euler.DefaultOrder = 'XYZ';
  Object.defineProperties(Euler.prototype, {
    x: {
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;

        this._onChangeCallback();
      }
    },
    y: {
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;

        this._onChangeCallback();
      }
    },
    z: {
      get: function get() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;

        this._onChangeCallback();
      }
    },
    order: {
      get: function get() {
        return this._order;
      },
      set: function set(value) {
        this._order = value;

        this._onChangeCallback();
      }
    }
  });
  Object.assign(Euler.prototype, {
    isEuler: true,
    set: function set(x, y, z, order) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order || this._order;

      this._onChangeCallback();

      return this;
    },
    clone: function clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    },
    copy: function copy(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;

      this._onChangeCallback();

      return this;
    },
    setFromRotationMatrix: function setFromRotationMatrix(m, order, update) {
      var clamp = MathUtils.clamp;
      var te = m.elements;
      var m11 = te[0],
          m12 = te[4],
          m13 = te[8];
      var m21 = te[1],
          m22 = te[5],
          m23 = te[9];
      var m31 = te[2],
          m32 = te[6],
          m33 = te[10];
      order = order || this._order;

      if (order === 'XYZ') {
        this._y = Math.asin(clamp(m13, -1, 1));

        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
      } else if (order === 'YXZ') {
        this._x = Math.asin(-clamp(m23, -1, 1));

        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
      } else if (order === 'ZXY') {
        this._x = Math.asin(clamp(m32, -1, 1));

        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
      } else if (order === 'ZYX') {
        this._y = Math.asin(-clamp(m31, -1, 1));

        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
      } else if (order === 'YZX') {
        this._z = Math.asin(clamp(m21, -1, 1));

        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
      } else if (order === 'XZY') {
        this._z = Math.asin(-clamp(m12, -1, 1));

        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
      } else {
        console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
      }

      this._order = order;
      if (update !== false) this._onChangeCallback();
      return this;
    },
    setFromQuaternion: function setFromQuaternion(q, order, update) {
      _matrix.makeRotationFromQuaternion(q);

      return this.setFromRotationMatrix(_matrix, order, update);
    },
    setFromVector3: function setFromVector3(v, order) {
      return this.set(v.x, v.y, v.z, order || this._order);
    },
    reorder: function reorder(newOrder) {
      _quaternion$1.setFromEuler(this);

      return this.setFromQuaternion(_quaternion$1, newOrder);
    },
    equals: function equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    },
    fromArray: function fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== undefined) this._order = array[3];

      this._onChangeCallback();

      return this;
    },
    toArray: function toArray(array, offset) {
      if (array === undefined) array = [];
      if (offset === undefined) offset = 0;
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    },
    toVector3: function toVector3(optionalResult) {
      if (optionalResult) {
        return optionalResult.set(this._x, this._y, this._z);
      } else {
        return new Vector3(this._x, this._y, this._z);
      }
    },
    _onChange: function _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    },
    _onChangeCallback: function _onChangeCallback() {}
  });

  function Layers() {
    this.mask = 1 | 0;
  }

  Object.assign(Layers.prototype, {
    set: function set(channel) {
      this.mask = 1 << channel | 0;
    },
    enable: function enable(channel) {
      this.mask |= 1 << channel | 0;
    },
    enableAll: function enableAll() {
      this.mask = 0xffffffff | 0;
    },
    toggle: function toggle(channel) {
      this.mask ^= 1 << channel | 0;
    },
    disable: function disable(channel) {
      this.mask &= ~(1 << channel | 0);
    },
    disableAll: function disableAll() {
      this.mask = 0;
    },
    test: function test(layers) {
      return (this.mask & layers.mask) !== 0;
    }
  });
  var _object3DId = 0;

  var _v1$1 = new Vector3();

  var _q1 = new Quaternion();

  var _m1$1 = new Matrix4();

  var _target = new Vector3();

  var _position = new Vector3();

  var _scale = new Vector3();

  var _quaternion$2 = new Quaternion();

  var _xAxis = new Vector3(1, 0, 0);

  var _yAxis = new Vector3(0, 1, 0);

  var _zAxis = new Vector3(0, 0, 1);

  var _addedEvent = {
    type: 'added'
  };
  var _removedEvent = {
    type: 'removed'
  };

  function Object3D() {
    Object.defineProperty(this, 'id', {
      value: _object3DId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    var position = new Vector3();
    var rotation = new Euler();
    var quaternion = new Quaternion();
    var scale = new Vector3(1, 1, 1);

    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }

    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, undefined, false);
    }

    rotation._onChange(onRotationChange);

    quaternion._onChange(onQuaternionChange);

    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = {};
  }

  Object3D.DefaultUp = new Vector3(0, 1, 0);
  Object3D.DefaultMatrixAutoUpdate = true;
  Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Object3D,
    isObject3D: true,
    onBeforeRender: function onBeforeRender() {},
    onAfterRender: function onAfterRender() {},
    applyMatrix4: function applyMatrix4(matrix) {
      if (this.matrixAutoUpdate) this.updateMatrix();
      this.matrix.premultiply(matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function applyQuaternion(q) {
      this.quaternion.premultiply(q);
      return this;
    },
    setRotationFromAxisAngle: function setRotationFromAxisAngle(axis, angle) {
      this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function setRotationFromEuler(euler) {
      this.quaternion.setFromEuler(euler, true);
    },
    setRotationFromMatrix: function setRotationFromMatrix(m) {
      this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function setRotationFromQuaternion(q) {
      this.quaternion.copy(q);
    },
    rotateOnAxis: function rotateOnAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);

      this.quaternion.multiply(_q1);
      return this;
    },
    rotateOnWorldAxis: function rotateOnWorldAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);

      this.quaternion.premultiply(_q1);
      return this;
    },
    rotateX: function rotateX(angle) {
      return this.rotateOnAxis(_xAxis, angle);
    },
    rotateY: function rotateY(angle) {
      return this.rotateOnAxis(_yAxis, angle);
    },
    rotateZ: function rotateZ(angle) {
      return this.rotateOnAxis(_zAxis, angle);
    },
    translateOnAxis: function translateOnAxis(axis, distance) {
      _v1$1.copy(axis).applyQuaternion(this.quaternion);

      this.position.add(_v1$1.multiplyScalar(distance));
      return this;
    },
    translateX: function translateX(distance) {
      return this.translateOnAxis(_xAxis, distance);
    },
    translateY: function translateY(distance) {
      return this.translateOnAxis(_yAxis, distance);
    },
    translateZ: function translateZ(distance) {
      return this.translateOnAxis(_zAxis, distance);
    },
    localToWorld: function localToWorld(vector) {
      return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function worldToLocal(vector) {
      return vector.applyMatrix4(_m1$1.getInverse(this.matrixWorld));
    },
    lookAt: function lookAt(x, y, z) {
      if (x.isVector3) {
        _target.copy(x);
      } else {
        _target.set(x, y, z);
      }

      var parent = this.parent;
      this.updateWorldMatrix(true, false);

      _position.setFromMatrixPosition(this.matrixWorld);

      if (this.isCamera || this.isLight) {
        _m1$1.lookAt(_position, _target, this.up);
      } else {
        _m1$1.lookAt(_target, _position, this.up);
      }

      this.quaternion.setFromRotationMatrix(_m1$1);

      if (parent) {
        _m1$1.extractRotation(parent.matrixWorld);

        _q1.setFromRotationMatrix(_m1$1);

        this.quaternion.premultiply(_q1.inverse());
      }
    },
    add: function add(object) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }

        return this;
      }

      if (object === this) {
        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
        return this;
      }

      if (object && object.isObject3D) {
        if (object.parent !== null) {
          object.parent.remove(object);
        }

        object.parent = this;
        this.children.push(object);
        object.dispatchEvent(_addedEvent);
      } else {
        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
      }

      return this;
    },
    remove: function remove(object) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.remove(arguments[i]);
        }

        return this;
      }

      var index = this.children.indexOf(object);

      if (index !== -1) {
        object.parent = null;
        this.children.splice(index, 1);
        object.dispatchEvent(_removedEvent);
      }

      return this;
    },
    attach: function attach(object) {
      this.updateWorldMatrix(true, false);

      _m1$1.getInverse(this.matrixWorld);

      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);

        _m1$1.multiply(object.parent.matrixWorld);
      }

      object.applyMatrix4(_m1$1);
      object.updateWorldMatrix(false, false);
      this.add(object);
      return this;
    },
    getObjectById: function getObjectById(id) {
      return this.getObjectByProperty('id', id);
    },
    getObjectByName: function getObjectByName(name) {
      return this.getObjectByProperty('name', name);
    },
    getObjectByProperty: function getObjectByProperty(name, value) {
      if (this[name] === value) return this;

      for (var i = 0, l = this.children.length; i < l; i++) {
        var child = this.children[i];
        var object = child.getObjectByProperty(name, value);

        if (object !== undefined) {
          return object;
        }
      }

      return undefined;
    },
    getWorldPosition: function getWorldPosition(target) {
      if (target === undefined) {
        console.warn('THREE.Object3D: .getWorldPosition() target is now required');
        target = new Vector3();
      }

      this.updateMatrixWorld(true);
      return target.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function getWorldQuaternion(target) {
      if (target === undefined) {
        console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
        target = new Quaternion();
      }

      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(_position, target, _scale);
      return target;
    },
    getWorldScale: function getWorldScale(target) {
      if (target === undefined) {
        console.warn('THREE.Object3D: .getWorldScale() target is now required');
        target = new Vector3();
      }

      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(_position, _quaternion$2, target);
      return target;
    },
    getWorldDirection: function getWorldDirection(target) {
      if (target === undefined) {
        console.warn('THREE.Object3D: .getWorldDirection() target is now required');
        target = new Vector3();
      }

      this.updateMatrixWorld(true);
      var e = this.matrixWorld.elements;
      return target.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function raycast() {},
    traverse: function traverse(callback) {
      callback(this);
      var children = this.children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].traverse(callback);
      }
    },
    traverseVisible: function traverseVisible(callback) {
      if (this.visible === false) return;
      callback(this);
      var children = this.children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].traverseVisible(callback);
      }
    },
    traverseAncestors: function traverseAncestors(callback) {
      var parent = this.parent;

      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    },
    updateMatrix: function updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function updateMatrixWorld(force) {
      if (this.matrixAutoUpdate) this.updateMatrix();

      if (this.matrixWorldNeedsUpdate || force) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }

        this.matrixWorldNeedsUpdate = false;
        force = true;
      }

      var children = this.children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(force);
      }
    },
    updateWorldMatrix: function updateWorldMatrix(updateParents, updateChildren) {
      var parent = this.parent;

      if (updateParents === true && parent !== null) {
        parent.updateWorldMatrix(true, false);
      }

      if (this.matrixAutoUpdate) this.updateMatrix();

      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      if (updateChildren === true) {
        var children = this.children;

        for (var i = 0, l = children.length; i < l; i++) {
          children[i].updateWorldMatrix(false, true);
        }
      }
    },
    toJSON: function toJSON(meta) {
      var isRootObject = meta === undefined || typeof meta === 'string';
      var output = {};

      if (isRootObject) {
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {}
        };
        output.metadata = {
          version: 4.5,
          type: 'Object',
          generator: 'Object3D.toJSON'
        };
      }

      var object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== '') object.name = this.name;
      if (this.castShadow === true) object.castShadow = true;
      if (this.receiveShadow === true) object.receiveShadow = true;
      if (this.visible === false) object.visible = false;
      if (this.frustumCulled === false) object.frustumCulled = false;
      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
      if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

      if (this.isInstancedMesh) {
        object.type = 'InstancedMesh';
        object.count = this.count;
        object.instanceMatrix = this.instanceMatrix.toJSON();
      }

      function serialize(library, element) {
        if (library[element.uuid] === undefined) {
          library[element.uuid] = element.toJSON(meta);
        }

        return element.uuid;
      }

      if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        var parameters = this.geometry.parameters;

        if (parameters !== undefined && parameters.shapes !== undefined) {
          var shapes = parameters.shapes;

          if (Array.isArray(shapes)) {
            for (var i = 0, l = shapes.length; i < l; i++) {
              var shape = shapes[i];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }

      if (this.material !== undefined) {
        if (Array.isArray(this.material)) {
          var uuids = [];

          for (var i = 0, l = this.material.length; i < l; i++) {
            uuids.push(serialize(meta.materials, this.material[i]));
          }

          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      }

      if (this.children.length > 0) {
        object.children = [];

        for (var i = 0; i < this.children.length; i++) {
          object.children.push(this.children[i].toJSON(meta).object);
        }
      }

      if (isRootObject) {
        var geometries = extractFromCache(meta.geometries);
        var materials = extractFromCache(meta.materials);
        var textures = extractFromCache(meta.textures);
        var images = extractFromCache(meta.images);
        var shapes = extractFromCache(meta.shapes);
        if (geometries.length > 0) output.geometries = geometries;
        if (materials.length > 0) output.materials = materials;
        if (textures.length > 0) output.textures = textures;
        if (images.length > 0) output.images = images;
        if (shapes.length > 0) output.shapes = shapes;
      }

      output.object = object;
      return output;

      function extractFromCache(cache) {
        var values = [];

        for (var key in cache) {
          var data = cache[key];
          delete data.metadata;
          values.push(data);
        }

        return values;
      }
    },
    clone: function clone(recursive) {
      return new this.constructor().copy(this, recursive);
    },
    copy: function copy(source, recursive) {
      if (recursive === undefined) recursive = true;
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.userData = JSON.parse(JSON.stringify(source.userData));

      if (recursive === true) {
        for (var i = 0; i < source.children.length; i++) {
          var child = source.children[i];
          this.add(child.clone());
        }
      }

      return this;
    }
  });

  function Scene() {
    Object3D.call(this);
    this.type = 'Scene';
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;

    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
      }));
    }
  }

  Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Scene,
    isScene: true,
    copy: function copy(source, recursive) {
      Object3D.prototype.copy.call(this, source, recursive);
      if (source.background !== null) this.background = source.background.clone();
      if (source.environment !== null) this.environment = source.environment.clone();
      if (source.fog !== null) this.fog = source.fog.clone();
      if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
      this.autoUpdate = source.autoUpdate;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    },
    toJSON: function toJSON(meta) {
      var data = Object3D.prototype.toJSON.call(this, meta);
      if (this.background !== null) data.object.background = this.background.toJSON(meta);
      if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
      if (this.fog !== null) data.object.fog = this.fog.toJSON();
      return data;
    },
    dispose: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  });
  var _points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];

  var _vector$1 = new Vector3();

  var _box = new Box3();

  var _v0 = new Vector3();

  var _v1$2 = new Vector3();

  var _v2 = new Vector3();

  var _f0 = new Vector3();

  var _f1 = new Vector3();

  var _f2 = new Vector3();

  var _center = new Vector3();

  var _extents = new Vector3();

  var _triangleNormal = new Vector3();

  var _testAxis = new Vector3();

  function Box3(min, max) {
    this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
    this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
  }

  Object.assign(Box3.prototype, {
    isBox3: true,
    set: function set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    },
    setFromArray: function setFromArray(array) {
      var minX = +Infinity;
      var minY = +Infinity;
      var minZ = +Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      var maxZ = -Infinity;

      for (var i = 0, l = array.length; i < l; i += 3) {
        var x = array[i];
        var y = array[i + 1];
        var z = array[i + 2];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (z < minZ) minZ = z;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
        if (z > maxZ) maxZ = z;
      }

      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    },
    setFromBufferAttribute: function setFromBufferAttribute(attribute) {
      var minX = +Infinity;
      var minY = +Infinity;
      var minZ = +Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      var maxZ = -Infinity;

      for (var i = 0, l = attribute.count; i < l; i++) {
        var x = attribute.getX(i);
        var y = attribute.getY(i);
        var z = attribute.getZ(i);
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (z < minZ) minZ = z;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
        if (z > maxZ) maxZ = z;
      }

      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    },
    setFromPoints: function setFromPoints(points) {
      this.makeEmpty();

      for (var i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }

      return this;
    },
    setFromCenterAndSize: function setFromCenterAndSize(center, size) {
      var halfSize = _vector$1.copy(size).multiplyScalar(0.5);

      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    },
    setFromObject: function setFromObject(object) {
      this.makeEmpty();
      return this.expandByObject(object);
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    },
    makeEmpty: function makeEmpty() {
      this.min.x = this.min.y = this.min.z = +Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    },
    isEmpty: function isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    getCenter: function getCenter(target) {
      if (target === undefined) {
        console.warn('THREE.Box3: .getCenter() target is now required');
        target = new Vector3();
      }

      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function getSize(target) {
      if (target === undefined) {
        console.warn('THREE.Box3: .getSize() target is now required');
        target = new Vector3();
      }

      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    },
    expandByPoint: function expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    },
    expandByVector: function expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    },
    expandByScalar: function expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    },
    expandByObject: function expandByObject(object) {
      object.updateWorldMatrix(false, false);
      var geometry = object.geometry;

      if (geometry !== undefined) {
        if (geometry.boundingBox === null) {
          geometry.computeBoundingBox();
        }

        _box.copy(geometry.boundingBox);

        _box.applyMatrix4(object.matrixWorld);

        this.expandByPoint(_box.min);
        this.expandByPoint(_box.max);
      }

      var children = object.children;

      for (var i = 0, l = children.length; i < l; i++) {
        this.expandByObject(children[i]);
      }

      return this;
    },
    containsPoint: function containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    },
    containsBox: function containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    },
    getParameter: function getParameter(point, target) {
      if (target === undefined) {
        console.warn('THREE.Box3: .getParameter() target is now required');
        target = new Vector3();
      }

      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    },
    intersectsBox: function intersectsBox(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    },
    intersectsSphere: function intersectsSphere(sphere) {
      this.clampPoint(sphere.center, _vector$1);
      return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    },
    intersectsPlane: function intersectsPlane(plane) {
      var min, max;

      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }

      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }

      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }

      return min <= -plane.constant && max >= -plane.constant;
    },
    intersectsTriangle: function intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }

      this.getCenter(_center);

      _extents.subVectors(this.max, _center);

      _v0.subVectors(triangle.a, _center);

      _v1$2.subVectors(triangle.b, _center);

      _v2.subVectors(triangle.c, _center);

      _f0.subVectors(_v1$2, _v0);

      _f1.subVectors(_v2, _v1$2);

      _f2.subVectors(_v0, _v2);

      var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

      if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {
        return false;
      }

      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

      if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {
        return false;
      }

      _triangleNormal.crossVectors(_f0, _f1);

      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0, _v1$2, _v2, _extents);
    },
    clampPoint: function clampPoint(point, target) {
      if (target === undefined) {
        console.warn('THREE.Box3: .clampPoint() target is now required');
        target = new Vector3();
      }

      return target.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function distanceToPoint(point) {
      var clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);

      return clampedPoint.sub(point).length();
    },
    getBoundingSphere: function getBoundingSphere(target) {
      if (target === undefined) {
        console.error('THREE.Box3: .getBoundingSphere() target is now required');
      }

      this.getCenter(target.center);
      target.radius = this.getSize(_vector$1).length() * 0.5;
      return target;
    },
    intersect: function intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty()) this.makeEmpty();
      return this;
    },
    union: function union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    },
    applyMatrix4: function applyMatrix4(matrix) {
      if (this.isEmpty()) return this;

      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);

      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);

      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);

      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);

      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);

      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);

      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);

      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);

      this.setFromPoints(_points);
      return this;
    },
    translate: function translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    },
    equals: function equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  });

  function satForAxes(axes, v0, v1, v2, extents) {
    var i, j;

    for (i = 0, j = axes.length - 3; i <= j; i += 3) {
      _testAxis.fromArray(axes, i);

      var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      var p0 = v0.dot(_testAxis);
      var p1 = v1.dot(_testAxis);
      var p2 = v2.dot(_testAxis);

      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
        return false;
      }
    }

    return true;
  }

  var _box$1 = new Box3();

  function Sphere(center, radius) {
    this.center = center !== undefined ? center : new Vector3();
    this.radius = radius !== undefined ? radius : 0;
  }

  Object.assign(Sphere.prototype, {
    set: function set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    },
    setFromPoints: function setFromPoints(points, optionalCenter) {
      var center = this.center;

      if (optionalCenter !== undefined) {
        center.copy(optionalCenter);
      } else {
        _box$1.setFromPoints(points).getCenter(center);
      }

      var maxRadiusSq = 0;

      for (var i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }

      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    },
    empty: function empty() {
      return this.radius <= 0;
    },
    containsPoint: function containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function intersectsSphere(sphere) {
      var radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    },
    intersectsBox: function intersectsBox(box) {
      return box.intersectsSphere(this);
    },
    intersectsPlane: function intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    },
    clampPoint: function clampPoint(point, target) {
      var deltaLengthSq = this.center.distanceToSquared(point);

      if (target === undefined) {
        console.warn('THREE.Sphere: .clampPoint() target is now required');
        target = new Vector3();
      }

      target.copy(point);

      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }

      return target;
    },
    getBoundingBox: function getBoundingBox(target) {
      if (target === undefined) {
        console.warn('THREE.Sphere: .getBoundingBox() target is now required');
        target = new Box3();
      }

      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    },
    applyMatrix4: function applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    },
    translate: function translate(offset) {
      this.center.add(offset);
      return this;
    },
    equals: function equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
  });

  var _vector$2 = new Vector3();

  var _segCenter = new Vector3();

  var _segDir = new Vector3();

  var _diff = new Vector3();

  var _edge1 = new Vector3();

  var _edge2 = new Vector3();

  var _normal = new Vector3();

  function Ray(origin, direction) {
    this.origin = origin !== undefined ? origin : new Vector3();
    this.direction = direction !== undefined ? direction : new Vector3(0, 0, -1);
  }

  Object.assign(Ray.prototype, {
    set: function set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    },
    at: function at(t, target) {
      if (target === undefined) {
        console.warn('THREE.Ray: .at() target is now required');
        target = new Vector3();
      }

      return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    lookAt: function lookAt(v) {
      this.direction.copy(v).sub(this.origin).normalize();
      return this;
    },
    recast: function recast(t) {
      this.origin.copy(this.at(t, _vector$2));
      return this;
    },
    closestPointToPoint: function closestPointToPoint(point, target) {
      if (target === undefined) {
        console.warn('THREE.Ray: .closestPointToPoint() target is now required');
        target = new Vector3();
      }

      target.subVectors(point, this.origin);
      var directionDistance = target.dot(this.direction);

      if (directionDistance < 0) {
        return target.copy(this.origin);
      }

      return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    },
    distanceToPoint: function distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    },
    distanceSqToPoint: function distanceSqToPoint(point) {
      var directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction);

      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }

      _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

      return _vector$2.distanceToSquared(point);
    },
    distanceSqToSegment: function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);

      _segDir.copy(v1).sub(v0).normalize();

      _diff.copy(this.origin).sub(_segCenter);

      var segExtent = v0.distanceTo(v1) * 0.5;
      var a01 = -this.direction.dot(_segDir);

      var b0 = _diff.dot(this.direction);

      var b1 = -_diff.dot(_segDir);

      var c = _diff.lengthSq();

      var det = Math.abs(1 - a01 * a01);
      var s0, s1, sqrDist, extDet;

      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;

        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }

      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }

      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
      }

      return sqrDist;
    },
    intersectSphere: function intersectSphere(sphere, target) {
      _vector$2.subVectors(sphere.center, this.origin);

      var tca = _vector$2.dot(this.direction);

      var d2 = _vector$2.dot(_vector$2) - tca * tca;
      var radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2) return null;
      var thc = Math.sqrt(radius2 - d2);
      var t0 = tca - thc;
      var t1 = tca + thc;
      if (t0 < 0 && t1 < 0) return null;
      if (t0 < 0) return this.at(t1, target);
      return this.at(t0, target);
    },
    intersectsSphere: function intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    },
    distanceToPlane: function distanceToPlane(plane) {
      var denominator = plane.normal.dot(this.direction);

      if (denominator === 0) {
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }

        return null;
      }

      var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
      return t >= 0 ? t : null;
    },
    intersectPlane: function intersectPlane(plane, target) {
      var t = this.distanceToPlane(plane);

      if (t === null) {
        return null;
      }

      return this.at(t, target);
    },
    intersectsPlane: function intersectsPlane(plane) {
      var distToPoint = plane.distanceToPoint(this.origin);

      if (distToPoint === 0) {
        return true;
      }

      var denominator = plane.normal.dot(this.direction);

      if (denominator * distToPoint < 0) {
        return true;
      }

      return false;
    },
    intersectBox: function intersectBox(box, target) {
      var tmin, tmax, tymin, tymax, tzmin, tzmax;
      var invdirx = 1 / this.direction.x,
          invdiry = 1 / this.direction.y,
          invdirz = 1 / this.direction.z;
      var origin = this.origin;

      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }

      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }

      if (tmin > tymax || tymin > tmax) return null;
      if (tymin > tmin || tmin !== tmin) tmin = tymin;
      if (tymax < tmax || tmax !== tmax) tmax = tymax;

      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }

      if (tmin > tzmax || tzmin > tmax) return null;
      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
      if (tmax < 0) return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    },
    intersectsBox: function intersectsBox(box) {
      return this.intersectBox(box, _vector$2) !== null;
    },
    intersectTriangle: function intersectTriangle(a, b, c, backfaceCulling, target) {
      _edge1.subVectors(b, a);

      _edge2.subVectors(c, a);

      _normal.crossVectors(_edge1, _edge2);

      var DdN = this.direction.dot(_normal);
      var sign;

      if (DdN > 0) {
        if (backfaceCulling) return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }

      _diff.subVectors(this.origin, a);

      var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));

      if (DdQxE2 < 0) {
        return null;
      }

      var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));

      if (DdE1xQ < 0) {
        return null;
      }

      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }

      var QdN = -sign * _diff.dot(_normal);

      if (QdN < 0) {
        return null;
      }

      return this.at(QdN / DdN, target);
    },
    applyMatrix4: function applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    },
    equals: function equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
  });

  var _vector1 = new Vector3();

  var _vector2 = new Vector3();

  var _normalMatrix = new Matrix3();

  function Plane(normal, constant) {
    this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
    this.constant = constant !== undefined ? constant : 0;
  }

  Object.assign(Plane.prototype, {
    isPlane: true,
    set: function set(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    },
    setComponents: function setComponents(x, y, z, w) {
      this.normal.set(x, y, z);
      this.constant = w;
      return this;
    },
    setFromNormalAndCoplanarPoint: function setFromNormalAndCoplanarPoint(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    },
    setFromCoplanarPoints: function setFromCoplanarPoints(a, b, c) {
      var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();

      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    },
    normalize: function normalize() {
      var inverseNormalLength = 1.0 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    },
    negate: function negate() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    },
    distanceToPoint: function distanceToPoint(point) {
      return this.normal.dot(point) + this.constant;
    },
    distanceToSphere: function distanceToSphere(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    },
    projectPoint: function projectPoint(point, target) {
      if (target === undefined) {
        console.warn('THREE.Plane: .projectPoint() target is now required');
        target = new Vector3();
      }

      return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    },
    intersectLine: function intersectLine(line, target) {
      if (target === undefined) {
        console.warn('THREE.Plane: .intersectLine() target is now required');
        target = new Vector3();
      }

      var direction = line.delta(_vector1);
      var denominator = this.normal.dot(direction);

      if (denominator === 0) {
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        }

        return undefined;
      }

      var t = -(line.start.dot(this.normal) + this.constant) / denominator;

      if (t < 0 || t > 1) {
        return undefined;
      }

      return target.copy(direction).multiplyScalar(t).add(line.start);
    },
    intersectsLine: function intersectsLine(line) {
      var startSign = this.distanceToPoint(line.start);
      var endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    },
    intersectsBox: function intersectsBox(box) {
      return box.intersectsPlane(this);
    },
    intersectsSphere: function intersectsSphere(sphere) {
      return sphere.intersectsPlane(this);
    },
    coplanarPoint: function coplanarPoint(target) {
      if (target === undefined) {
        console.warn('THREE.Plane: .coplanarPoint() target is now required');
        target = new Vector3();
      }

      return target.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function applyMatrix4(matrix, optionalNormalMatrix) {
      var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

      var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
      var normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    },
    translate: function translate(offset) {
      this.constant -= offset.dot(this.normal);
      return this;
    },
    equals: function equals(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
  });

  var _v0$1 = new Vector3();

  var _v1$3 = new Vector3();

  var _v2$1 = new Vector3();

  var _v3 = new Vector3();

  var _vab = new Vector3();

  var _vac = new Vector3();

  var _vbc = new Vector3();

  var _vap = new Vector3();

  var _vbp = new Vector3();

  var _vcp = new Vector3();

  function Triangle(a, b, c) {
    this.a = a !== undefined ? a : new Vector3();
    this.b = b !== undefined ? b : new Vector3();
    this.c = c !== undefined ? c : new Vector3();
  }

  Object.assign(Triangle, {
    getNormal: function getNormal(a, b, c, target) {
      if (target === undefined) {
        console.warn('THREE.Triangle: .getNormal() target is now required');
        target = new Vector3();
      }

      target.subVectors(c, b);

      _v0$1.subVectors(a, b);

      target.cross(_v0$1);
      var targetLengthSq = target.lengthSq();

      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }

      return target.set(0, 0, 0);
    },
    getBarycoord: function getBarycoord(point, a, b, c, target) {
      _v0$1.subVectors(c, a);

      _v1$3.subVectors(b, a);

      _v2$1.subVectors(point, a);

      var dot00 = _v0$1.dot(_v0$1);

      var dot01 = _v0$1.dot(_v1$3);

      var dot02 = _v0$1.dot(_v2$1);

      var dot11 = _v1$3.dot(_v1$3);

      var dot12 = _v1$3.dot(_v2$1);

      var denom = dot00 * dot11 - dot01 * dot01;

      if (target === undefined) {
        console.warn('THREE.Triangle: .getBarycoord() target is now required');
        target = new Vector3();
      }

      if (denom === 0) {
        return target.set(-2, -1, -1);
      }

      var invDenom = 1 / denom;
      var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return target.set(1 - u - v, v, u);
    },
    containsPoint: function containsPoint(point, a, b, c) {
      Triangle.getBarycoord(point, a, b, c, _v3);
      return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
    },
    getUV: function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
      this.getBarycoord(point, p1, p2, p3, _v3);
      target.set(0, 0);
      target.addScaledVector(uv1, _v3.x);
      target.addScaledVector(uv2, _v3.y);
      target.addScaledVector(uv3, _v3.z);
      return target;
    },
    isFrontFacing: function isFrontFacing(a, b, c, direction) {
      _v0$1.subVectors(c, b);

      _v1$3.subVectors(a, b);

      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
  });
  Object.assign(Triangle.prototype, {
    set: function set(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    },
    setFromPointsAndIndices: function setFromPointsAndIndices(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    },
    getArea: function getArea() {
      _v0$1.subVectors(this.c, this.b);

      _v1$3.subVectors(this.a, this.b);

      return _v0$1.cross(_v1$3).length() * 0.5;
    },
    getMidpoint: function getMidpoint(target) {
      if (target === undefined) {
        console.warn('THREE.Triangle: .getMidpoint() target is now required');
        target = new Vector3();
      }

      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    getNormal: function getNormal(target) {
      return Triangle.getNormal(this.a, this.b, this.c, target);
    },
    getPlane: function getPlane(target) {
      if (target === undefined) {
        console.warn('THREE.Triangle: .getPlane() target is now required');
        target = new Plane();
      }

      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    getBarycoord: function getBarycoord(point, target) {
      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    },
    getUV: function getUV(point, uv1, uv2, uv3, target) {
      return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    },
    containsPoint: function containsPoint(point) {
      return Triangle.containsPoint(point, this.a, this.b, this.c);
    },
    isFrontFacing: function isFrontFacing(direction) {
      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    },
    intersectsBox: function intersectsBox(box) {
      return box.intersectsTriangle(this);
    },
    closestPointToPoint: function closestPointToPoint(p, target) {
      if (target === undefined) {
        console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
        target = new Vector3();
      }

      var a = this.a,
          b = this.b,
          c = this.c;
      var v, w;

      _vab.subVectors(b, a);

      _vac.subVectors(c, a);

      _vap.subVectors(p, a);

      var d1 = _vab.dot(_vap);

      var d2 = _vac.dot(_vap);

      if (d1 <= 0 && d2 <= 0) {
        return target.copy(a);
      }

      _vbp.subVectors(p, b);

      var d3 = _vab.dot(_vbp);

      var d4 = _vac.dot(_vbp);

      if (d3 >= 0 && d4 <= d3) {
        return target.copy(b);
      }

      var vc = d1 * d4 - d3 * d2;

      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3);
        return target.copy(a).addScaledVector(_vab, v);
      }

      _vcp.subVectors(p, c);

      var d5 = _vab.dot(_vcp);

      var d6 = _vac.dot(_vcp);

      if (d6 >= 0 && d5 <= d6) {
        return target.copy(c);
      }

      var vb = d5 * d2 - d1 * d6;

      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6);
        return target.copy(a).addScaledVector(_vac, w);
      }

      var va = d3 * d6 - d5 * d4;

      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        _vbc.subVectors(c, b);

        w = (d4 - d3) / (d4 - d3 + (d5 - d6));
        return target.copy(b).addScaledVector(_vbc, w);
      }

      var denom = 1 / (va + vb + vc);
      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    },
    equals: function equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  });
  var _colorKeywords = {
    'aliceblue': 0xF0F8FF,
    'antiquewhite': 0xFAEBD7,
    'aqua': 0x00FFFF,
    'aquamarine': 0x7FFFD4,
    'azure': 0xF0FFFF,
    'beige': 0xF5F5DC,
    'bisque': 0xFFE4C4,
    'black': 0x000000,
    'blanchedalmond': 0xFFEBCD,
    'blue': 0x0000FF,
    'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A,
    'burlywood': 0xDEB887,
    'cadetblue': 0x5F9EA0,
    'chartreuse': 0x7FFF00,
    'chocolate': 0xD2691E,
    'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED,
    'cornsilk': 0xFFF8DC,
    'crimson': 0xDC143C,
    'cyan': 0x00FFFF,
    'darkblue': 0x00008B,
    'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B,
    'darkgray': 0xA9A9A9,
    'darkgreen': 0x006400,
    'darkgrey': 0xA9A9A9,
    'darkkhaki': 0xBDB76B,
    'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F,
    'darkorange': 0xFF8C00,
    'darkorchid': 0x9932CC,
    'darkred': 0x8B0000,
    'darksalmon': 0xE9967A,
    'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B,
    'darkslategray': 0x2F4F4F,
    'darkslategrey': 0x2F4F4F,
    'darkturquoise': 0x00CED1,
    'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493,
    'deepskyblue': 0x00BFFF,
    'dimgray': 0x696969,
    'dimgrey': 0x696969,
    'dodgerblue': 0x1E90FF,
    'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0,
    'forestgreen': 0x228B22,
    'fuchsia': 0xFF00FF,
    'gainsboro': 0xDCDCDC,
    'ghostwhite': 0xF8F8FF,
    'gold': 0xFFD700,
    'goldenrod': 0xDAA520,
    'gray': 0x808080,
    'green': 0x008000,
    'greenyellow': 0xADFF2F,
    'grey': 0x808080,
    'honeydew': 0xF0FFF0,
    'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C,
    'indigo': 0x4B0082,
    'ivory': 0xFFFFF0,
    'khaki': 0xF0E68C,
    'lavender': 0xE6E6FA,
    'lavenderblush': 0xFFF0F5,
    'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD,
    'lightblue': 0xADD8E6,
    'lightcoral': 0xF08080,
    'lightcyan': 0xE0FFFF,
    'lightgoldenrodyellow': 0xFAFAD2,
    'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90,
    'lightgrey': 0xD3D3D3,
    'lightpink': 0xFFB6C1,
    'lightsalmon': 0xFFA07A,
    'lightseagreen': 0x20B2AA,
    'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899,
    'lightslategrey': 0x778899,
    'lightsteelblue': 0xB0C4DE,
    'lightyellow': 0xFFFFE0,
    'lime': 0x00FF00,
    'limegreen': 0x32CD32,
    'linen': 0xFAF0E6,
    'magenta': 0xFF00FF,
    'maroon': 0x800000,
    'mediumaquamarine': 0x66CDAA,
    'mediumblue': 0x0000CD,
    'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB,
    'mediumseagreen': 0x3CB371,
    'mediumslateblue': 0x7B68EE,
    'mediumspringgreen': 0x00FA9A,
    'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585,
    'midnightblue': 0x191970,
    'mintcream': 0xF5FFFA,
    'mistyrose': 0xFFE4E1,
    'moccasin': 0xFFE4B5,
    'navajowhite': 0xFFDEAD,
    'navy': 0x000080,
    'oldlace': 0xFDF5E6,
    'olive': 0x808000,
    'olivedrab': 0x6B8E23,
    'orange': 0xFFA500,
    'orangered': 0xFF4500,
    'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA,
    'palegreen': 0x98FB98,
    'paleturquoise': 0xAFEEEE,
    'palevioletred': 0xDB7093,
    'papayawhip': 0xFFEFD5,
    'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F,
    'pink': 0xFFC0CB,
    'plum': 0xDDA0DD,
    'powderblue': 0xB0E0E6,
    'purple': 0x800080,
    'rebeccapurple': 0x663399,
    'red': 0xFF0000,
    'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1,
    'saddlebrown': 0x8B4513,
    'salmon': 0xFA8072,
    'sandybrown': 0xF4A460,
    'seagreen': 0x2E8B57,
    'seashell': 0xFFF5EE,
    'sienna': 0xA0522D,
    'silver': 0xC0C0C0,
    'skyblue': 0x87CEEB,
    'slateblue': 0x6A5ACD,
    'slategray': 0x708090,
    'slategrey': 0x708090,
    'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F,
    'steelblue': 0x4682B4,
    'tan': 0xD2B48C,
    'teal': 0x008080,
    'thistle': 0xD8BFD8,
    'tomato': 0xFF6347,
    'turquoise': 0x40E0D0,
    'violet': 0xEE82EE,
    'wheat': 0xF5DEB3,
    'white': 0xFFFFFF,
    'whitesmoke': 0xF5F5F5,
    'yellow': 0xFFFF00,
    'yellowgreen': 0x9ACD32
  };
  var _hslA = {
    h: 0,
    s: 0,
    l: 0
  };
  var _hslB = {
    h: 0,
    s: 0,
    l: 0
  };

  function Color(r, g, b) {
    if (g === undefined && b === undefined) {
      return this.set(r);
    }

    return this.setRGB(r, g, b);
  }

  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
    return p;
  }

  function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
  }

  function LinearToSRGB(c) {
    return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
  }

  Object.assign(Color.prototype, {
    isColor: true,
    r: 1,
    g: 1,
    b: 1,
    set: function set(value) {
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === 'number') {
        this.setHex(value);
      } else if (typeof value === 'string') {
        this.setStyle(value);
      }

      return this;
    },
    setScalar: function setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    },
    setHex: function setHex(hex) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      return this;
    },
    setRGB: function setRGB(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
      return this;
    },
    setHSL: function setHSL(h, s, l) {
      h = MathUtils.euclideanModulo(h, 1);
      s = MathUtils.clamp(s, 0, 1);
      l = MathUtils.clamp(l, 0, 1);

      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        var q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }

      return this;
    },
    setStyle: function setStyle(style) {
      function handleAlpha(string) {
        if (string === undefined) return;

        if (parseFloat(string) < 1) {
          console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
        }
      }

      var m;

      if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
        var color;
        var name = m[1];
        var components = m[2];

        switch (name) {
          case 'rgb':
          case 'rgba':
            if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
              this.r = Math.min(255, parseInt(color[1], 10)) / 255;
              this.g = Math.min(255, parseInt(color[2], 10)) / 255;
              this.b = Math.min(255, parseInt(color[3], 10)) / 255;
              handleAlpha(color[5]);
              return this;
            }

            if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
              this.r = Math.min(100, parseInt(color[1], 10)) / 100;
              this.g = Math.min(100, parseInt(color[2], 10)) / 100;
              this.b = Math.min(100, parseInt(color[3], 10)) / 100;
              handleAlpha(color[5]);
              return this;
            }

            break;

          case 'hsl':
          case 'hsla':
            if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
              var h = parseFloat(color[1]) / 360;
              var s = parseInt(color[2], 10) / 100;
              var l = parseInt(color[3], 10) / 100;
              handleAlpha(color[5]);
              return this.setHSL(h, s, l);
            }

            break;
        }
      } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
        var hex = m[1];
        var size = hex.length;

        if (size === 3) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
          this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
          this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
          return this;
        } else if (size === 6) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
          this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
          this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
          return this;
        }
      }

      if (style && style.length > 0) {
        return this.setColorName(style);
      }

      return this;
    },
    setColorName: function setColorName(style) {
      var hex = _colorKeywords[style];

      if (hex !== undefined) {
        this.setHex(hex);
      } else {
        console.warn('THREE.Color: Unknown color ' + style);
      }

      return this;
    },
    clone: function clone() {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    },
    copyGammaToLinear: function copyGammaToLinear(color, gammaFactor) {
      if (gammaFactor === undefined) gammaFactor = 2.0;
      this.r = Math.pow(color.r, gammaFactor);
      this.g = Math.pow(color.g, gammaFactor);
      this.b = Math.pow(color.b, gammaFactor);
      return this;
    },
    copyLinearToGamma: function copyLinearToGamma(color, gammaFactor) {
      if (gammaFactor === undefined) gammaFactor = 2.0;
      var safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
      this.r = Math.pow(color.r, safeInverse);
      this.g = Math.pow(color.g, safeInverse);
      this.b = Math.pow(color.b, safeInverse);
      return this;
    },
    convertGammaToLinear: function convertGammaToLinear(gammaFactor) {
      this.copyGammaToLinear(this, gammaFactor);
      return this;
    },
    convertLinearToGamma: function convertLinearToGamma(gammaFactor) {
      this.copyLinearToGamma(this, gammaFactor);
      return this;
    },
    copySRGBToLinear: function copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    },
    copyLinearToSRGB: function copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    },
    convertSRGBToLinear: function convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    },
    convertLinearToSRGB: function convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    },
    getHex: function getHex() {
      return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    },
    getHexString: function getHexString() {
      return ('000000' + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function getHSL(target) {
      if (target === undefined) {
        console.warn('THREE.Color: .getHSL() target is now required');
        target = {
          h: 0,
          s: 0,
          l: 0
        };
      }

      var r = this.r,
          g = this.g,
          b = this.b;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var hue, saturation;
      var lightness = (min + max) / 2.0;

      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        var delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

        switch (max) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;

          case g:
            hue = (b - r) / delta + 2;
            break;

          case b:
            hue = (r - g) / delta + 4;
            break;
        }

        hue /= 6;
      }

      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    },
    getStyle: function getStyle() {
      return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
    },
    offsetHSL: function offsetHSL(h, s, l) {
      this.getHSL(_hslA);
      _hslA.h += h;
      _hslA.s += s;
      _hslA.l += l;
      this.setHSL(_hslA.h, _hslA.s, _hslA.l);
      return this;
    },
    add: function add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    },
    addColors: function addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    },
    addScalar: function addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    },
    sub: function sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    },
    multiply: function multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    },
    multiplyScalar: function multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    },
    lerp: function lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    },
    lerpHSL: function lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      var h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
      var s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
      var l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h, s, l);
      return this;
    },
    equals: function equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    },
    fromArray: function fromArray(array, offset) {
      if (offset === undefined) offset = 0;
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    },
    toArray: function toArray(array, offset) {
      if (array === undefined) array = [];
      if (offset === undefined) offset = 0;
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    },
    toJSON: function toJSON() {
      return this.getHex();
    }
  });
  Color.NAMES = _colorKeywords;

  function Face3(a, b, c, normal, color, materialIndex) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = normal && normal.isVector3 ? normal : new Vector3();
    this.vertexNormals = Array.isArray(normal) ? normal : [];
    this.color = color && color.isColor ? color : new Color();
    this.vertexColors = Array.isArray(color) ? color : [];
    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
  }

  Object.assign(Face3.prototype, {
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(source) {
      this.a = source.a;
      this.b = source.b;
      this.c = source.c;
      this.normal.copy(source.normal);
      this.color.copy(source.color);
      this.materialIndex = source.materialIndex;

      for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
        this.vertexNormals[i] = source.vertexNormals[i].clone();
      }

      for (var i = 0, il = source.vertexColors.length; i < il; i++) {
        this.vertexColors[i] = source.vertexColors[i].clone();
      }

      return this;
    }
  });
  var materialId = 0;

  function Material() {
    Object.defineProperty(this, 'id', {
      value: materialId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'Material';
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.flatShading = false;
    this.vertexTangents = false;
    this.vertexColors = NoColors;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 0xff;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 0xff;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
  }

  Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Material,
    isMaterial: true,
    onBeforeCompile: function onBeforeCompile() {},
    setValues: function setValues(values) {
      if (values === undefined) return;

      for (var key in values) {
        var newValue = values[key];

        if (newValue === undefined) {
          console.warn("THREE.Material: '" + key + "' parameter is undefined.");
          continue;
        }

        if (key === 'shading') {
          console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
          this.flatShading = newValue === FlatShading ? true : false;
          continue;
        }

        var currentValue = this[key];

        if (currentValue === undefined) {
          console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
          continue;
        }

        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    },
    toJSON: function toJSON(meta) {
      var isRoot = meta === undefined || typeof meta === 'string';

      if (isRoot) {
        meta = {
          textures: {},
          images: {}
        };
      }

      var data = {
        metadata: {
          version: 4.5,
          type: 'Material',
          generator: 'Material.toJSON'
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== '') data.name = this.name;
      if (this.color && this.color.isColor) data.color = this.color.getHex();
      if (this.roughness !== undefined) data.roughness = this.roughness;
      if (this.metalness !== undefined) data.metalness = this.metalness;
      if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
      if (this.shininess !== undefined) data.shininess = this.shininess;
      if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
      if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
      }

      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;

      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }

      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }

      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }

      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }

      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        data.reflectivity = this.reflectivity;
        data.refractionRatio = this.refractionRatio;
        if (this.combine !== undefined) data.combine = this.combine;
        if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
      }

      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }

      if (this.size !== undefined) data.size = this.size;
      if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending) data.blending = this.blending;
      if (this.flatShading === true) data.flatShading = this.flatShading;
      if (this.side !== FrontSide) data.side = this.side;
      if (this.vertexColors !== NoColors) data.vertexColors = this.vertexColors;
      if (this.opacity < 1) data.opacity = this.opacity;
      if (this.transparent === true) data.transparent = this.transparent;
      data.depthFunc = this.depthFunc;
      data.depthTest = this.depthTest;
      data.depthWrite = this.depthWrite;
      data.stencilWrite = this.stencilWrite;
      data.stencilWriteMask = this.stencilWriteMask;
      data.stencilFunc = this.stencilFunc;
      data.stencilRef = this.stencilRef;
      data.stencilFuncMask = this.stencilFuncMask;
      data.stencilFail = this.stencilFail;
      data.stencilZFail = this.stencilZFail;
      data.stencilZPass = this.stencilZPass;
      if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
      if (this.polygonOffset === true) data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
      if (this.dashSize !== undefined) data.dashSize = this.dashSize;
      if (this.gapSize !== undefined) data.gapSize = this.gapSize;
      if (this.scale !== undefined) data.scale = this.scale;
      if (this.dithering === true) data.dithering = true;
      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
      if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
      if (this.wireframe === true) data.wireframe = this.wireframe;
      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.morphTargets === true) data.morphTargets = true;
      if (this.morphNormals === true) data.morphNormals = true;
      if (this.skinning === true) data.skinning = true;
      if (this.visible === false) data.visible = false;
      if (this.toneMapped === false) data.toneMapped = false;
      if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;

      function extractFromCache(cache) {
        var values = [];

        for (var key in cache) {
          var data = cache[key];
          delete data.metadata;
          values.push(data);
        }

        return values;
      }

      if (isRoot) {
        var textures = extractFromCache(meta.textures);
        var images = extractFromCache(meta.images);
        if (textures.length > 0) data.textures = textures;
        if (images.length > 0) data.images = images;
      }

      return data;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(source) {
      this.name = source.name;
      this.fog = source.fog;
      this.blending = source.blending;
      this.side = source.side;
      this.flatShading = source.flatShading;
      this.vertexTangents = source.vertexTangents;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.stencilWriteMask = source.stencilWriteMask;
      this.stencilFunc = source.stencilFunc;
      this.stencilRef = source.stencilRef;
      this.stencilFuncMask = source.stencilFuncMask;
      this.stencilFail = source.stencilFail;
      this.stencilZFail = source.stencilZFail;
      this.stencilZPass = source.stencilZPass;
      this.stencilWrite = source.stencilWrite;
      var srcPlanes = source.clippingPlanes,
          dstPlanes = null;

      if (srcPlanes !== null) {
        var n = srcPlanes.length;
        dstPlanes = new Array(n);

        for (var i = 0; i !== n; ++i) {
          dstPlanes[i] = srcPlanes[i].clone();
        }
      }

      this.clippingPlanes = dstPlanes;
      this.clipIntersection = source.clipIntersection;
      this.clipShadows = source.clipShadows;
      this.shadowSide = source.shadowSide;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.visible = source.visible;
      this.toneMapped = source.toneMapped;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      return this;
    },
    dispose: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  });
  Object.defineProperty(Material.prototype, 'needsUpdate', {
    set: function set(value) {
      if (value === true) this.version++;
    }
  });

  function MeshBasicMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshBasicMaterial';
    this.color = new Color(0xffffff);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
  }

  MeshBasicMaterial.prototype = Object.create(Material.prototype);
  MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

  MeshBasicMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
  };

  var _vector$3 = new Vector3();

  function BufferAttribute(array, itemSize, normalized) {
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }

    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = {
      offset: 0,
      count: -1
    };
    this.version = 0;
  }

  Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
    set: function set(value) {
      if (value === true) this.version++;
    }
  });
  Object.assign(BufferAttribute.prototype, {
    isBufferAttribute: true,
    onUploadCallback: function onUploadCallback() {},
    setUsage: function setUsage(value) {
      this.usage = value;
      return this;
    },
    copy: function copy(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.usage = source.usage;
      return this;
    },
    copyAt: function copyAt(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;

      for (var i = 0, l = this.itemSize; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }

      return this;
    },
    copyArray: function copyArray(array) {
      this.array.set(array);
      return this;
    },
    copyColorsArray: function copyColorsArray(colors) {
      var array = this.array,
          offset = 0;

      for (var i = 0, l = colors.length; i < l; i++) {
        var color = colors[i];

        if (color === undefined) {
          console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
          color = new Color();
        }

        array[offset++] = color.r;
        array[offset++] = color.g;
        array[offset++] = color.b;
      }

      return this;
    },
    copyVector2sArray: function copyVector2sArray(vectors) {
      var array = this.array,
          offset = 0;

      for (var i = 0, l = vectors.length; i < l; i++) {
        var vector = vectors[i];

        if (vector === undefined) {
          console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
          vector = new Vector2();
        }

        array[offset++] = vector.x;
        array[offset++] = vector.y;
      }

      return this;
    },
    copyVector3sArray: function copyVector3sArray(vectors) {
      var array = this.array,
          offset = 0;

      for (var i = 0, l = vectors.length; i < l; i++) {
        var vector = vectors[i];

        if (vector === undefined) {
          console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
          vector = new Vector3();
        }

        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
      }

      return this;
    },
    copyVector4sArray: function copyVector4sArray(vectors) {
      var array = this.array,
          offset = 0;

      for (var i = 0, l = vectors.length; i < l; i++) {
        var vector = vectors[i];

        if (vector === undefined) {
          console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
          vector = new Vector4();
        }

        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
        array[offset++] = vector.w;
      }

      return this;
    },
    applyMatrix3: function applyMatrix3(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$3.x = this.getX(i);
        _vector$3.y = this.getY(i);
        _vector$3.z = this.getZ(i);

        _vector$3.applyMatrix3(m);

        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
      }

      return this;
    },
    applyMatrix4: function applyMatrix4(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$3.x = this.getX(i);
        _vector$3.y = this.getY(i);
        _vector$3.z = this.getZ(i);

        _vector$3.applyMatrix4(m);

        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
      }

      return this;
    },
    applyNormalMatrix: function applyNormalMatrix(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$3.x = this.getX(i);
        _vector$3.y = this.getY(i);
        _vector$3.z = this.getZ(i);

        _vector$3.applyNormalMatrix(m);

        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
      }

      return this;
    },
    transformDirection: function transformDirection(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$3.x = this.getX(i);
        _vector$3.y = this.getY(i);
        _vector$3.z = this.getZ(i);

        _vector$3.transformDirection(m);

        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
      }

      return this;
    },
    set: function set(value, offset) {
      if (offset === undefined) offset = 0;
      this.array.set(value, offset);
      return this;
    },
    getX: function getX(index) {
      return this.array[index * this.itemSize];
    },
    setX: function setX(index, x) {
      this.array[index * this.itemSize] = x;
      return this;
    },
    getY: function getY(index) {
      return this.array[index * this.itemSize + 1];
    },
    setY: function setY(index, y) {
      this.array[index * this.itemSize + 1] = y;
      return this;
    },
    getZ: function getZ(index) {
      return this.array[index * this.itemSize + 2];
    },
    setZ: function setZ(index, z) {
      this.array[index * this.itemSize + 2] = z;
      return this;
    },
    getW: function getW(index) {
      return this.array[index * this.itemSize + 3];
    },
    setW: function setW(index, w) {
      this.array[index * this.itemSize + 3] = w;
      return this;
    },
    setXY: function setXY(index, x, y) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      return this;
    },
    setXYZ: function setXYZ(index, x, y, z) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    },
    setXYZW: function setXYZW(index, x, y, z, w) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    },
    onUpload: function onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    },
    clone: function clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    },
    toJSON: function toJSON() {
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.prototype.slice.call(this.array),
        normalized: this.normalized
      };
    }
  });

  function Int8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
  }

  Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;

  function Uint8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
  }

  Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;

  function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
  }

  Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;

  function Int16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
  }

  Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;

  function Uint16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
  }

  Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;

  function Int32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
  }

  Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;

  function Uint32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
  }

  Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

  function Float32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
  }

  Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;

  function Float64BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
  }

  Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

  function DirectGeometry() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }

  Object.assign(DirectGeometry.prototype, {
    computeGroups: function computeGroups(geometry) {
      var group;
      var groups = [];
      var materialIndex = undefined;
      var faces = geometry.faces;

      for (var i = 0; i < faces.length; i++) {
        var face = faces[i];

        if (face.materialIndex !== materialIndex) {
          materialIndex = face.materialIndex;

          if (group !== undefined) {
            group.count = i * 3 - group.start;
            groups.push(group);
          }

          group = {
            start: i * 3,
            materialIndex: materialIndex
          };
        }
      }

      if (group !== undefined) {
        group.count = i * 3 - group.start;
        groups.push(group);
      }

      this.groups = groups;
    },
    fromGeometry: function fromGeometry(geometry) {
      var faces = geometry.faces;
      var vertices = geometry.vertices;
      var faceVertexUvs = geometry.faceVertexUvs;
      var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
      var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
      var morphTargets = geometry.morphTargets;
      var morphTargetsLength = morphTargets.length;
      var morphTargetsPosition;

      if (morphTargetsLength > 0) {
        morphTargetsPosition = [];

        for (var i = 0; i < morphTargetsLength; i++) {
          morphTargetsPosition[i] = {
            name: morphTargets[i].name,
            data: []
          };
        }

        this.morphTargets.position = morphTargetsPosition;
      }

      var morphNormals = geometry.morphNormals;
      var morphNormalsLength = morphNormals.length;
      var morphTargetsNormal;

      if (morphNormalsLength > 0) {
        morphTargetsNormal = [];

        for (var i = 0; i < morphNormalsLength; i++) {
          morphTargetsNormal[i] = {
            name: morphNormals[i].name,
            data: []
          };
        }

        this.morphTargets.normal = morphTargetsNormal;
      }

      var skinIndices = geometry.skinIndices;
      var skinWeights = geometry.skinWeights;
      var hasSkinIndices = skinIndices.length === vertices.length;
      var hasSkinWeights = skinWeights.length === vertices.length;

      if (vertices.length > 0 && faces.length === 0) {
        console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
      }

      for (var i = 0; i < faces.length; i++) {
        var face = faces[i];
        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
        var vertexNormals = face.vertexNormals;

        if (vertexNormals.length === 3) {
          this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
        } else {
          var normal = face.normal;
          this.normals.push(normal, normal, normal);
        }

        var vertexColors = face.vertexColors;

        if (vertexColors.length === 3) {
          this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
        } else {
          var color = face.color;
          this.colors.push(color, color, color);
        }

        if (hasFaceVertexUv === true) {
          var vertexUvs = faceVertexUvs[0][i];

          if (vertexUvs !== undefined) {
            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
          } else {
            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
            this.uvs.push(new Vector2(), new Vector2(), new Vector2());
          }
        }

        if (hasFaceVertexUv2 === true) {
          var vertexUvs = faceVertexUvs[1][i];

          if (vertexUvs !== undefined) {
            this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
          } else {
            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
            this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
          }
        }

        for (var j = 0; j < morphTargetsLength; j++) {
          var morphTarget = morphTargets[j].vertices;
          morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
        }

        for (var j = 0; j < morphNormalsLength; j++) {
          var morphNormal = morphNormals[j].vertexNormals[i];
          morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
        }

        if (hasSkinIndices) {
          this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
        }

        if (hasSkinWeights) {
          this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
        }
      }

      this.computeGroups(geometry);
      this.verticesNeedUpdate = geometry.verticesNeedUpdate;
      this.normalsNeedUpdate = geometry.normalsNeedUpdate;
      this.colorsNeedUpdate = geometry.colorsNeedUpdate;
      this.uvsNeedUpdate = geometry.uvsNeedUpdate;
      this.groupsNeedUpdate = geometry.groupsNeedUpdate;

      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }

      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }

      return this;
    }
  });

  function arrayMax(array) {
    if (array.length === 0) return -Infinity;
    var max = array[0];

    for (var i = 1, l = array.length; i < l; ++i) {
      if (array[i] > max) max = array[i];
    }

    return max;
  }

  var _bufferGeometryId = 1;

  var _m1$2 = new Matrix4();

  var _obj = new Object3D();

  var _offset = new Vector3();

  var _box$2 = new Box3();

  var _boxMorphTargets = new Box3();

  var _vector$4 = new Vector3();

  function BufferGeometry() {
    Object.defineProperty(this, 'id', {
      value: _bufferGeometryId += 2
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
      start: 0,
      count: Infinity
    };
    this.userData = {};
  }

  BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: BufferGeometry,
    isBufferGeometry: true,
    getIndex: function getIndex() {
      return this.index;
    },
    setIndex: function setIndex(index) {
      if (Array.isArray(index)) {
        this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
      } else {
        this.index = index;
      }
    },
    getAttribute: function getAttribute(name) {
      return this.attributes[name];
    },
    setAttribute: function setAttribute(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    },
    deleteAttribute: function deleteAttribute(name) {
      delete this.attributes[name];
      return this;
    },
    addGroup: function addGroup(start, count, materialIndex) {
      this.groups.push({
        start: start,
        count: count,
        materialIndex: materialIndex !== undefined ? materialIndex : 0
      });
    },
    clearGroups: function clearGroups() {
      this.groups = [];
    },
    setDrawRange: function setDrawRange(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    },
    applyMatrix4: function applyMatrix4(matrix) {
      var position = this.attributes.position;

      if (position !== undefined) {
        position.applyMatrix4(matrix);
        position.needsUpdate = true;
      }

      var normal = this.attributes.normal;

      if (normal !== undefined) {
        var normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normal.applyNormalMatrix(normalMatrix);
        normal.needsUpdate = true;
      }

      var tangent = this.attributes.tangent;

      if (tangent !== undefined) {
        tangent.transformDirection(matrix);
        tangent.needsUpdate = true;
      }

      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }

      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }

      return this;
    },
    rotateX: function rotateX(angle) {
      _m1$2.makeRotationX(angle);

      this.applyMatrix4(_m1$2);
      return this;
    },
    rotateY: function rotateY(angle) {
      _m1$2.makeRotationY(angle);

      this.applyMatrix4(_m1$2);
      return this;
    },
    rotateZ: function rotateZ(angle) {
      _m1$2.makeRotationZ(angle);

      this.applyMatrix4(_m1$2);
      return this;
    },
    translate: function translate(x, y, z) {
      _m1$2.makeTranslation(x, y, z);

      this.applyMatrix4(_m1$2);
      return this;
    },
    scale: function scale(x, y, z) {
      _m1$2.makeScale(x, y, z);

      this.applyMatrix4(_m1$2);
      return this;
    },
    lookAt: function lookAt(vector) {
      _obj.lookAt(vector);

      _obj.updateMatrix();

      this.applyMatrix4(_obj.matrix);
      return this;
    },
    center: function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset).negate();
      this.translate(_offset.x, _offset.y, _offset.z);
      return this;
    },
    setFromObject: function setFromObject(object) {
      var geometry = object.geometry;

      if (object.isPoints || object.isLine) {
        var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
        var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
        this.setAttribute('position', positions.copyVector3sArray(geometry.vertices));
        this.setAttribute('color', colors.copyColorsArray(geometry.colors));

        if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
          var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
          this.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
        }

        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }

        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
      } else if (object.isMesh) {
        if (geometry && geometry.isGeometry) {
          this.fromGeometry(geometry);
        }
      }

      return this;
    },
    setFromPoints: function setFromPoints(points) {
      var position = [];

      for (var i = 0, l = points.length; i < l; i++) {
        var point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }

      this.setAttribute('position', new Float32BufferAttribute(position, 3));
      return this;
    },
    updateFromObject: function updateFromObject(object) {
      var geometry = object.geometry;

      if (object.isMesh) {
        var direct = geometry.__directGeometry;

        if (geometry.elementsNeedUpdate === true) {
          direct = undefined;
          geometry.elementsNeedUpdate = false;
        }

        if (direct === undefined) {
          return this.fromGeometry(geometry);
        }

        direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
        direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
        direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
        direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
        direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
        geometry.verticesNeedUpdate = false;
        geometry.normalsNeedUpdate = false;
        geometry.colorsNeedUpdate = false;
        geometry.uvsNeedUpdate = false;
        geometry.groupsNeedUpdate = false;
        geometry = direct;
      }

      var attribute;

      if (geometry.verticesNeedUpdate === true) {
        attribute = this.attributes.position;

        if (attribute !== undefined) {
          attribute.copyVector3sArray(geometry.vertices);
          attribute.needsUpdate = true;
        }

        geometry.verticesNeedUpdate = false;
      }

      if (geometry.normalsNeedUpdate === true) {
        attribute = this.attributes.normal;

        if (attribute !== undefined) {
          attribute.copyVector3sArray(geometry.normals);
          attribute.needsUpdate = true;
        }

        geometry.normalsNeedUpdate = false;
      }

      if (geometry.colorsNeedUpdate === true) {
        attribute = this.attributes.color;

        if (attribute !== undefined) {
          attribute.copyColorsArray(geometry.colors);
          attribute.needsUpdate = true;
        }

        geometry.colorsNeedUpdate = false;
      }

      if (geometry.uvsNeedUpdate) {
        attribute = this.attributes.uv;

        if (attribute !== undefined) {
          attribute.copyVector2sArray(geometry.uvs);
          attribute.needsUpdate = true;
        }

        geometry.uvsNeedUpdate = false;
      }

      if (geometry.lineDistancesNeedUpdate) {
        attribute = this.attributes.lineDistance;

        if (attribute !== undefined) {
          attribute.copyArray(geometry.lineDistances);
          attribute.needsUpdate = true;
        }

        geometry.lineDistancesNeedUpdate = false;
      }

      if (geometry.groupsNeedUpdate) {
        geometry.computeGroups(object.geometry);
        this.groups = geometry.groups;
        geometry.groupsNeedUpdate = false;
      }

      return this;
    },
    fromGeometry: function fromGeometry(geometry) {
      geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
      return this.fromDirectGeometry(geometry.__directGeometry);
    },
    fromDirectGeometry: function fromDirectGeometry(geometry) {
      var positions = new Float32Array(geometry.vertices.length * 3);
      this.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));

      if (geometry.normals.length > 0) {
        var normals = new Float32Array(geometry.normals.length * 3);
        this.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
      }

      if (geometry.colors.length > 0) {
        var colors = new Float32Array(geometry.colors.length * 3);
        this.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
      }

      if (geometry.uvs.length > 0) {
        var uvs = new Float32Array(geometry.uvs.length * 2);
        this.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
      }

      if (geometry.uvs2.length > 0) {
        var uvs2 = new Float32Array(geometry.uvs2.length * 2);
        this.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
      }

      this.groups = geometry.groups;

      for (var name in geometry.morphTargets) {
        var array = [];
        var morphTargets = geometry.morphTargets[name];

        for (var i = 0, l = morphTargets.length; i < l; i++) {
          var morphTarget = morphTargets[i];
          var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
          attribute.name = morphTarget.name;
          array.push(attribute.copyVector3sArray(morphTarget.data));
        }

        this.morphAttributes[name] = array;
      }

      if (geometry.skinIndices.length > 0) {
        var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
        this.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
      }

      if (geometry.skinWeights.length > 0) {
        var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
        this.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
      }

      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }

      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }

      return this;
    },
    computeBoundingBox: function computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }

      var position = this.attributes.position;
      var morphAttributesPosition = this.morphAttributes.position;

      if (position !== undefined) {
        this.boundingBox.setFromBufferAttribute(position);

        if (morphAttributesPosition) {
          for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
            var morphAttribute = morphAttributesPosition[i];

            _box$2.setFromBufferAttribute(morphAttribute);

            if (this.morphTargetsRelative) {
              _vector$4.addVectors(this.boundingBox.min, _box$2.min);

              this.boundingBox.expandByPoint(_vector$4);

              _vector$4.addVectors(this.boundingBox.max, _box$2.max);

              this.boundingBox.expandByPoint(_vector$4);
            } else {
              this.boundingBox.expandByPoint(_box$2.min);
              this.boundingBox.expandByPoint(_box$2.max);
            }
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }

      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    },
    computeBoundingSphere: function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }

      var position = this.attributes.position;
      var morphAttributesPosition = this.morphAttributes.position;

      if (position) {
        var center = this.boundingSphere.center;

        _box$2.setFromBufferAttribute(position);

        if (morphAttributesPosition) {
          for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
            var morphAttribute = morphAttributesPosition[i];

            _boxMorphTargets.setFromBufferAttribute(morphAttribute);

            if (this.morphTargetsRelative) {
              _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);

              _box$2.expandByPoint(_vector$4);

              _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);

              _box$2.expandByPoint(_vector$4);
            } else {
              _box$2.expandByPoint(_boxMorphTargets.min);

              _box$2.expandByPoint(_boxMorphTargets.max);
            }
          }
        }

        _box$2.getCenter(center);

        var maxRadiusSq = 0;

        for (var i = 0, il = position.count; i < il; i++) {
          _vector$4.fromBufferAttribute(position, i);

          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
        }

        if (morphAttributesPosition) {
          for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
            var morphAttribute = morphAttributesPosition[i];
            var morphTargetsRelative = this.morphTargetsRelative;

            for (var j = 0, jl = morphAttribute.count; j < jl; j++) {
              _vector$4.fromBufferAttribute(morphAttribute, j);

              if (morphTargetsRelative) {
                _offset.fromBufferAttribute(position, j);

                _vector$4.add(_offset);
              }

              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
            }
          }
        }

        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    },
    computeFaceNormals: function computeFaceNormals() {},
    computeVertexNormals: function computeVertexNormals() {
      var index = this.index;
      var attributes = this.attributes;

      if (attributes.position) {
        var positions = attributes.position.array;

        if (attributes.normal === undefined) {
          this.setAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
        } else {
          var array = attributes.normal.array;

          for (var i = 0, il = array.length; i < il; i++) {
            array[i] = 0;
          }
        }

        var normals = attributes.normal.array;
        var vA, vB, vC;
        var pA = new Vector3(),
            pB = new Vector3(),
            pC = new Vector3();
        var cb = new Vector3(),
            ab = new Vector3();

        if (index) {
          var indices = index.array;

          for (var i = 0, il = index.count; i < il; i += 3) {
            vA = indices[i + 0] * 3;
            vB = indices[i + 1] * 3;
            vC = indices[i + 2] * 3;
            pA.fromArray(positions, vA);
            pB.fromArray(positions, vB);
            pC.fromArray(positions, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normals[vA] += cb.x;
            normals[vA + 1] += cb.y;
            normals[vA + 2] += cb.z;
            normals[vB] += cb.x;
            normals[vB + 1] += cb.y;
            normals[vB + 2] += cb.z;
            normals[vC] += cb.x;
            normals[vC + 1] += cb.y;
            normals[vC + 2] += cb.z;
          }
        } else {
          for (var i = 0, il = positions.length; i < il; i += 9) {
            pA.fromArray(positions, i);
            pB.fromArray(positions, i + 3);
            pC.fromArray(positions, i + 6);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normals[i] = cb.x;
            normals[i + 1] = cb.y;
            normals[i + 2] = cb.z;
            normals[i + 3] = cb.x;
            normals[i + 4] = cb.y;
            normals[i + 5] = cb.z;
            normals[i + 6] = cb.x;
            normals[i + 7] = cb.y;
            normals[i + 8] = cb.z;
          }
        }

        this.normalizeNormals();
        attributes.normal.needsUpdate = true;
      }
    },
    merge: function merge(geometry, offset) {
      if (!(geometry && geometry.isBufferGeometry)) {
        console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
        return;
      }

      if (offset === undefined) {
        offset = 0;
        console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
      }

      var attributes = this.attributes;

      for (var key in attributes) {
        if (geometry.attributes[key] === undefined) continue;
        var attribute1 = attributes[key];
        var attributeArray1 = attribute1.array;
        var attribute2 = geometry.attributes[key];
        var attributeArray2 = attribute2.array;
        var attributeOffset = attribute2.itemSize * offset;
        var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

        for (var i = 0, j = attributeOffset; i < length; i++, j++) {
          attributeArray1[j] = attributeArray2[i];
        }
      }

      return this;
    },
    normalizeNormals: function normalizeNormals() {
      var normals = this.attributes.normal;

      for (var i = 0, il = normals.count; i < il; i++) {
        _vector$4.x = normals.getX(i);
        _vector$4.y = normals.getY(i);
        _vector$4.z = normals.getZ(i);

        _vector$4.normalize();

        normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
      }
    },
    toNonIndexed: function toNonIndexed() {
      function convertBufferAttribute(attribute, indices) {
        var array = attribute.array;
        var itemSize = attribute.itemSize;
        var array2 = new array.constructor(indices.length * itemSize);
        var index = 0,
            index2 = 0;

        for (var i = 0, l = indices.length; i < l; i++) {
          index = indices[i] * itemSize;

          for (var j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
          }
        }

        return new BufferAttribute(array2, itemSize);
      }

      if (this.index === null) {
        console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
        return this;
      }

      var geometry2 = new BufferGeometry();
      var indices = this.index.array;
      var attributes = this.attributes;

      for (var name in attributes) {
        var attribute = attributes[name];
        var newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.setAttribute(name, newAttribute);
      }

      var morphAttributes = this.morphAttributes;

      for (name in morphAttributes) {
        var morphArray = [];
        var morphAttribute = morphAttributes[name];

        for (var i = 0, il = morphAttribute.length; i < il; i++) {
          var attribute = morphAttribute[i];
          var newAttribute = convertBufferAttribute(attribute, indices);
          morphArray.push(newAttribute);
        }

        geometry2.morphAttributes[name] = morphArray;
      }

      geometry2.morphTargetsRelative = this.morphTargetsRelative;
      var groups = this.groups;

      for (var i = 0, l = groups.length; i < l; i++) {
        var group = groups[i];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }

      return geometry2;
    },
    toJSON: function toJSON() {
      var data = {
        metadata: {
          version: 4.5,
          type: 'BufferGeometry',
          generator: 'BufferGeometry.toJSON'
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== '') data.name = this.name;
      if (Object.keys(this.userData).length > 0) data.userData = this.userData;

      if (this.parameters !== undefined) {
        var parameters = this.parameters;

        for (var key in parameters) {
          if (parameters[key] !== undefined) data[key] = parameters[key];
        }

        return data;
      }

      data.data = {
        attributes: {}
      };
      var index = this.index;

      if (index !== null) {
        data.data.index = {
          type: index.array.constructor.name,
          array: Array.prototype.slice.call(index.array)
        };
      }

      var attributes = this.attributes;

      for (var key in attributes) {
        var attribute = attributes[key];
        var attributeData = attribute.toJSON();
        if (attribute.name !== '') attributeData.name = attribute.name;
        data.data.attributes[key] = attributeData;
      }

      var morphAttributes = {};
      var hasMorphAttributes = false;

      for (var key in this.morphAttributes) {
        var attributeArray = this.morphAttributes[key];
        var array = [];

        for (var i = 0, il = attributeArray.length; i < il; i++) {
          var attribute = attributeArray[i];
          var attributeData = attribute.toJSON();
          if (attribute.name !== '') attributeData.name = attribute.name;
          array.push(attributeData);
        }

        if (array.length > 0) {
          morphAttributes[key] = array;
          hasMorphAttributes = true;
        }
      }

      if (hasMorphAttributes) {
        data.data.morphAttributes = morphAttributes;
        data.data.morphTargetsRelative = this.morphTargetsRelative;
      }

      var groups = this.groups;

      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }

      var boundingSphere = this.boundingSphere;

      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }

      return data;
    },
    clone: function clone() {
      return new BufferGeometry().copy(this);
    },
    copy: function copy(source) {
      var name, i, l;
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.name = source.name;
      var index = source.index;

      if (index !== null) {
        this.setIndex(index.clone());
      }

      var attributes = source.attributes;

      for (name in attributes) {
        var attribute = attributes[name];
        this.setAttribute(name, attribute.clone());
      }

      var morphAttributes = source.morphAttributes;

      for (name in morphAttributes) {
        var array = [];
        var morphAttribute = morphAttributes[name];

        for (i = 0, l = morphAttribute.length; i < l; i++) {
          array.push(morphAttribute[i].clone());
        }

        this.morphAttributes[name] = array;
      }

      this.morphTargetsRelative = source.morphTargetsRelative;
      var groups = source.groups;

      for (i = 0, l = groups.length; i < l; i++) {
        var group = groups[i];
        this.addGroup(group.start, group.count, group.materialIndex);
      }

      var boundingBox = source.boundingBox;

      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }

      var boundingSphere = source.boundingSphere;

      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }

      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;
      this.userData = source.userData;
      return this;
    },
    dispose: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  });

  var _inverseMatrix = new Matrix4();

  var _ray = new Ray();

  var _sphere = new Sphere();

  var _vA = new Vector3();

  var _vB = new Vector3();

  var _vC = new Vector3();

  var _tempA = new Vector3();

  var _tempB = new Vector3();

  var _tempC = new Vector3();

  var _morphA = new Vector3();

  var _morphB = new Vector3();

  var _morphC = new Vector3();

  var _uvA = new Vector2();

  var _uvB = new Vector2();

  var _uvC = new Vector2();

  var _intersectionPoint = new Vector3();

  var _intersectionPointWorld = new Vector3();

  function Mesh(geometry, material) {
    Object3D.call(this);
    this.type = 'Mesh';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new MeshBasicMaterial();
    this.updateMorphTargets();
  }

  Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Mesh,
    isMesh: true,
    copy: function copy(source) {
      Object3D.prototype.copy.call(this, source);

      if (source.morphTargetInfluences !== undefined) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }

      if (source.morphTargetDictionary !== undefined) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }

      return this;
    },
    updateMorphTargets: function updateMorphTargets() {
      var geometry = this.geometry;
      var m, ml, name;

      if (geometry.isBufferGeometry) {
        var morphAttributes = geometry.morphAttributes;
        var keys = Object.keys(morphAttributes);

        if (keys.length > 0) {
          var morphAttribute = morphAttributes[keys[0]];

          if (morphAttribute !== undefined) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};

            for (m = 0, ml = morphAttribute.length; m < ml; m++) {
              name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        var morphTargets = geometry.morphTargets;

        if (morphTargets !== undefined && morphTargets.length > 0) {
          console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
      }
    },
    raycast: function raycast(raycaster, intersects) {
      var geometry = this.geometry;
      var material = this.material;
      var matrixWorld = this.matrixWorld;
      if (material === undefined) return;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

      _sphere.copy(geometry.boundingSphere);

      _sphere.applyMatrix4(matrixWorld);

      if (raycaster.ray.intersectsSphere(_sphere) === false) return;

      _inverseMatrix.getInverse(matrixWorld);

      _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

      if (geometry.boundingBox !== null) {
        if (_ray.intersectsBox(geometry.boundingBox) === false) return;
      }

      var intersection;

      if (geometry.isBufferGeometry) {
        var a, b, c;
        var index = geometry.index;
        var position = geometry.attributes.position;
        var morphPosition = geometry.morphAttributes.position;
        var morphTargetsRelative = geometry.morphTargetsRelative;
        var uv = geometry.attributes.uv;
        var uv2 = geometry.attributes.uv2;
        var groups = geometry.groups;
        var drawRange = geometry.drawRange;
        var i, j, il, jl;
        var group, groupMaterial;
        var start, end;

        if (index !== null) {
          if (Array.isArray(material)) {
            for (i = 0, il = groups.length; i < il; i++) {
              group = groups[i];
              groupMaterial = material[group.materialIndex];
              start = Math.max(group.start, drawRange.start);
              end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

              for (j = start, jl = end; j < jl; j += 3) {
                a = index.getX(j);
                b = index.getX(j + 1);
                c = index.getX(j + 2);
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects.push(intersection);
                }
              }
            }
          } else {
            start = Math.max(0, drawRange.start);
            end = Math.min(index.count, drawRange.start + drawRange.count);

            for (i = start, il = end; i < il; i += 3) {
              a = index.getX(i);
              b = index.getX(i + 1);
              c = index.getX(i + 2);
              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects.push(intersection);
              }
            }
          }
        } else if (position !== undefined) {
          if (Array.isArray(material)) {
            for (i = 0, il = groups.length; i < il; i++) {
              group = groups[i];
              groupMaterial = material[group.materialIndex];
              start = Math.max(group.start, drawRange.start);
              end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

              for (j = start, jl = end; j < jl; j += 3) {
                a = j;
                b = j + 1;
                c = j + 2;
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects.push(intersection);
                }
              }
            }
          } else {
            start = Math.max(0, drawRange.start);
            end = Math.min(position.count, drawRange.start + drawRange.count);

            for (i = start, il = end; i < il; i += 3) {
              a = i;
              b = i + 1;
              c = i + 2;
              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects.push(intersection);
              }
            }
          }
        }
      } else if (geometry.isGeometry) {
        var fvA, fvB, fvC;
        var isMultiMaterial = Array.isArray(material);
        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var uvs;
        var faceVertexUvs = geometry.faceVertexUvs[0];
        if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

        for (var f = 0, fl = faces.length; f < fl; f++) {
          var face = faces[f];
          var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
          if (faceMaterial === undefined) continue;
          fvA = vertices[face.a];
          fvB = vertices[face.b];
          fvC = vertices[face.c];
          intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);

          if (intersection) {
            if (uvs && uvs[f]) {
              var uvs_f = uvs[f];

              _uvA.copy(uvs_f[0]);

              _uvB.copy(uvs_f[1]);

              _uvC.copy(uvs_f[2]);

              intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2());
            }

            intersection.face = face;
            intersection.faceIndex = f;
            intersects.push(intersection);
          }
        }
      }
    },
    clone: function clone() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  });

  function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    var intersect;

    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    }

    if (intersect === null) return null;

    _intersectionPointWorld.copy(point);

    _intersectionPointWorld.applyMatrix4(object.matrixWorld);

    var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far) return null;
    return {
      distance: distance,
      point: _intersectionPointWorld.clone(),
      object: object
    };
  }

  function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
    _vA.fromBufferAttribute(position, a);

    _vB.fromBufferAttribute(position, b);

    _vC.fromBufferAttribute(position, c);

    var morphInfluences = object.morphTargetInfluences;

    if (material.morphTargets && morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);

      _morphB.set(0, 0, 0);

      _morphC.set(0, 0, 0);

      for (var i = 0, il = morphPosition.length; i < il; i++) {
        var influence = morphInfluences[i];
        var morphAttribute = morphPosition[i];
        if (influence === 0) continue;

        _tempA.fromBufferAttribute(morphAttribute, a);

        _tempB.fromBufferAttribute(morphAttribute, b);

        _tempC.fromBufferAttribute(morphAttribute, c);

        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);

          _morphB.addScaledVector(_tempB, influence);

          _morphC.addScaledVector(_tempC, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(_vA), influence);

          _morphB.addScaledVector(_tempB.sub(_vB), influence);

          _morphC.addScaledVector(_tempC.sub(_vC), influence);
        }
      }

      _vA.add(_morphA);

      _vB.add(_morphB);

      _vC.add(_morphC);
    }

    var intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);

    if (intersection) {
      if (uv) {
        _uvA.fromBufferAttribute(uv, a);

        _uvB.fromBufferAttribute(uv, b);

        _uvC.fromBufferAttribute(uv, c);

        intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
      }

      if (uv2) {
        _uvA.fromBufferAttribute(uv2, a);

        _uvB.fromBufferAttribute(uv2, b);

        _uvC.fromBufferAttribute(uv2, c);

        intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
      }

      var face = new Face3(a, b, c);
      Triangle.getNormal(_vA, _vB, _vC, face.normal);
      intersection.face = face;
    }

    return intersection;
  }

  var _geometryId = 0;

  var _m1$3 = new Matrix4();

  var _obj$1 = new Object3D();

  var _offset$1 = new Vector3();

  function Geometry() {
    Object.defineProperty(this, 'id', {
      value: _geometryId += 2
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'Geometry';
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }

  Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Geometry,
    isGeometry: true,
    applyMatrix4: function applyMatrix4(matrix) {
      var normalMatrix = new Matrix3().getNormalMatrix(matrix);

      for (var i = 0, il = this.vertices.length; i < il; i++) {
        var vertex = this.vertices[i];
        vertex.applyMatrix4(matrix);
      }

      for (var i = 0, il = this.faces.length; i < il; i++) {
        var face = this.faces[i];
        face.normal.applyMatrix3(normalMatrix).normalize();

        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
          face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
        }
      }

      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }

      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }

      this.verticesNeedUpdate = true;
      this.normalsNeedUpdate = true;
      return this;
    },
    rotateX: function rotateX(angle) {
      _m1$3.makeRotationX(angle);

      this.applyMatrix4(_m1$3);
      return this;
    },
    rotateY: function rotateY(angle) {
      _m1$3.makeRotationY(angle);

      this.applyMatrix4(_m1$3);
      return this;
    },
    rotateZ: function rotateZ(angle) {
      _m1$3.makeRotationZ(angle);

      this.applyMatrix4(_m1$3);
      return this;
    },
    translate: function translate(x, y, z) {
      _m1$3.makeTranslation(x, y, z);

      this.applyMatrix4(_m1$3);
      return this;
    },
    scale: function scale(x, y, z) {
      _m1$3.makeScale(x, y, z);

      this.applyMatrix4(_m1$3);
      return this;
    },
    lookAt: function lookAt(vector) {
      _obj$1.lookAt(vector);

      _obj$1.updateMatrix();

      this.applyMatrix4(_obj$1.matrix);
      return this;
    },
    fromBufferGeometry: function fromBufferGeometry(geometry) {
      var scope = this;
      var indices = geometry.index !== null ? geometry.index.array : undefined;
      var attributes = geometry.attributes;

      if (attributes.position === undefined) {
        console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');
        return this;
      }

      var positions = attributes.position.array;
      var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
      var colors = attributes.color !== undefined ? attributes.color.array : undefined;
      var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
      var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
      if (uvs2 !== undefined) this.faceVertexUvs[1] = [];

      for (var i = 0; i < positions.length; i += 3) {
        scope.vertices.push(new Vector3().fromArray(positions, i));

        if (colors !== undefined) {
          scope.colors.push(new Color().fromArray(colors, i));
        }
      }

      function addFace(a, b, c, materialIndex) {
        var vertexColors = colors === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];
        var vertexNormals = normals === undefined ? [] : [new Vector3().fromArray(normals, a * 3), new Vector3().fromArray(normals, b * 3), new Vector3().fromArray(normals, c * 3)];
        var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
        scope.faces.push(face);

        if (uvs !== undefined) {
          scope.faceVertexUvs[0].push([new Vector2().fromArray(uvs, a * 2), new Vector2().fromArray(uvs, b * 2), new Vector2().fromArray(uvs, c * 2)]);
        }

        if (uvs2 !== undefined) {
          scope.faceVertexUvs[1].push([new Vector2().fromArray(uvs2, a * 2), new Vector2().fromArray(uvs2, b * 2), new Vector2().fromArray(uvs2, c * 2)]);
        }
      }

      var groups = geometry.groups;

      if (groups.length > 0) {
        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];
          var start = group.start;
          var count = group.count;

          for (var j = start, jl = start + count; j < jl; j += 3) {
            if (indices !== undefined) {
              addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
            } else {
              addFace(j, j + 1, j + 2, group.materialIndex);
            }
          }
        }
      } else {
        if (indices !== undefined) {
          for (var i = 0; i < indices.length; i += 3) {
            addFace(indices[i], indices[i + 1], indices[i + 2]);
          }
        } else {
          for (var i = 0; i < positions.length / 3; i += 3) {
            addFace(i, i + 1, i + 2);
          }
        }
      }

      this.computeFaceNormals();

      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }

      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }

      return this;
    },
    center: function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset$1).negate();
      this.translate(_offset$1.x, _offset$1.y, _offset$1.z);
      return this;
    },
    normalize: function normalize() {
      this.computeBoundingSphere();
      var center = this.boundingSphere.center;
      var radius = this.boundingSphere.radius;
      var s = radius === 0 ? 1 : 1.0 / radius;
      var matrix = new Matrix4();
      matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
      this.applyMatrix4(matrix);
      return this;
    },
    computeFaceNormals: function computeFaceNormals() {
      var cb = new Vector3(),
          ab = new Vector3();

      for (var f = 0, fl = this.faces.length; f < fl; f++) {
        var face = this.faces[f];
        var vA = this.vertices[face.a];
        var vB = this.vertices[face.b];
        var vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        cb.normalize();
        face.normal.copy(cb);
      }
    },
    computeVertexNormals: function computeVertexNormals(areaWeighted) {
      if (areaWeighted === undefined) areaWeighted = true;
      var v, vl, f, fl, face, vertices;
      vertices = new Array(this.vertices.length);

      for (v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v] = new Vector3();
      }

      if (areaWeighted) {
        var vA, vB, vC;
        var cb = new Vector3(),
            ab = new Vector3();

        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          vA = this.vertices[face.a];
          vB = this.vertices[face.b];
          vC = this.vertices[face.c];
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          cb.cross(ab);
          vertices[face.a].add(cb);
          vertices[face.b].add(cb);
          vertices[face.c].add(cb);
        }
      } else {
        this.computeFaceNormals();

        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          vertices[face.a].add(face.normal);
          vertices[face.b].add(face.normal);
          vertices[face.c].add(face.normal);
        }
      }

      for (v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v].normalize();
      }

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        var vertexNormals = face.vertexNormals;

        if (vertexNormals.length === 3) {
          vertexNormals[0].copy(vertices[face.a]);
          vertexNormals[1].copy(vertices[face.b]);
          vertexNormals[2].copy(vertices[face.c]);
        } else {
          vertexNormals[0] = vertices[face.a].clone();
          vertexNormals[1] = vertices[face.b].clone();
          vertexNormals[2] = vertices[face.c].clone();
        }
      }

      if (this.faces.length > 0) {
        this.normalsNeedUpdate = true;
      }
    },
    computeFlatVertexNormals: function computeFlatVertexNormals() {
      var f, fl, face;
      this.computeFaceNormals();

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        var vertexNormals = face.vertexNormals;

        if (vertexNormals.length === 3) {
          vertexNormals[0].copy(face.normal);
          vertexNormals[1].copy(face.normal);
          vertexNormals[2].copy(face.normal);
        } else {
          vertexNormals[0] = face.normal.clone();
          vertexNormals[1] = face.normal.clone();
          vertexNormals[2] = face.normal.clone();
        }
      }

      if (this.faces.length > 0) {
        this.normalsNeedUpdate = true;
      }
    },
    computeMorphNormals: function computeMorphNormals() {
      var i, il, f, fl, face;

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];

        if (!face.__originalFaceNormal) {
          face.__originalFaceNormal = face.normal.clone();
        } else {
          face.__originalFaceNormal.copy(face.normal);
        }

        if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

        for (i = 0, il = face.vertexNormals.length; i < il; i++) {
          if (!face.__originalVertexNormals[i]) {
            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
          } else {
            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
          }
        }
      }

      var tmpGeo = new Geometry();
      tmpGeo.faces = this.faces;

      for (i = 0, il = this.morphTargets.length; i < il; i++) {
        if (!this.morphNormals[i]) {
          this.morphNormals[i] = {};
          this.morphNormals[i].faceNormals = [];
          this.morphNormals[i].vertexNormals = [];
          var dstNormalsFace = this.morphNormals[i].faceNormals;
          var dstNormalsVertex = this.morphNormals[i].vertexNormals;
          var faceNormal, vertexNormals;

          for (f = 0, fl = this.faces.length; f < fl; f++) {
            faceNormal = new Vector3();
            vertexNormals = {
              a: new Vector3(),
              b: new Vector3(),
              c: new Vector3()
            };
            dstNormalsFace.push(faceNormal);
            dstNormalsVertex.push(vertexNormals);
          }
        }

        var morphNormals = this.morphNormals[i];
        tmpGeo.vertices = this.morphTargets[i].vertices;
        tmpGeo.computeFaceNormals();
        tmpGeo.computeVertexNormals();
        var faceNormal, vertexNormals;

        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          faceNormal = morphNormals.faceNormals[f];
          vertexNormals = morphNormals.vertexNormals[f];
          faceNormal.copy(face.normal);
          vertexNormals.a.copy(face.vertexNormals[0]);
          vertexNormals.b.copy(face.vertexNormals[1]);
          vertexNormals.c.copy(face.vertexNormals[2]);
        }
      }

      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        face.normal = face.__originalFaceNormal;
        face.vertexNormals = face.__originalVertexNormals;
      }
    },
    computeBoundingBox: function computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }

      this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }

      this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function merge(geometry, matrix, materialIndexOffset) {
      if (!(geometry && geometry.isGeometry)) {
        console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
        return;
      }

      var normalMatrix,
          vertexOffset = this.vertices.length,
          vertices1 = this.vertices,
          vertices2 = geometry.vertices,
          faces1 = this.faces,
          faces2 = geometry.faces,
          colors1 = this.colors,
          colors2 = geometry.colors;
      if (materialIndexOffset === undefined) materialIndexOffset = 0;

      if (matrix !== undefined) {
        normalMatrix = new Matrix3().getNormalMatrix(matrix);
      }

      for (var i = 0, il = vertices2.length; i < il; i++) {
        var vertex = vertices2[i];
        var vertexCopy = vertex.clone();
        if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
        vertices1.push(vertexCopy);
      }

      for (var i = 0, il = colors2.length; i < il; i++) {
        colors1.push(colors2[i].clone());
      }

      for (i = 0, il = faces2.length; i < il; i++) {
        var face = faces2[i],
            faceCopy,
            normal,
            color,
            faceVertexNormals = face.vertexNormals,
            faceVertexColors = face.vertexColors;
        faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
        faceCopy.normal.copy(face.normal);

        if (normalMatrix !== undefined) {
          faceCopy.normal.applyMatrix3(normalMatrix).normalize();
        }

        for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
          normal = faceVertexNormals[j].clone();

          if (normalMatrix !== undefined) {
            normal.applyMatrix3(normalMatrix).normalize();
          }

          faceCopy.vertexNormals.push(normal);
        }

        faceCopy.color.copy(face.color);

        for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
          color = faceVertexColors[j];
          faceCopy.vertexColors.push(color.clone());
        }

        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
        faces1.push(faceCopy);
      }

      for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {
        var faceVertexUvs2 = geometry.faceVertexUvs[i];
        if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];

        for (var j = 0, jl = faceVertexUvs2.length; j < jl; j++) {
          var uvs2 = faceVertexUvs2[j],
              uvsCopy = [];

          for (var k = 0, kl = uvs2.length; k < kl; k++) {
            uvsCopy.push(uvs2[k].clone());
          }

          this.faceVertexUvs[i].push(uvsCopy);
        }
      }
    },
    mergeMesh: function mergeMesh(mesh) {
      if (!(mesh && mesh.isMesh)) {
        console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
        return;
      }

      if (mesh.matrixAutoUpdate) mesh.updateMatrix();
      this.merge(mesh.geometry, mesh.matrix);
    },
    mergeVertices: function mergeVertices() {
      var verticesMap = {};
      var unique = [],
          changes = [];
      var v, key;
      var precisionPoints = 4;
      var precision = Math.pow(10, precisionPoints);
      var i, il, face;
      var indices, j, jl;

      for (i = 0, il = this.vertices.length; i < il; i++) {
        v = this.vertices[i];
        key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

        if (verticesMap[key] === undefined) {
          verticesMap[key] = i;
          unique.push(this.vertices[i]);
          changes[i] = unique.length - 1;
        } else {
          changes[i] = changes[verticesMap[key]];
        }
      }

      var faceIndicesToRemove = [];

      for (i = 0, il = this.faces.length; i < il; i++) {
        face = this.faces[i];
        face.a = changes[face.a];
        face.b = changes[face.b];
        face.c = changes[face.c];
        indices = [face.a, face.b, face.c];

        for (var n = 0; n < 3; n++) {
          if (indices[n] === indices[(n + 1) % 3]) {
            faceIndicesToRemove.push(i);
            break;
          }
        }
      }

      for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
        var idx = faceIndicesToRemove[i];
        this.faces.splice(idx, 1);

        for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
          this.faceVertexUvs[j].splice(idx, 1);
        }
      }

      var diff = this.vertices.length - unique.length;
      this.vertices = unique;
      return diff;
    },
    setFromPoints: function setFromPoints(points) {
      this.vertices = [];

      for (var i = 0, l = points.length; i < l; i++) {
        var point = points[i];
        this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
      }

      return this;
    },
    sortFacesByMaterialIndex: function sortFacesByMaterialIndex() {
      var faces = this.faces;
      var length = faces.length;

      for (var i = 0; i < length; i++) {
        faces[i]._id = i;
      }

      function materialIndexSort(a, b) {
        return a.materialIndex - b.materialIndex;
      }

      faces.sort(materialIndexSort);
      var uvs1 = this.faceVertexUvs[0];
      var uvs2 = this.faceVertexUvs[1];
      var newUvs1, newUvs2;
      if (uvs1 && uvs1.length === length) newUvs1 = [];
      if (uvs2 && uvs2.length === length) newUvs2 = [];

      for (var i = 0; i < length; i++) {
        var id = faces[i]._id;
        if (newUvs1) newUvs1.push(uvs1[id]);
        if (newUvs2) newUvs2.push(uvs2[id]);
      }

      if (newUvs1) this.faceVertexUvs[0] = newUvs1;
      if (newUvs2) this.faceVertexUvs[1] = newUvs2;
    },
    toJSON: function toJSON() {
      var data = {
        metadata: {
          version: 4.5,
          type: 'Geometry',
          generator: 'Geometry.toJSON'
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== '') data.name = this.name;

      if (this.parameters !== undefined) {
        var parameters = this.parameters;

        for (var key in parameters) {
          if (parameters[key] !== undefined) data[key] = parameters[key];
        }

        return data;
      }

      var vertices = [];

      for (var i = 0; i < this.vertices.length; i++) {
        var vertex = this.vertices[i];
        vertices.push(vertex.x, vertex.y, vertex.z);
      }

      var faces = [];
      var normals = [];
      var normalsHash = {};
      var colors = [];
      var colorsHash = {};
      var uvs = [];
      var uvsHash = {};

      for (var i = 0; i < this.faces.length; i++) {
        var face = this.faces[i];
        var hasMaterial = true;
        var hasFaceUv = false;
        var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
        var hasFaceNormal = face.normal.length() > 0;
        var hasFaceVertexNormal = face.vertexNormals.length > 0;
        var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
        var hasFaceVertexColor = face.vertexColors.length > 0;
        var faceType = 0;
        faceType = setBit(faceType, 0, 0);
        faceType = setBit(faceType, 1, hasMaterial);
        faceType = setBit(faceType, 2, hasFaceUv);
        faceType = setBit(faceType, 3, hasFaceVertexUv);
        faceType = setBit(faceType, 4, hasFaceNormal);
        faceType = setBit(faceType, 5, hasFaceVertexNormal);
        faceType = setBit(faceType, 6, hasFaceColor);
        faceType = setBit(faceType, 7, hasFaceVertexColor);
        faces.push(faceType);
        faces.push(face.a, face.b, face.c);
        faces.push(face.materialIndex);

        if (hasFaceVertexUv) {
          var faceVertexUvs = this.faceVertexUvs[0][i];
          faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
        }

        if (hasFaceNormal) {
          faces.push(getNormalIndex(face.normal));
        }

        if (hasFaceVertexNormal) {
          var vertexNormals = face.vertexNormals;
          faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
        }

        if (hasFaceColor) {
          faces.push(getColorIndex(face.color));
        }

        if (hasFaceVertexColor) {
          var vertexColors = face.vertexColors;
          faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
        }
      }

      function setBit(value, position, enabled) {
        return enabled ? value | 1 << position : value & ~(1 << position);
      }

      function getNormalIndex(normal) {
        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

        if (normalsHash[hash] !== undefined) {
          return normalsHash[hash];
        }

        normalsHash[hash] = normals.length / 3;
        normals.push(normal.x, normal.y, normal.z);
        return normalsHash[hash];
      }

      function getColorIndex(color) {
        var hash = color.r.toString() + color.g.toString() + color.b.toString();

        if (colorsHash[hash] !== undefined) {
          return colorsHash[hash];
        }

        colorsHash[hash] = colors.length;
        colors.push(color.getHex());
        return colorsHash[hash];
      }

      function getUvIndex(uv) {
        var hash = uv.x.toString() + uv.y.toString();

        if (uvsHash[hash] !== undefined) {
          return uvsHash[hash];
        }

        uvsHash[hash] = uvs.length / 2;
        uvs.push(uv.x, uv.y);
        return uvsHash[hash];
      }

      data.data = {};
      data.data.vertices = vertices;
      data.data.normals = normals;
      if (colors.length > 0) data.data.colors = colors;
      if (uvs.length > 0) data.data.uvs = [uvs];
      data.data.faces = faces;
      return data;
    },
    clone: function clone() {
      return new Geometry().copy(this);
    },
    copy: function copy(source) {
      var i, il, j, jl, k, kl;
      this.vertices = [];
      this.colors = [];
      this.faces = [];
      this.faceVertexUvs = [[]];
      this.morphTargets = [];
      this.morphNormals = [];
      this.skinWeights = [];
      this.skinIndices = [];
      this.lineDistances = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.name = source.name;
      var vertices = source.vertices;

      for (i = 0, il = vertices.length; i < il; i++) {
        this.vertices.push(vertices[i].clone());
      }

      var colors = source.colors;

      for (i = 0, il = colors.length; i < il; i++) {
        this.colors.push(colors[i].clone());
      }

      var faces = source.faces;

      for (i = 0, il = faces.length; i < il; i++) {
        this.faces.push(faces[i].clone());
      }

      for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
        var faceVertexUvs = source.faceVertexUvs[i];

        if (this.faceVertexUvs[i] === undefined) {
          this.faceVertexUvs[i] = [];
        }

        for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
          var uvs = faceVertexUvs[j],
              uvsCopy = [];

          for (k = 0, kl = uvs.length; k < kl; k++) {
            var uv = uvs[k];
            uvsCopy.push(uv.clone());
          }

          this.faceVertexUvs[i].push(uvsCopy);
        }
      }

      var morphTargets = source.morphTargets;

      for (i = 0, il = morphTargets.length; i < il; i++) {
        var morphTarget = {};
        morphTarget.name = morphTargets[i].name;

        if (morphTargets[i].vertices !== undefined) {
          morphTarget.vertices = [];

          for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
            morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
          }
        }

        if (morphTargets[i].normals !== undefined) {
          morphTarget.normals = [];

          for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
            morphTarget.normals.push(morphTargets[i].normals[j].clone());
          }
        }

        this.morphTargets.push(morphTarget);
      }

      var morphNormals = source.morphNormals;

      for (i = 0, il = morphNormals.length; i < il; i++) {
        var morphNormal = {};

        if (morphNormals[i].vertexNormals !== undefined) {
          morphNormal.vertexNormals = [];

          for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
            var srcVertexNormal = morphNormals[i].vertexNormals[j];
            var destVertexNormal = {};
            destVertexNormal.a = srcVertexNormal.a.clone();
            destVertexNormal.b = srcVertexNormal.b.clone();
            destVertexNormal.c = srcVertexNormal.c.clone();
            morphNormal.vertexNormals.push(destVertexNormal);
          }
        }

        if (morphNormals[i].faceNormals !== undefined) {
          morphNormal.faceNormals = [];

          for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
            morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
          }
        }

        this.morphNormals.push(morphNormal);
      }

      var skinWeights = source.skinWeights;

      for (i = 0, il = skinWeights.length; i < il; i++) {
        this.skinWeights.push(skinWeights[i].clone());
      }

      var skinIndices = source.skinIndices;

      for (i = 0, il = skinIndices.length; i < il; i++) {
        this.skinIndices.push(skinIndices[i].clone());
      }

      var lineDistances = source.lineDistances;

      for (i = 0, il = lineDistances.length; i < il; i++) {
        this.lineDistances.push(lineDistances[i]);
      }

      var boundingBox = source.boundingBox;

      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }

      var boundingSphere = source.boundingSphere;

      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }

      this.elementsNeedUpdate = source.elementsNeedUpdate;
      this.verticesNeedUpdate = source.verticesNeedUpdate;
      this.uvsNeedUpdate = source.uvsNeedUpdate;
      this.normalsNeedUpdate = source.normalsNeedUpdate;
      this.colorsNeedUpdate = source.colorsNeedUpdate;
      this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
      this.groupsNeedUpdate = source.groupsNeedUpdate;
      return this;
    },
    dispose: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  });

  var BoxGeometry = function (_Geometry) {
    _inherits(BoxGeometry, _Geometry);

    function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
      var _this3;

      _classCallCheck(this, BoxGeometry);

      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(BoxGeometry).call(this));
      _this3.type = 'BoxGeometry';
      _this3.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
      };

      _this3.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));

      _this3.mergeVertices();

      return _this3;
    }

    return BoxGeometry;
  }(Geometry);

  var BoxBufferGeometry = function (_BufferGeometry) {
    _inherits(BoxBufferGeometry, _BufferGeometry);

    function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
      var _this4;

      _classCallCheck(this, BoxBufferGeometry);

      _this4 = _possibleConstructorReturn(this, _getPrototypeOf(BoxBufferGeometry).call(this));
      _this4.type = 'BoxBufferGeometry';
      _this4.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
      };

      var scope = _assertThisInitialized(_this4);

      width = width || 1;
      height = height || 1;
      depth = depth || 1;
      widthSegments = Math.floor(widthSegments) || 1;
      heightSegments = Math.floor(heightSegments) || 1;
      depthSegments = Math.floor(depthSegments) || 1;
      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      var numberOfVertices = 0;
      var groupStart = 0;
      buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0);
      buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
      buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2);
      buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
      buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4);
      buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5);

      _this4.setIndex(indices);

      _this4.setAttribute('position', new Float32BufferAttribute(vertices, 3));

      _this4.setAttribute('normal', new Float32BufferAttribute(normals, 3));

      _this4.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

      function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
        var segmentWidth = width / gridX;
        var segmentHeight = height / gridY;
        var widthHalf = width / 2;
        var heightHalf = height / 2;
        var depthHalf = depth / 2;
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var vertexCounter = 0;
        var groupCount = 0;
        var ix, iy;
        var vector = new Vector3();

        for (iy = 0; iy < gridY1; iy++) {
          var y = iy * segmentHeight - heightHalf;

          for (ix = 0; ix < gridX1; ix++) {
            var x = ix * segmentWidth - widthHalf;
            vector[u] = x * udir;
            vector[v] = y * vdir;
            vector[w] = depthHalf;
            vertices.push(vector.x, vector.y, vector.z);
            vector[u] = 0;
            vector[v] = 0;
            vector[w] = depth > 0 ? 1 : -1;
            normals.push(vector.x, vector.y, vector.z);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
            vertexCounter += 1;
          }
        }

        for (iy = 0; iy < gridY; iy++) {
          for (ix = 0; ix < gridX; ix++) {
            var a = numberOfVertices + ix + gridX1 * iy;
            var b = numberOfVertices + ix + gridX1 * (iy + 1);
            var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
            var d = numberOfVertices + (ix + 1) + gridX1 * iy;
            indices.push(a, b, d);
            indices.push(b, c, d);
            groupCount += 6;
          }
        }

        scope.addGroup(groupStart, groupCount, materialIndex);
        groupStart += groupCount;
        numberOfVertices += vertexCounter;
      }

      return _this4;
    }

    return BoxBufferGeometry;
  }(BufferGeometry);

  function cloneUniforms(src) {
    var dst = {};

    for (var u in src) {
      dst[u] = {};

      for (var p in src[u]) {
        var property = src[u][p];

        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
          dst[u][p] = property.clone();
        } else if (Array.isArray(property)) {
          dst[u][p] = property.slice();
        } else {
          dst[u][p] = property;
        }
      }
    }

    return dst;
  }

  function mergeUniforms(uniforms) {
    var merged = {};

    for (var u = 0; u < uniforms.length; u++) {
      var tmp = cloneUniforms(uniforms[u]);

      for (var p in tmp) {
        merged[p] = tmp[p];
      }
    }

    return merged;
  }

  var UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
  };
  var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

  function ShaderMaterial(parameters) {
    Material.call(this);
    this.type = 'ShaderMaterial';
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.extensions = {
      derivatives: false,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
      'color': [1, 1, 1],
      'uv': [0, 0],
      'uv2': [0, 0]
    };
    this.index0AttributeName = undefined;
    this.uniformsNeedUpdate = false;

    if (parameters !== undefined) {
      if (parameters.attributes !== undefined) {
        console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
      }

      this.setValues(parameters);
    }
  }

  ShaderMaterial.prototype = Object.create(Material.prototype);
  ShaderMaterial.prototype.constructor = ShaderMaterial;
  ShaderMaterial.prototype.isShaderMaterial = true;

  ShaderMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.extensions = source.extensions;
    return this;
  };

  ShaderMaterial.prototype.toJSON = function (meta) {
    var data = Material.prototype.toJSON.call(this, meta);
    data.uniforms = {};

    for (var name in this.uniforms) {
      var uniform = this.uniforms[name];
      var value = uniform.value;

      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: 't',
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: 'c',
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: 'v2',
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: 'v3',
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: 'v4',
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: 'm3',
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: 'm4',
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value: value
        };
      }
    }

    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    var extensions = {};

    for (var key in this.extensions) {
      if (this.extensions[key] === true) extensions[key] = true;
    }

    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
  };

  function Camera() {
    Object3D.call(this);
    this.type = 'Camera';
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }

  Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Camera,
    isCamera: true,
    copy: function copy(source, recursive) {
      Object3D.prototype.copy.call(this, source, recursive);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      return this;
    },
    getWorldDirection: function getWorldDirection(target) {
      if (target === undefined) {
        console.warn('THREE.Camera: .getWorldDirection() target is now required');
        target = new Vector3();
      }

      this.updateMatrixWorld(true);
      var e = this.matrixWorld.elements;
      return target.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function updateMatrixWorld(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    updateWorldMatrix: function updateWorldMatrix(updateParents, updateChildren) {
      Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
      this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    }
  });

  function PerspectiveCamera(fov, aspect, near, far) {
    Camera.call(this);
    this.type = 'PerspectiveCamera';
    this.fov = fov !== undefined ? fov : 50;
    this.zoom = 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.focus = 10;
    this.aspect = aspect !== undefined ? aspect : 1;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }

  PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: PerspectiveCamera,
    isPerspectiveCamera: true,
    copy: function copy(source, recursive) {
      Camera.prototype.copy.call(this, source, recursive);
      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    },
    setFocalLength: function setFocalLength(focalLength) {
      var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
      this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
      this.updateProjectionMatrix();
    },
    getFocalLength: function getFocalLength() {
      var vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / vExtentSlope;
    },
    getEffectiveFOV: function getEffectiveFOV() {
      return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
    },
    getFilmWidth: function getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      this.aspect = fullWidth / fullHeight;

      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }

      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    },
    clearViewOffset: function clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }

      this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function updateProjectionMatrix() {
      var near = this.near,
          top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom,
          height = 2 * top,
          width = this.aspect * height,
          left = -0.5 * width,
          view = this.view;

      if (this.view !== null && this.view.enabled) {
        var fullWidth = view.fullWidth,
            fullHeight = view.fullHeight;
        left += view.offsetX * width / fullWidth;
        top -= view.offsetY * height / fullHeight;
        width *= view.width / fullWidth;
        height *= view.height / fullHeight;
      }

      var skew = this.filmOffset;
      if (skew !== 0) left += near * skew / this.getFilmWidth();
      this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
      this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function toJSON(meta) {
      var data = Object3D.prototype.toJSON.call(this, meta);
      data.object.fov = this.fov;
      data.object.zoom = this.zoom;
      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;
      data.object.aspect = this.aspect;
      if (this.view !== null) data.object.view = Object.assign({}, this.view);
      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;
      return data;
    }
  });
  var fov = 90,
      aspect = 1;

  function CubeCamera(near, far, cubeResolution, options) {
    Object3D.call(this);
    this.type = 'CubeCamera';
    var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
    options = options || {
      format: RGBFormat,
      magFilter: LinearFilter,
      minFilter: LinearFilter
    };
    this.renderTarget = new WebGLCubeRenderTarget(cubeResolution, options);
    this.renderTarget.texture.name = "CubeCamera";

    this.update = function (renderer, scene) {
      if (this.parent === null) this.updateMatrixWorld();
      var currentRenderTarget = renderer.getRenderTarget();
      var renderTarget = this.renderTarget;
      var generateMipmaps = renderTarget.texture.generateMipmaps;
      renderTarget.texture.generateMipmaps = false;
      renderer.setRenderTarget(renderTarget, 0);
      renderer.render(scene, cameraPX);
      renderer.setRenderTarget(renderTarget, 1);
      renderer.render(scene, cameraNX);
      renderer.setRenderTarget(renderTarget, 2);
      renderer.render(scene, cameraPY);
      renderer.setRenderTarget(renderTarget, 3);
      renderer.render(scene, cameraNY);
      renderer.setRenderTarget(renderTarget, 4);
      renderer.render(scene, cameraPZ);
      renderTarget.texture.generateMipmaps = generateMipmaps;
      renderer.setRenderTarget(renderTarget, 5);
      renderer.render(scene, cameraNZ);
      renderer.setRenderTarget(currentRenderTarget);
    };

    this.clear = function (renderer, color, depth, stencil) {
      var currentRenderTarget = renderer.getRenderTarget();
      var renderTarget = this.renderTarget;

      for (var i = 0; i < 6; i++) {
        renderer.setRenderTarget(renderTarget, i);
        renderer.clear(color, depth, stencil);
      }

      renderer.setRenderTarget(currentRenderTarget);
    };
  }

  CubeCamera.prototype = Object.create(Object3D.prototype);
  CubeCamera.prototype.constructor = CubeCamera;

  function WebGLCubeRenderTarget(size, options, dummy) {
    if (Number.isInteger(options)) {
      console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
      options = dummy;
    }

    WebGLRenderTarget.call(this, size, size, options);
  }

  WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);
  WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;
  WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

  WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function (renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = texture.format;
    this.texture.encoding = texture.encoding;
    var scene = new Scene();
    var shader = {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "	vWorldDirection = transformDirection( position, modelMatrix );", "	#include <begin_vertex>", "	#include <project_vertex>", "}"].join('\n'),
      fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "	vec3 direction = normalize( vWorldDirection );", "	vec2 sampleUV;", "	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "	gl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join('\n')
    };
    var material = new ShaderMaterial({
      type: 'CubemapFromEquirect',
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    var mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material);
    scene.add(mesh);
    var camera = new CubeCamera(1, 10, 1);
    camera.renderTarget = this;
    camera.renderTarget.texture.name = 'CubeCameraTexture';
    camera.update(renderer, scene);
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  };

  function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
      data: data || null,
      width: width || 1,
      height: height || 1
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }

  DataTexture.prototype = Object.create(Texture.prototype);
  DataTexture.prototype.constructor = DataTexture;
  DataTexture.prototype.isDataTexture = true;

  var _sphere$1 = new Sphere();

  var _vector$5 = new Vector3();

  function Frustum(p0, p1, p2, p3, p4, p5) {
    this.planes = [p0 !== undefined ? p0 : new Plane(), p1 !== undefined ? p1 : new Plane(), p2 !== undefined ? p2 : new Plane(), p3 !== undefined ? p3 : new Plane(), p4 !== undefined ? p4 : new Plane(), p5 !== undefined ? p5 : new Plane()];
  }

  Object.assign(Frustum.prototype, {
    set: function set(p0, p1, p2, p3, p4, p5) {
      var planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(frustum) {
      var planes = this.planes;

      for (var i = 0; i < 6; i++) {
        planes[i].copy(frustum.planes[i]);
      }

      return this;
    },
    setFromProjectionMatrix: function setFromProjectionMatrix(m) {
      var planes = this.planes;
      var me = m.elements;
      var me0 = me[0],
          me1 = me[1],
          me2 = me[2],
          me3 = me[3];
      var me4 = me[4],
          me5 = me[5],
          me6 = me[6],
          me7 = me[7];
      var me8 = me[8],
          me9 = me[9],
          me10 = me[10],
          me11 = me[11];
      var me12 = me[12],
          me13 = me[13],
          me14 = me[14],
          me15 = me[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
      return this;
    },
    intersectsObject: function intersectsObject(object) {
      var geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

      _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

      return this.intersectsSphere(_sphere$1);
    },
    intersectsSprite: function intersectsSprite(sprite) {
      _sphere$1.center.set(0, 0, 0);

      _sphere$1.radius = 0.7071067811865476;

      _sphere$1.applyMatrix4(sprite.matrixWorld);

      return this.intersectsSphere(_sphere$1);
    },
    intersectsSphere: function intersectsSphere(sphere) {
      var planes = this.planes;
      var center = sphere.center;
      var negRadius = -sphere.radius;

      for (var i = 0; i < 6; i++) {
        var distance = planes[i].distanceToPoint(center);

        if (distance < negRadius) {
          return false;
        }
      }

      return true;
    },
    intersectsBox: function intersectsBox(box) {
      var planes = this.planes;

      for (var i = 0; i < 6; i++) {
        var plane = planes[i];
        _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

        if (plane.distanceToPoint(_vector$5) < 0) {
          return false;
        }
      }

      return true;
    },
    containsPoint: function containsPoint(point) {
      var planes = this.planes;

      for (var i = 0; i < 6; i++) {
        if (planes[i].distanceToPoint(point) < 0) {
          return false;
        }
      }

      return true;
    }
  });
  var UniformsLib = {
    common: {
      diffuse: {
        value: new Color(0xeeeeee)
      },
      opacity: {
        value: 1.0
      },
      map: {
        value: null
      },
      uvTransform: {
        value: new Matrix3()
      },
      uv2Transform: {
        value: new Matrix3()
      },
      alphaMap: {
        value: null
      }
    },
    specularmap: {
      specularMap: {
        value: null
      }
    },
    envmap: {
      envMap: {
        value: null
      },
      flipEnvMap: {
        value: -1
      },
      reflectivity: {
        value: 1.0
      },
      refractionRatio: {
        value: 0.98
      },
      maxMipLevel: {
        value: 0
      }
    },
    aomap: {
      aoMap: {
        value: null
      },
      aoMapIntensity: {
        value: 1
      }
    },
    lightmap: {
      lightMap: {
        value: null
      },
      lightMapIntensity: {
        value: 1
      }
    },
    emissivemap: {
      emissiveMap: {
        value: null
      }
    },
    bumpmap: {
      bumpMap: {
        value: null
      },
      bumpScale: {
        value: 1
      }
    },
    normalmap: {
      normalMap: {
        value: null
      },
      normalScale: {
        value: new Vector2(1, 1)
      }
    },
    displacementmap: {
      displacementMap: {
        value: null
      },
      displacementScale: {
        value: 1
      },
      displacementBias: {
        value: 0
      }
    },
    roughnessmap: {
      roughnessMap: {
        value: null
      }
    },
    metalnessmap: {
      metalnessMap: {
        value: null
      }
    },
    gradientmap: {
      gradientMap: {
        value: null
      }
    },
    fog: {
      fogDensity: {
        value: 0.00025
      },
      fogNear: {
        value: 1
      },
      fogFar: {
        value: 2000
      },
      fogColor: {
        value: new Color(0xffffff)
      }
    },
    lights: {
      ambientLightColor: {
        value: []
      },
      lightProbe: {
        value: []
      },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      directionalShadowMap: {
        value: []
      },
      directionalShadowMatrix: {
        value: []
      },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotShadowMap: {
        value: []
      },
      spotShadowMatrix: {
        value: []
      },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: {
        value: []
      },
      pointShadowMatrix: {
        value: []
      },
      hemisphereLights: {
        value: [],
        properties: {
          direction: {},
          skyColor: {},
          groundColor: {}
        }
      },
      rectAreaLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          width: {},
          height: {}
        }
      }
    },
    points: {
      diffuse: {
        value: new Color(0xeeeeee)
      },
      opacity: {
        value: 1.0
      },
      size: {
        value: 1.0
      },
      scale: {
        value: 1.0
      },
      map: {
        value: null
      },
      alphaMap: {
        value: null
      },
      uvTransform: {
        value: new Matrix3()
      }
    },
    sprite: {
      diffuse: {
        value: new Color(0xeeeeee)
      },
      opacity: {
        value: 1.0
      },
      center: {
        value: new Vector2(0.5, 0.5)
      },
      rotation: {
        value: 0.0
      },
      map: {
        value: null
      },
      alphaMap: {
        value: null
      },
      uvTransform: {
        value: new Matrix3()
      }
    }
  };

  function WebGLAnimation() {
    var context = null;
    var isAnimating = false;
    var animationLoop = null;

    function onAnimationFrame(time, frame) {
      if (isAnimating === false) return;
      animationLoop(time, frame);
      context.requestAnimationFrame(onAnimationFrame);
    }

    return {
      start: function start() {
        if (isAnimating === true) return;
        if (animationLoop === null) return;
        context.requestAnimationFrame(onAnimationFrame);
        isAnimating = true;
      },
      stop: function stop() {
        isAnimating = false;
      },
      setAnimationLoop: function setAnimationLoop(callback) {
        animationLoop = callback;
      },
      setContext: function setContext(value) {
        context = value;
      }
    };
  }

  function WebGLAttributes(gl, capabilities) {
    var isWebGL2 = capabilities.isWebGL2;
    var buffers = new WeakMap();

    function createBuffer(attribute, bufferType) {
      var array = attribute.array;
      var usage = attribute.usage;
      var buffer = gl.createBuffer();
      gl.bindBuffer(bufferType, buffer);
      gl.bufferData(bufferType, array, usage);
      attribute.onUploadCallback();
      var type = 5126;

      if (array instanceof Float32Array) {
        type = 5126;
      } else if (array instanceof Float64Array) {
        console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
      } else if (array instanceof Uint16Array) {
        type = 5123;
      } else if (array instanceof Int16Array) {
        type = 5122;
      } else if (array instanceof Uint32Array) {
        type = 5125;
      } else if (array instanceof Int32Array) {
        type = 5124;
      } else if (array instanceof Int8Array) {
        type = 5120;
      } else if (array instanceof Uint8Array) {
        type = 5121;
      }

      return {
        buffer: buffer,
        type: type,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version
      };
    }

    function updateBuffer(buffer, attribute, bufferType) {
      var array = attribute.array;
      var updateRange = attribute.updateRange;
      gl.bindBuffer(bufferType, buffer);

      if (updateRange.count === -1) {
        gl.bufferSubData(bufferType, 0, array);
      } else {
        if (isWebGL2) {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
        } else {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
        }

        updateRange.count = -1;
      }
    }

    function get(attribute) {
      if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
      return buffers.get(attribute);
    }

    function remove(attribute) {
      if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
      var data = buffers.get(attribute);

      if (data) {
        gl.deleteBuffer(data.buffer);
        buffers["delete"](attribute);
      }
    }

    function update(attribute, bufferType) {
      if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
      var data = buffers.get(attribute);

      if (data === undefined) {
        buffers.set(attribute, createBuffer(attribute, bufferType));
      } else if (data.version < attribute.version) {
        updateBuffer(data.buffer, attribute, bufferType);
        data.version = attribute.version;
      }
    }

    return {
      get: get,
      remove: remove,
      update: update
    };
  }

  function PlaneGeometry(width, height, widthSegments, heightSegments) {
    Geometry.call(this);
    this.type = 'PlaneGeometry';
    this.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
    this.mergeVertices();
  }

  PlaneGeometry.prototype = Object.create(Geometry.prototype);
  PlaneGeometry.prototype.constructor = PlaneGeometry;

  function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
    BufferGeometry.call(this);
    this.type = 'PlaneBufferGeometry';
    this.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    width = width || 1;
    height = height || 1;
    var width_half = width / 2;
    var height_half = height / 2;
    var gridX = Math.floor(widthSegments) || 1;
    var gridY = Math.floor(heightSegments) || 1;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var segment_width = width / gridX;
    var segment_height = height / gridY;
    var ix, iy;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    for (iy = 0; iy < gridY1; iy++) {
      var y = iy * segment_height - height_half;

      for (ix = 0; ix < gridX1; ix++) {
        var x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }

    for (iy = 0; iy < gridY; iy++) {
      for (ix = 0; ix < gridX; ix++) {
        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * (iy + 1);
        var c = ix + 1 + gridX1 * (iy + 1);
        var d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

  PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
  var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
  var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
  var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
  var begin_vertex = "vec3 transformed = vec3( position );";
  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
  var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif";
  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif";
  var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
  var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
  var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
  var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
  var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}";
  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";
  var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
  var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
  var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
  var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
  var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
  var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
  var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
  var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";
  var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
  var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
  var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
  var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
  var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
  var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif";
  var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
  var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
  var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
  var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = max( clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
  var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
  var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
  var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
  var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
  var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
  var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
  var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
  var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";
  var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
  var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";
  var clearcoat_normalmap_pars_fragment = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
  var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
  var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
  var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
  var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
  var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
  var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif";
  var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}";
  var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
  var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
  var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
  var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
  var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";
  var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
  var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
  var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
  var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
  var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
  var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
  var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
  var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
  var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
  var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
  var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}";
  var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}";
  var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
  var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
  var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
  var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
  var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
  var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
  var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
  var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
  var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
  var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
  var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
  var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
  var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
  var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
  var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
  var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
  var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
  var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
  var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
  var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
  var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
  var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
  var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
  var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
  var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
  var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
  var ShaderChunk = {
    alphamap_fragment: alphamap_fragment,
    alphamap_pars_fragment: alphamap_pars_fragment,
    alphatest_fragment: alphatest_fragment,
    aomap_fragment: aomap_fragment,
    aomap_pars_fragment: aomap_pars_fragment,
    begin_vertex: begin_vertex,
    beginnormal_vertex: beginnormal_vertex,
    bsdfs: bsdfs,
    bumpmap_pars_fragment: bumpmap_pars_fragment,
    clipping_planes_fragment: clipping_planes_fragment,
    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    clipping_planes_vertex: clipping_planes_vertex,
    color_fragment: color_fragment,
    color_pars_fragment: color_pars_fragment,
    color_pars_vertex: color_pars_vertex,
    color_vertex: color_vertex,
    common: common,
    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    defaultnormal_vertex: defaultnormal_vertex,
    displacementmap_pars_vertex: displacementmap_pars_vertex,
    displacementmap_vertex: displacementmap_vertex,
    emissivemap_fragment: emissivemap_fragment,
    emissivemap_pars_fragment: emissivemap_pars_fragment,
    encodings_fragment: encodings_fragment,
    encodings_pars_fragment: encodings_pars_fragment,
    envmap_fragment: envmap_fragment,
    envmap_common_pars_fragment: envmap_common_pars_fragment,
    envmap_pars_fragment: envmap_pars_fragment,
    envmap_pars_vertex: envmap_pars_vertex,
    envmap_physical_pars_fragment: envmap_physical_pars_fragment,
    envmap_vertex: envmap_vertex,
    fog_vertex: fog_vertex,
    fog_pars_vertex: fog_pars_vertex,
    fog_fragment: fog_fragment,
    fog_pars_fragment: fog_pars_fragment,
    gradientmap_pars_fragment: gradientmap_pars_fragment,
    lightmap_fragment: lightmap_fragment,
    lightmap_pars_fragment: lightmap_pars_fragment,
    lights_lambert_vertex: lights_lambert_vertex,
    lights_pars_begin: lights_pars_begin,
    lights_toon_fragment: lights_toon_fragment,
    lights_toon_pars_fragment: lights_toon_pars_fragment,
    lights_phong_fragment: lights_phong_fragment,
    lights_phong_pars_fragment: lights_phong_pars_fragment,
    lights_physical_fragment: lights_physical_fragment,
    lights_physical_pars_fragment: lights_physical_pars_fragment,
    lights_fragment_begin: lights_fragment_begin,
    lights_fragment_maps: lights_fragment_maps,
    lights_fragment_end: lights_fragment_end,
    logdepthbuf_fragment: logdepthbuf_fragment,
    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    logdepthbuf_vertex: logdepthbuf_vertex,
    map_fragment: map_fragment,
    map_pars_fragment: map_pars_fragment,
    map_particle_fragment: map_particle_fragment,
    map_particle_pars_fragment: map_particle_pars_fragment,
    metalnessmap_fragment: metalnessmap_fragment,
    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    morphnormal_vertex: morphnormal_vertex,
    morphtarget_pars_vertex: morphtarget_pars_vertex,
    morphtarget_vertex: morphtarget_vertex,
    normal_fragment_begin: normal_fragment_begin,
    normal_fragment_maps: normal_fragment_maps,
    normalmap_pars_fragment: normalmap_pars_fragment,
    clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
    clearcoat_normalmap_pars_fragment: clearcoat_normalmap_pars_fragment,
    packing: packing,
    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    project_vertex: project_vertex,
    dithering_fragment: dithering_fragment,
    dithering_pars_fragment: dithering_pars_fragment,
    roughnessmap_fragment: roughnessmap_fragment,
    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    shadowmap_pars_fragment: shadowmap_pars_fragment,
    shadowmap_pars_vertex: shadowmap_pars_vertex,
    shadowmap_vertex: shadowmap_vertex,
    shadowmask_pars_fragment: shadowmask_pars_fragment,
    skinbase_vertex: skinbase_vertex,
    skinning_pars_vertex: skinning_pars_vertex,
    skinning_vertex: skinning_vertex,
    skinnormal_vertex: skinnormal_vertex,
    specularmap_fragment: specularmap_fragment,
    specularmap_pars_fragment: specularmap_pars_fragment,
    tonemapping_fragment: tonemapping_fragment,
    tonemapping_pars_fragment: tonemapping_pars_fragment,
    uv_pars_fragment: uv_pars_fragment,
    uv_pars_vertex: uv_pars_vertex,
    uv_vertex: uv_vertex,
    uv2_pars_fragment: uv2_pars_fragment,
    uv2_pars_vertex: uv2_pars_vertex,
    uv2_vertex: uv2_vertex,
    worldpos_vertex: worldpos_vertex,
    background_frag: background_frag,
    background_vert: background_vert,
    cube_frag: cube_frag,
    cube_vert: cube_vert,
    depth_frag: depth_frag,
    depth_vert: depth_vert,
    distanceRGBA_frag: distanceRGBA_frag,
    distanceRGBA_vert: distanceRGBA_vert,
    equirect_frag: equirect_frag,
    equirect_vert: equirect_vert,
    linedashed_frag: linedashed_frag,
    linedashed_vert: linedashed_vert,
    meshbasic_frag: meshbasic_frag,
    meshbasic_vert: meshbasic_vert,
    meshlambert_frag: meshlambert_frag,
    meshlambert_vert: meshlambert_vert,
    meshmatcap_frag: meshmatcap_frag,
    meshmatcap_vert: meshmatcap_vert,
    meshtoon_frag: meshtoon_frag,
    meshtoon_vert: meshtoon_vert,
    meshphong_frag: meshphong_frag,
    meshphong_vert: meshphong_vert,
    meshphysical_frag: meshphysical_frag,
    meshphysical_vert: meshphysical_vert,
    normal_frag: normal_frag,
    normal_vert: normal_vert,
    points_frag: points_frag,
    points_vert: points_vert,
    shadow_frag: shadow_frag,
    shadow_vert: shadow_vert,
    sprite_frag: sprite_frag,
    sprite_vert: sprite_vert
  };
  var ShaderLib = {
    basic: {
      uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
      uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
        emissive: {
          value: new Color(0x000000)
        }
      }]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
      uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
        emissive: {
          value: new Color(0x000000)
        },
        specular: {
          value: new Color(0x111111)
        },
        shininess: {
          value: 30
        }
      }]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
      uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
        emissive: {
          value: new Color(0x000000)
        },
        roughness: {
          value: 0.5
        },
        metalness: {
          value: 0.5
        },
        envMapIntensity: {
          value: 1
        }
      }]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
      uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
        emissive: {
          value: new Color(0x000000)
        },
        specular: {
          value: new Color(0x111111)
        },
        shininess: {
          value: 30
        }
      }]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
      uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
        matcap: {
          value: null
        }
      }]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
      uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
      uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
        scale: {
          value: 1
        },
        dashSize: {
          value: 1
        },
        totalSize: {
          value: 2
        }
      }]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
      uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
      uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
        opacity: {
          value: 1.0
        }
      }]),
      vertexShader: ShaderChunk.normal_vert,
      fragmentShader: ShaderChunk.normal_frag
    },
    sprite: {
      uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: {
          value: new Matrix3()
        },
        t2D: {
          value: null
        }
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag
    },
    cube: {
      uniforms: mergeUniforms([UniformsLib.envmap, {
        opacity: {
          value: 1.0
        }
      }]),
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
      uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
        referencePosition: {
          value: new Vector3()
        },
        nearDistance: {
          value: 1
        },
        farDistance: {
          value: 1000
        }
      }]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
      uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
        color: {
          value: new Color(0x00000)
        },
        opacity: {
          value: 1.0
        }
      }]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag
    }
  };
  ShaderLib.physical = {
    uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
      transparency: {
        value: 0
      },
      clearcoat: {
        value: 0
      },
      clearcoatRoughness: {
        value: 0
      },
      sheen: {
        value: new Color(0x000000)
      },
      clearcoatNormalScale: {
        value: new Vector2(1, 1)
      },
      clearcoatNormalMap: {
        value: null
      }
    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  };

  function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
    var clearColor = new Color(0x000000);
    var clearAlpha = 0;
    var planeMesh;
    var boxMesh;
    var currentBackground = null;
    var currentBackgroundVersion = 0;
    var currentTonemapping = null;

    function render(renderList, scene, camera, forceClear) {
      var background = scene.background;
      var xr = renderer.xr;
      var session = xr.getSession && xr.getSession();

      if (session && session.environmentBlendMode === 'additive') {
        background = null;
      }

      if (background === null) {
        setClear(clearColor, clearAlpha);
      } else if (background && background.isColor) {
        setClear(background, 1);
        forceClear = true;
      }

      if (renderer.autoClear || forceClear) {
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      }

      if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
        if (boxMesh === undefined) {
          boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
            type: 'BackgroundCubeMaterial',
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          boxMesh.geometry.deleteAttribute('normal');
          boxMesh.geometry.deleteAttribute('uv');

          boxMesh.onBeforeRender = function (renderer, scene, camera) {
            this.matrixWorld.copyPosition(camera.matrixWorld);
          };

          Object.defineProperty(boxMesh.material, 'envMap', {
            get: function get() {
              return this.uniforms.envMap.value;
            }
          });
          objects.update(boxMesh);
        }

        var texture = background.isWebGLCubeRenderTarget ? background.texture : background;
        boxMesh.material.uniforms.envMap.value = texture;
        boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? -1 : 1;

        if (currentBackground !== background || currentBackgroundVersion !== texture.version || currentTonemapping !== renderer.toneMapping) {
          boxMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = texture.version;
          currentTonemapping = renderer.toneMapping;
        }

        renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
      } else if (background && background.isTexture) {
        if (planeMesh === undefined) {
          planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
            type: 'BackgroundMaterial',
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          planeMesh.geometry.deleteAttribute('normal');
          Object.defineProperty(planeMesh.material, 'map', {
            get: function get() {
              return this.uniforms.t2D.value;
            }
          });
          objects.update(planeMesh);
        }

        planeMesh.material.uniforms.t2D.value = background;

        if (background.matrixAutoUpdate === true) {
          background.updateMatrix();
        }

        planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          planeMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }

        renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
      }
    }

    function setClear(color, alpha) {
      state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
    }

    return {
      getClearColor: function getClearColor() {
        return clearColor;
      },
      setClearColor: function setClearColor(color, alpha) {
        clearColor.set(color);
        clearAlpha = alpha !== undefined ? alpha : 1;
        setClear(clearColor, clearAlpha);
      },
      getClearAlpha: function getClearAlpha() {
        return clearAlpha;
      },
      setClearAlpha: function setClearAlpha(alpha) {
        clearAlpha = alpha;
        setClear(clearColor, clearAlpha);
      },
      render: render
    };
  }

  function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    var isWebGL2 = capabilities.isWebGL2;
    var mode;

    function setMode(value) {
      mode = value;
    }

    function render(start, count) {
      gl.drawArrays(mode, start, count);
      info.update(count, mode);
    }

    function renderInstances(geometry, start, count, primcount) {
      if (primcount === 0) return;
      var extension, methodName;

      if (isWebGL2) {
        extension = gl;
        methodName = 'drawArraysInstanced';
      } else {
        extension = extensions.get('ANGLE_instanced_arrays');
        methodName = 'drawArraysInstancedANGLE';

        if (extension === null) {
          console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
          return;
        }
      }

      extension[methodName](mode, start, count, primcount);
      info.update(count, mode, primcount);
    }

    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
  }

  function WebGLCapabilities(gl, extensions, parameters) {
    var maxAnisotropy;

    function getMaxAnisotropy() {
      if (maxAnisotropy !== undefined) return maxAnisotropy;
      var extension = extensions.get('EXT_texture_filter_anisotropic');

      if (extension !== null) {
        maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        maxAnisotropy = 0;
      }

      return maxAnisotropy;
    }

    function getMaxPrecision(precision) {
      if (precision === 'highp') {
        if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
          return 'highp';
        }

        precision = 'mediump';
      }

      if (precision === 'mediump') {
        if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
          return 'mediump';
        }
      }

      return 'lowp';
    }

    var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
    var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
    var maxPrecision = getMaxPrecision(precision);

    if (maxPrecision !== precision) {
      console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
      precision = maxPrecision;
    }

    var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    var maxTextures = gl.getParameter(34930);
    var maxVertexTextures = gl.getParameter(35660);
    var maxTextureSize = gl.getParameter(3379);
    var maxCubemapSize = gl.getParameter(34076);
    var maxAttributes = gl.getParameter(34921);
    var maxVertexUniforms = gl.getParameter(36347);
    var maxVaryings = gl.getParameter(36348);
    var maxFragmentUniforms = gl.getParameter(36349);
    var vertexTextures = maxVertexTextures > 0;
    var floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
    var floatVertexTextures = vertexTextures && floatFragmentTextures;
    var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
      isWebGL2: isWebGL2,
      getMaxAnisotropy: getMaxAnisotropy,
      getMaxPrecision: getMaxPrecision,
      precision: precision,
      logarithmicDepthBuffer: logarithmicDepthBuffer,
      maxTextures: maxTextures,
      maxVertexTextures: maxVertexTextures,
      maxTextureSize: maxTextureSize,
      maxCubemapSize: maxCubemapSize,
      maxAttributes: maxAttributes,
      maxVertexUniforms: maxVertexUniforms,
      maxVaryings: maxVaryings,
      maxFragmentUniforms: maxFragmentUniforms,
      vertexTextures: vertexTextures,
      floatFragmentTextures: floatFragmentTextures,
      floatVertexTextures: floatVertexTextures,
      maxSamples: maxSamples
    };
  }

  function WebGLClipping() {
    var scope = this,
        globalState = null,
        numGlobalPlanes = 0,
        localClippingEnabled = false,
        renderingShadows = false,
        plane = new Plane(),
        viewNormalMatrix = new Matrix3(),
        uniform = {
      value: null,
      needsUpdate: false
    };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;

    this.init = function (planes, enableLocalClipping, camera) {
      var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
      localClippingEnabled = enableLocalClipping;
      globalState = projectPlanes(planes, camera, 0);
      numGlobalPlanes = planes.length;
      return enabled;
    };

    this.beginShadows = function () {
      renderingShadows = true;
      projectPlanes(null);
    };

    this.endShadows = function () {
      renderingShadows = false;
      resetGlobalState();
    };

    this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {
      if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
          projectPlanes(null);
        } else {
          resetGlobalState();
        }
      } else {
        var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
            lGlobal = nGlobal * 4,
            dstArray = cache.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera, lGlobal, fromCache);

        for (var i = 0; i !== lGlobal; ++i) {
          dstArray[i] = globalState[i];
        }

        cache.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;
      }
    };

    function resetGlobalState() {
      if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
      }

      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;
    }

    function projectPlanes(planes, camera, dstOffset, skipTransform) {
      var nPlanes = planes !== null ? planes.length : 0,
          dstArray = null;

      if (nPlanes !== 0) {
        dstArray = uniform.value;

        if (skipTransform !== true || dstArray === null) {
          var flatSize = dstOffset + nPlanes * 4,
              viewMatrix = camera.matrixWorldInverse;
          viewNormalMatrix.getNormalMatrix(viewMatrix);

          if (dstArray === null || dstArray.length < flatSize) {
            dstArray = new Float32Array(flatSize);
          }

          for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
            plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
            plane.normal.toArray(dstArray, i4);
            dstArray[i4 + 3] = plane.constant;
          }
        }

        uniform.value = dstArray;
        uniform.needsUpdate = true;
      }

      scope.numPlanes = nPlanes;
      return dstArray;
    }
  }

  function WebGLExtensions(gl) {
    var extensions = {};
    return {
      get: function get(name) {
        if (extensions[name] !== undefined) {
          return extensions[name];
        }

        var extension;

        switch (name) {
          case 'WEBGL_depth_texture':
            extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
            break;

          case 'EXT_texture_filter_anisotropic':
            extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            break;

          case 'WEBGL_compressed_texture_s3tc':
            extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
            break;

          case 'WEBGL_compressed_texture_pvrtc':
            extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
            break;

          default:
            extension = gl.getExtension(name);
        }

        if (extension === null) {
          console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
        }

        extensions[name] = extension;
        return extension;
      }
    };
  }

  function WebGLGeometries(gl, attributes, info) {
    var geometries = new WeakMap();
    var wireframeAttributes = new WeakMap();

    function onGeometryDispose(event) {
      var geometry = event.target;
      var buffergeometry = geometries.get(geometry);

      if (buffergeometry.index !== null) {
        attributes.remove(buffergeometry.index);
      }

      for (var name in buffergeometry.attributes) {
        attributes.remove(buffergeometry.attributes[name]);
      }

      geometry.removeEventListener('dispose', onGeometryDispose);
      geometries["delete"](geometry);
      var attribute = wireframeAttributes.get(buffergeometry);

      if (attribute) {
        attributes.remove(attribute);
        wireframeAttributes["delete"](buffergeometry);
      }

      info.memory.geometries--;
    }

    function get(object, geometry) {
      var buffergeometry = geometries.get(geometry);
      if (buffergeometry) return buffergeometry;
      geometry.addEventListener('dispose', onGeometryDispose);

      if (geometry.isBufferGeometry) {
        buffergeometry = geometry;
      } else if (geometry.isGeometry) {
        if (geometry._bufferGeometry === undefined) {
          geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
        }

        buffergeometry = geometry._bufferGeometry;
      }

      geometries.set(geometry, buffergeometry);
      info.memory.geometries++;
      return buffergeometry;
    }

    function update(geometry) {
      var index = geometry.index;
      var geometryAttributes = geometry.attributes;

      if (index !== null) {
        attributes.update(index, 34963);
      }

      for (var name in geometryAttributes) {
        attributes.update(geometryAttributes[name], 34962);
      }

      var morphAttributes = geometry.morphAttributes;

      for (var name in morphAttributes) {
        var array = morphAttributes[name];

        for (var i = 0, l = array.length; i < l; i++) {
          attributes.update(array[i], 34962);
        }
      }
    }

    function updateWireframeAttribute(geometry) {
      var indices = [];
      var geometryIndex = geometry.index;
      var geometryPosition = geometry.attributes.position;
      var version = 0;

      if (geometryIndex !== null) {
        var array = geometryIndex.array;
        version = geometryIndex.version;

        for (var i = 0, l = array.length; i < l; i += 3) {
          var a = array[i + 0];
          var b = array[i + 1];
          var c = array[i + 2];
          indices.push(a, b, b, c, c, a);
        }
      } else {
        var array = geometryPosition.array;
        version = geometryPosition.version;

        for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
          var a = i + 0;
          var b = i + 1;
          var c = i + 2;
          indices.push(a, b, b, c, c, a);
        }
      }

      var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
      attribute.version = version;
      attributes.update(attribute, 34963);
      var previousAttribute = wireframeAttributes.get(geometry);
      if (previousAttribute) attributes.remove(previousAttribute);
      wireframeAttributes.set(geometry, attribute);
    }

    function getWireframeAttribute(geometry) {
      var currentAttribute = wireframeAttributes.get(geometry);

      if (currentAttribute) {
        var geometryIndex = geometry.index;

        if (geometryIndex !== null) {
          if (currentAttribute.version < geometryIndex.version) {
            updateWireframeAttribute(geometry);
          }
        }
      } else {
        updateWireframeAttribute(geometry);
      }

      return wireframeAttributes.get(geometry);
    }

    return {
      get: get,
      update: update,
      getWireframeAttribute: getWireframeAttribute
    };
  }

  function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    var isWebGL2 = capabilities.isWebGL2;
    var mode;

    function setMode(value) {
      mode = value;
    }

    var type, bytesPerElement;

    function setIndex(value) {
      type = value.type;
      bytesPerElement = value.bytesPerElement;
    }

    function render(start, count) {
      gl.drawElements(mode, count, type, start * bytesPerElement);
      info.update(count, mode);
    }

    function renderInstances(geometry, start, count, primcount) {
      if (primcount === 0) return;
      var extension, methodName;

      if (isWebGL2) {
        extension = gl;
        methodName = 'drawElementsInstanced';
      } else {
        extension = extensions.get('ANGLE_instanced_arrays');
        methodName = 'drawElementsInstancedANGLE';

        if (extension === null) {
          console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
          return;
        }
      }

      extension[methodName](mode, count, type, start * bytesPerElement, primcount);
      info.update(count, mode, primcount);
    }

    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
  }

  function WebGLInfo(gl) {
    var memory = {
      geometries: 0,
      textures: 0
    };
    var render = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };

    function update(count, mode, instanceCount) {
      instanceCount = instanceCount || 1;
      render.calls++;

      switch (mode) {
        case 4:
          render.triangles += instanceCount * (count / 3);
          break;

        case 1:
          render.lines += instanceCount * (count / 2);
          break;

        case 3:
          render.lines += instanceCount * (count - 1);
          break;

        case 2:
          render.lines += instanceCount * count;
          break;

        case 0:
          render.points += instanceCount * count;
          break;

        default:
          console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
          break;
      }
    }

    function reset() {
      render.frame++;
      render.calls = 0;
      render.triangles = 0;
      render.points = 0;
      render.lines = 0;
    }

    return {
      memory: memory,
      render: render,
      programs: null,
      autoReset: true,
      reset: reset,
      update: update
    };
  }

  function absNumericalSort(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
  }

  function WebGLMorphtargets(gl) {
    var influencesList = {};
    var morphInfluences = new Float32Array(8);

    function update(object, geometry, material, program) {
      var objectInfluences = object.morphTargetInfluences;
      var length = objectInfluences === undefined ? 0 : objectInfluences.length;
      var influences = influencesList[geometry.id];

      if (influences === undefined) {
        influences = [];

        for (var i = 0; i < length; i++) {
          influences[i] = [i, 0];
        }

        influencesList[geometry.id] = influences;
      }

      var morphTargets = material.morphTargets && geometry.morphAttributes.position;
      var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

      for (var i = 0; i < length; i++) {
        var influence = influences[i];

        if (influence[1] !== 0) {
          if (morphTargets) geometry.deleteAttribute('morphTarget' + i);
          if (morphNormals) geometry.deleteAttribute('morphNormal' + i);
        }
      }

      for (var i = 0; i < length; i++) {
        var influence = influences[i];
        influence[0] = i;
        influence[1] = objectInfluences[i];
      }

      influences.sort(absNumericalSort);
      var morphInfluencesSum = 0;

      for (var i = 0; i < 8; i++) {
        var influence = influences[i];

        if (influence) {
          var index = influence[0];
          var value = influence[1];

          if (value) {
            if (morphTargets) geometry.setAttribute('morphTarget' + i, morphTargets[index]);
            if (morphNormals) geometry.setAttribute('morphNormal' + i, morphNormals[index]);
            morphInfluences[i] = value;
            morphInfluencesSum += value;
            continue;
          }
        }

        morphInfluences[i] = 0;
      }

      var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
      program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
    }

    return {
      update: update
    };
  }

  function WebGLObjects(gl, geometries, attributes, info) {
    var updateList = {};

    function update(object) {
      var frame = info.render.frame;
      var geometry = object.geometry;
      var buffergeometry = geometries.get(object, geometry);

      if (updateList[buffergeometry.id] !== frame) {
        if (geometry.isGeometry) {
          buffergeometry.updateFromObject(object);
        }

        geometries.update(buffergeometry);
        updateList[buffergeometry.id] = frame;
      }

      if (object.isInstancedMesh) {
        attributes.update(object.instanceMatrix, 34962);
      }

      return buffergeometry;
    }

    function dispose() {
      updateList = {};
    }

    return {
      update: update,
      dispose: dispose
    };
  }

  function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
    format = format !== undefined ? format : RGBFormat;
    Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
  }

  CubeTexture.prototype = Object.create(Texture.prototype);
  CubeTexture.prototype.constructor = CubeTexture;
  CubeTexture.prototype.isCubeTexture = true;
  Object.defineProperty(CubeTexture.prototype, 'images', {
    get: function get() {
      return this.image;
    },
    set: function set(value) {
      this.image = value;
    }
  });

  function DataTexture2DArray(data, width, height, depth) {
    Texture.call(this, null);
    this.image = {
      data: data || null,
      width: width || 1,
      height: height || 1,
      depth: depth || 1
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }

  DataTexture2DArray.prototype = Object.create(Texture.prototype);
  DataTexture2DArray.prototype.constructor = DataTexture2DArray;
  DataTexture2DArray.prototype.isDataTexture2DArray = true;

  function DataTexture3D(data, width, height, depth) {
    Texture.call(this, null);
    this.image = {
      data: data || null,
      width: width || 1,
      height: height || 1,
      depth: depth || 1
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }

  DataTexture3D.prototype = Object.create(Texture.prototype);
  DataTexture3D.prototype.constructor = DataTexture3D;
  DataTexture3D.prototype.isDataTexture3D = true;
  var emptyTexture = new Texture();
  var emptyTexture2dArray = new DataTexture2DArray();
  var emptyTexture3d = new DataTexture3D();
  var emptyCubeTexture = new CubeTexture();
  var arrayCacheF32 = [];
  var arrayCacheI32 = [];
  var mat4array = new Float32Array(16);
  var mat3array = new Float32Array(9);
  var mat2array = new Float32Array(4);

  function flatten(array, nBlocks, blockSize) {
    var firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0) return array;
    var n = nBlocks * blockSize,
        r = arrayCacheF32[n];

    if (r === undefined) {
      r = new Float32Array(n);
      arrayCacheF32[n] = r;
    }

    if (nBlocks !== 0) {
      firstElem.toArray(r, 0);

      for (var i = 1, offset = 0; i !== nBlocks; ++i) {
        offset += blockSize;
        array[i].toArray(r, offset);
      }
    }

    return r;
  }

  function arraysEqual(a, b) {
    if (a.length !== b.length) return false;

    for (var i = 0, l = a.length; i < l; i++) {
      if (a[i] !== b[i]) return false;
    }

    return true;
  }

  function copyArray(a, b) {
    for (var i = 0, l = b.length; i < l; i++) {
      a[i] = b[i];
    }
  }

  function allocTexUnits(textures, n) {
    var r = arrayCacheI32[n];

    if (r === undefined) {
      r = new Int32Array(n);
      arrayCacheI32[n] = r;
    }

    for (var i = 0; i !== n; ++i) {
      r[i] = textures.allocateTextureUnit();
    }

    return r;
  }

  function setValueV1f(gl, v) {
    var cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
  }

  function setValueV2f(gl, v) {
    var cache = this.cache;

    if (v.x !== undefined) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2f(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v)) return;
      gl.uniform2fv(this.addr, v);
      copyArray(cache, v);
    }
  }

  function setValueV3f(gl, v) {
    var cache = this.cache;

    if (v.x !== undefined) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3f(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else if (v.r !== undefined) {
      if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
        gl.uniform3f(this.addr, v.r, v.g, v.b);
        cache[0] = v.r;
        cache[1] = v.g;
        cache[2] = v.b;
      }
    } else {
      if (arraysEqual(cache, v)) return;
      gl.uniform3fv(this.addr, v);
      copyArray(cache, v);
    }
  }

  function setValueV4f(gl, v) {
    var cache = this.cache;

    if (v.x !== undefined) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v)) return;
      gl.uniform4fv(this.addr, v);
      copyArray(cache, v);
    }
  }

  function setValueM2(gl, v) {
    var cache = this.cache;
    var elements = v.elements;

    if (elements === undefined) {
      if (arraysEqual(cache, v)) return;
      gl.uniformMatrix2fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements)) return;
      mat2array.set(elements);
      gl.uniformMatrix2fv(this.addr, false, mat2array);
      copyArray(cache, elements);
    }
  }

  function setValueM3(gl, v) {
    var cache = this.cache;
    var elements = v.elements;

    if (elements === undefined) {
      if (arraysEqual(cache, v)) return;
      gl.uniformMatrix3fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements)) return;
      mat3array.set(elements);
      gl.uniformMatrix3fv(this.addr, false, mat3array);
      copyArray(cache, elements);
    }
  }

  function setValueM4(gl, v) {
    var cache = this.cache;
    var elements = v.elements;

    if (elements === undefined) {
      if (arraysEqual(cache, v)) return;
      gl.uniformMatrix4fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements)) return;
      mat4array.set(elements);
      gl.uniformMatrix4fv(this.addr, false, mat4array);
      copyArray(cache, elements);
    }
  }

  function setValueT1(gl, v, textures) {
    var cache = this.cache;
    var unit = textures.allocateTextureUnit();

    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }

    textures.safeSetTexture2D(v || emptyTexture, unit);
  }

  function setValueT2DArray1(gl, v, textures) {
    var cache = this.cache;
    var unit = textures.allocateTextureUnit();

    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }

    textures.setTexture2DArray(v || emptyTexture2dArray, unit);
  }

  function setValueT3D1(gl, v, textures) {
    var cache = this.cache;
    var unit = textures.allocateTextureUnit();

    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }

    textures.setTexture3D(v || emptyTexture3d, unit);
  }

  function setValueT6(gl, v, textures) {
    var cache = this.cache;
    var unit = textures.allocateTextureUnit();

    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }

    textures.safeSetTextureCube(v || emptyCubeTexture, unit);
  }

  function setValueV1i(gl, v) {
    var cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
  }

  function setValueV2i(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
  }

  function setValueV3i(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
  }

  function setValueV4i(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
  }

  function setValueV1ui(gl, v) {
    var cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
  }

  function getSingularSetter(type) {
    switch (type) {
      case 0x1406:
        return setValueV1f;

      case 0x8b50:
        return setValueV2f;

      case 0x8b51:
        return setValueV3f;

      case 0x8b52:
        return setValueV4f;

      case 0x8b5a:
        return setValueM2;

      case 0x8b5b:
        return setValueM3;

      case 0x8b5c:
        return setValueM4;

      case 0x1404:
      case 0x8b56:
        return setValueV1i;

      case 0x8b53:
      case 0x8b57:
        return setValueV2i;

      case 0x8b54:
      case 0x8b58:
        return setValueV3i;

      case 0x8b55:
      case 0x8b59:
        return setValueV4i;

      case 0x1405:
        return setValueV1ui;

      case 0x8b5e:
      case 0x8d66:
      case 0x8dca:
      case 0x8dd2:
      case 0x8b62:
        return setValueT1;

      case 0x8b5f:
      case 0x8dcb:
      case 0x8dd3:
        return setValueT3D1;

      case 0x8b60:
      case 0x8dcc:
      case 0x8dd4:
      case 0x8dc5:
        return setValueT6;

      case 0x8dc1:
      case 0x8dcf:
      case 0x8dd7:
      case 0x8dc4:
        return setValueT2DArray1;
    }
  }

  function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
  }

  function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
  }

  function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
  }

  function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
  }

  function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
  }

  function setValueV2fArray(gl, v) {
    var data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
  }

  function setValueV3fArray(gl, v) {
    var data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
  }

  function setValueV4fArray(gl, v) {
    var data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
  }

  function setValueM2Array(gl, v) {
    var data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
  }

  function setValueM3Array(gl, v) {
    var data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
  }

  function setValueM4Array(gl, v) {
    var data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
  }

  function setValueT1Array(gl, v, textures) {
    var n = v.length;
    var units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);

    for (var i = 0; i !== n; ++i) {
      textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
    }
  }

  function setValueT6Array(gl, v, textures) {
    var n = v.length;
    var units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);

    for (var i = 0; i !== n; ++i) {
      textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
  }

  function getPureArraySetter(type) {
    switch (type) {
      case 0x1406:
        return setValueV1fArray;

      case 0x8b50:
        return setValueV2fArray;

      case 0x8b51:
        return setValueV3fArray;

      case 0x8b52:
        return setValueV4fArray;

      case 0x8b5a:
        return setValueM2Array;

      case 0x8b5b:
        return setValueM3Array;

      case 0x8b5c:
        return setValueM4Array;

      case 0x1404:
      case 0x8b56:
        return setValueV1iArray;

      case 0x8b53:
      case 0x8b57:
        return setValueV2iArray;

      case 0x8b54:
      case 0x8b58:
        return setValueV3iArray;

      case 0x8b55:
      case 0x8b59:
        return setValueV4iArray;

      case 0x8b5e:
      case 0x8d66:
      case 0x8dca:
      case 0x8dd2:
      case 0x8b62:
        return setValueT1Array;

      case 0x8b60:
      case 0x8dcc:
      case 0x8dd4:
      case 0x8dc5:
        return setValueT6Array;
    }
  }

  function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
  }

  function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }

  PureArrayUniform.prototype.updateCache = function (data) {
    var cache = this.cache;

    if (data instanceof Float32Array && cache.length !== data.length) {
      this.cache = new Float32Array(data.length);
    }

    copyArray(cache, data);
  };

  function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }

  StructuredUniform.prototype.setValue = function (gl, value, textures) {
    var seq = this.seq;

    for (var i = 0, n = seq.length; i !== n; ++i) {
      var u = seq[i];
      u.setValue(gl, value[u.id], textures);
    }
  };

  var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

  function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
  }

  function parseUniform(activeInfo, addr, container) {
    var path = activeInfo.name,
        pathLength = path.length;
    RePathPart.lastIndex = 0;

    while (true) {
      var match = RePathPart.exec(path),
          matchEnd = RePathPart.lastIndex,
          id = match[1],
          idIsIndex = match[2] === ']',
          subscript = match[3];
      if (idIsIndex) id = id | 0;

      if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
        break;
      } else {
        var map = container.map,
            next = map[id];

        if (next === undefined) {
          next = new StructuredUniform(id);
          addUniform(container, next);
        }

        container = next;
      }
    }
  }

  function WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {};
    var n = gl.getProgramParameter(program, 35718);

    for (var i = 0; i < n; ++i) {
      var info = gl.getActiveUniform(program, i),
          addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }

  WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
    var u = this.map[name];
    if (u !== undefined) u.setValue(gl, value, textures);
  };

  WebGLUniforms.prototype.setOptional = function (gl, object, name) {
    var v = object[name];
    if (v !== undefined) this.setValue(gl, name, v);
  };

  WebGLUniforms.upload = function (gl, seq, values, textures) {
    for (var i = 0, n = seq.length; i !== n; ++i) {
      var u = seq[i],
          v = values[u.id];

      if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, textures);
      }
    }
  };

  WebGLUniforms.seqWithValue = function (seq, values) {
    var r = [];

    for (var i = 0, n = seq.length; i !== n; ++i) {
      var u = seq[i];
      if (u.id in values) r.push(u);
    }

    return r;
  };

  function WebGLShader(gl, type, string) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
  }

  var programIdCount = 0;

  function addLineNumbers(string) {
    var lines = string.split('\n');

    for (var i = 0; i < lines.length; i++) {
      lines[i] = i + 1 + ': ' + lines[i];
    }

    return lines.join('\n');
  }

  function getEncodingComponents(encoding) {
    switch (encoding) {
      case LinearEncoding:
        return ['Linear', '( value )'];

      case sRGBEncoding:
        return ['sRGB', '( value )'];

      case RGBEEncoding:
        return ['RGBE', '( value )'];

      case RGBM7Encoding:
        return ['RGBM', '( value, 7.0 )'];

      case RGBM16Encoding:
        return ['RGBM', '( value, 16.0 )'];

      case RGBDEncoding:
        return ['RGBD', '( value, 256.0 )'];

      case GammaEncoding:
        return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

      case LogLuvEncoding:
        return ['LogLuv', '( value )'];

      default:
        throw new Error('unsupported encoding: ' + encoding);
    }
  }

  function getShaderErrors(gl, shader, type) {
    var status = gl.getShaderParameter(shader, 35713);
    var log = gl.getShaderInfoLog(shader).trim();
    if (status && log === '') return '';
    var source = gl.getShaderSource(shader);
    return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
  }

  function getTexelDecodingFunction(functionName, encoding) {
    var components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
  }

  function getTexelEncodingFunction(functionName, encoding) {
    var components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
  }

  function getToneMappingFunction(functionName, toneMapping) {
    var toneMappingName;

    switch (toneMapping) {
      case LinearToneMapping:
        toneMappingName = 'Linear';
        break;

      case ReinhardToneMapping:
        toneMappingName = 'Reinhard';
        break;

      case Uncharted2ToneMapping:
        toneMappingName = 'Uncharted2';
        break;

      case CineonToneMapping:
        toneMappingName = 'OptimizedCineon';
        break;

      case ACESFilmicToneMapping:
        toneMappingName = 'ACESFilmic';
        break;

      default:
        throw new Error('unsupported toneMapping: ' + toneMapping);
    }

    return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
  }

  function generateExtensions(parameters) {
    var chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
    return chunks.filter(filterEmptyLine).join('\n');
  }

  function generateDefines(defines) {
    var chunks = [];

    for (var name in defines) {
      var value = defines[name];
      if (value === false) continue;
      chunks.push('#define ' + name + ' ' + value);
    }

    return chunks.join('\n');
  }

  function fetchAttributeLocations(gl, program) {
    var attributes = {};
    var n = gl.getProgramParameter(program, 35721);

    for (var i = 0; i < n; i++) {
      var info = gl.getActiveAttrib(program, i);
      var name = info.name;
      attributes[name] = gl.getAttribLocation(program, name);
    }

    return attributes;
  }

  function filterEmptyLine(string) {
    return string !== '';
  }

  function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
  }

  function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
  }

  var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

  function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
  }

  function includeReplacer(match, include) {
    var string = ShaderChunk[include];

    if (string === undefined) {
      throw new Error('Can not resolve #include <' + include + '>');
    }

    return resolveIncludes(string);
  }

  var loopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

  function unrollLoops(string) {
    return string.replace(loopPattern, loopReplacer);
  }

  function loopReplacer(match, start, end, snippet) {
    var string = '';

    for (var i = parseInt(start); i < parseInt(end); i++) {
      string += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
    }

    return string;
  }

  function generatePrecision(parameters) {
    var precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";

    if (parameters.precision === "highp") {
      precisionstring += "\n#define HIGH_PRECISION";
    } else if (parameters.precision === "mediump") {
      precisionstring += "\n#define MEDIUM_PRECISION";
    } else if (parameters.precision === "lowp") {
      precisionstring += "\n#define LOW_PRECISION";
    }

    return precisionstring;
  }

  function generateShadowMapTypeDefine(parameters) {
    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

    if (parameters.shadowMapType === PCFShadowMap) {
      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
    } else if (parameters.shadowMapType === VSMShadowMap) {
      shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
    }

    return shadowMapTypeDefine;
  }

  function generateEnvMapTypeDefine(parameters) {
    var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
          break;

        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
          break;

        case EquirectangularReflectionMapping:
        case EquirectangularRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
          break;

        case SphericalReflectionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
          break;
      }
    }

    return envMapTypeDefine;
  }

  function generateEnvMapModeDefine(parameters) {
    var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeRefractionMapping:
        case EquirectangularRefractionMapping:
          envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
          break;
      }
    }

    return envMapModeDefine;
  }

  function generateEnvMapBlendingDefine(parameters) {
    var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

    if (parameters.envMap) {
      switch (parameters.combine) {
        case MultiplyOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
          break;

        case MixOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
          break;

        case AddOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
          break;
      }
    }

    return envMapBlendingDefine;
  }

  function WebGLProgram(renderer, cacheKey, parameters) {
    var gl = renderer.getContext();
    var defines = parameters.defines;
    var vertexShader = parameters.vertexShader;
    var fragmentShader = parameters.fragmentShader;
    var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    var envMapModeDefine = generateEnvMapModeDefine(parameters);
    var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
    var customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
    var customDefines = generateDefines(defines);
    var program = gl.createProgram();
    var prefixVertex, prefixFragment;
    var numMultiviewViews = parameters.numMultiviewViews;

    if (parameters.isRawShaderMaterial) {
      prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

      if (prefixVertex.length > 0) {
        prefixVertex += '\n';
      }

      prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

      if (prefixFragment.length > 0) {
        prefixFragment += '\n';
      }
    } else {
      prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', ' attribute mat4 instanceMatrix;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
      prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding || parameters.lightMapEncoding ? ShaderChunk['encodings_pars_fragment'] : '', parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcapEncoding ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.lightMapEncoding ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '', parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
    }

    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);

    if (parameters.isWebGL2 && !parameters.isRawShaderMaterial) {
      var isGLSL3ShaderMaterial = false;
      var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

      if (parameters.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {
        isGLSL3ShaderMaterial = true;
        vertexShader = vertexShader.replace(versionRegex, '');
        fragmentShader = fragmentShader.replace(versionRegex, '');
      }

      prefixVertex = ['#version 300 es\n', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
      prefixFragment = ['#version 300 es\n', '#define varying in', isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;', isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;

      if (numMultiviewViews > 0) {
        prefixVertex = prefixVertex.replace('#version 300 es\n', ['#version 300 es\n', '#extension GL_OVR_multiview2 : require', 'layout(num_views = ' + numMultiviewViews + ') in;', '#define VIEW_ID gl_ViewID_OVR'].join('\n'));
        prefixVertex = prefixVertex.replace(['uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;'].join('\n'), ['uniform mat4 modelViewMatrices[' + numMultiviewViews + '];', 'uniform mat4 projectionMatrices[' + numMultiviewViews + '];', 'uniform mat4 viewMatrices[' + numMultiviewViews + '];', 'uniform mat3 normalMatrices[' + numMultiviewViews + '];', '#define modelViewMatrix modelViewMatrices[VIEW_ID]', '#define projectionMatrix projectionMatrices[VIEW_ID]', '#define viewMatrix viewMatrices[VIEW_ID]', '#define normalMatrix normalMatrices[VIEW_ID]'].join('\n'));
        prefixFragment = prefixFragment.replace('#version 300 es\n', ['#version 300 es\n', '#extension GL_OVR_multiview2 : require', '#define VIEW_ID gl_ViewID_OVR'].join('\n'));
        prefixFragment = prefixFragment.replace('uniform mat4 viewMatrix;', ['uniform mat4 viewMatrices[' + numMultiviewViews + '];', '#define viewMatrix viewMatrices[VIEW_ID]'].join('\n'));
      }
    }

    var vertexGlsl = prefixVertex + vertexShader;
    var fragmentGlsl = prefixFragment + fragmentShader;
    var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
    var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);

    if (parameters.index0AttributeName !== undefined) {
      gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      gl.bindAttribLocation(program, 0, 'position');
    }

    gl.linkProgram(program);

    if (renderer.debug.checkShaderErrors) {
      var programLog = gl.getProgramInfoLog(program).trim();
      var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      var runnable = true;
      var haveDiagnostics = true;

      if (gl.getProgramParameter(program, 35714) === false) {
        runnable = false;
        var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
        var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
        console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
      } else if (programLog !== '') {
        console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
      } else if (vertexLog === '' || fragmentLog === '') {
        haveDiagnostics = false;
      }

      if (haveDiagnostics) {
        this.diagnostics = {
          runnable: runnable,
          programLog: programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }

    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    var cachedUniforms;

    this.getUniforms = function () {
      if (cachedUniforms === undefined) {
        cachedUniforms = new WebGLUniforms(gl, program);
      }

      return cachedUniforms;
    };

    var cachedAttributes;

    this.getAttributes = function () {
      if (cachedAttributes === undefined) {
        cachedAttributes = fetchAttributeLocations(gl, program);
      }

      return cachedAttributes;
    };

    this.destroy = function () {
      gl.deleteProgram(program);
      this.program = undefined;
    };

    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    this.numMultiviewViews = numMultiviewViews;
    return this;
  }

  function WebGLPrograms(renderer, extensions, capabilities) {
    var programs = [];
    var isWebGL2 = capabilities.isWebGL2;
    var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    var floatVertexTextures = capabilities.floatVertexTextures;
    var precision = capabilities.precision;
    var maxVertexUniforms = capabilities.maxVertexUniforms;
    var vertexTextures = capabilities.vertexTextures;
    var shaderIDs = {
      MeshDepthMaterial: 'depth',
      MeshDistanceMaterial: 'distanceRGBA',
      MeshNormalMaterial: 'normal',
      MeshBasicMaterial: 'basic',
      MeshLambertMaterial: 'lambert',
      MeshPhongMaterial: 'phong',
      MeshToonMaterial: 'toon',
      MeshStandardMaterial: 'physical',
      MeshPhysicalMaterial: 'physical',
      MeshMatcapMaterial: 'matcap',
      LineBasicMaterial: 'basic',
      LineDashedMaterial: 'dashed',
      PointsMaterial: 'points',
      ShadowMaterial: 'shadow',
      SpriteMaterial: 'sprite'
    };
    var parameterNames = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "numMultiviewViews", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

    function getShaderObject(material, shaderID) {
      var shaderobject;

      if (shaderID) {
        var shader = ShaderLib[shaderID];
        shaderobject = {
          name: material.type,
          uniforms: UniformsUtils.clone(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader
        };
      } else {
        shaderobject = {
          name: material.type,
          uniforms: material.uniforms,
          vertexShader: material.vertexShader,
          fragmentShader: material.fragmentShader
        };
      }

      return shaderobject;
    }

    function allocateBones(object) {
      var skeleton = object.skeleton;
      var bones = skeleton.bones;

      if (floatVertexTextures) {
        return 1024;
      } else {
        var nVertexUniforms = maxVertexUniforms;
        var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
        var maxBones = Math.min(nVertexMatrices, bones.length);

        if (maxBones < bones.length) {
          console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
          return 0;
        }

        return maxBones;
      }
    }

    function getTextureEncodingFromMap(map) {
      var encoding;

      if (!map) {
        encoding = LinearEncoding;
      } else if (map.isTexture) {
        encoding = map.encoding;
      } else if (map.isWebGLRenderTarget) {
        console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
        encoding = map.texture.encoding;
      }

      return encoding;
    }

    this.getParameters = function (material, lights, shadows, scene, nClipPlanes, nClipIntersection, object) {
      var fog = scene.fog;
      var environment = material.isMeshStandardMaterial ? scene.environment : null;
      var envMap = material.envMap || environment;
      var shaderID = shaderIDs[material.type];
      var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;

      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);

        if (precision !== material.precision) {
          console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
        }
      }

      var shaderobject = getShaderObject(material, shaderID);
      material.onBeforeCompile(shaderobject, renderer);
      var currentRenderTarget = renderer.getRenderTarget();
      var numMultiviewViews = currentRenderTarget && currentRenderTarget.isWebGLMultiviewRenderTarget ? currentRenderTarget.numViews : 0;
      var parameters = {
        isWebGL2: isWebGL2,
        shaderID: shaderID,
        shaderName: shaderobject.name,
        uniforms: shaderobject.uniforms,
        vertexShader: shaderobject.vertexShader,
        fragmentShader: shaderobject.fragmentShader,
        defines: material.defines,
        isRawShaderMaterial: material.isRawShaderMaterial,
        isShaderMaterial: material.isShaderMaterial,
        precision: precision,
        instancing: object.isInstancedMesh === true,
        supportsVertexTextures: vertexTextures,
        numMultiviewViews: numMultiviewViews,
        outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
        map: !!material.map,
        mapEncoding: getTextureEncodingFromMap(material.map),
        matcap: !!material.matcap,
        matcapEncoding: getTextureEncodingFromMap(material.matcap),
        envMap: !!envMap,
        envMapMode: envMap && envMap.mapping,
        envMapEncoding: getTextureEncodingFromMap(envMap),
        envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
        lightMap: !!material.lightMap,
        lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
        aoMap: !!material.aoMap,
        emissiveMap: !!material.emissiveMap,
        emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
        bumpMap: !!material.bumpMap,
        normalMap: !!material.normalMap,
        objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
        tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
        clearcoatNormalMap: !!material.clearcoatNormalMap,
        displacementMap: !!material.displacementMap,
        roughnessMap: !!material.roughnessMap,
        metalnessMap: !!material.metalnessMap,
        specularMap: !!material.specularMap,
        alphaMap: !!material.alphaMap,
        gradientMap: !!material.gradientMap,
        sheen: !!material.sheen,
        combine: material.combine,
        vertexTangents: material.normalMap && material.vertexTangents,
        vertexColors: material.vertexColors,
        vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.displacementMap,
        uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap) && !!material.displacementMap,
        fog: !!fog,
        useFog: material.fog,
        fogExp2: fog && fog.isFogExp2,
        flatShading: material.flatShading,
        sizeAttenuation: material.sizeAttenuation,
        logarithmicDepthBuffer: logarithmicDepthBuffer,
        skinning: material.skinning && maxBones > 0,
        maxBones: maxBones,
        useVertexTexture: floatVertexTextures,
        morphTargets: material.morphTargets,
        morphNormals: material.morphNormals,
        maxMorphTargets: renderer.maxMorphTargets,
        maxMorphNormals: renderer.maxMorphNormals,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,
        numDirLightShadows: lights.directionalShadowMap.length,
        numPointLightShadows: lights.pointShadowMap.length,
        numSpotLightShadows: lights.spotShadowMap.length,
        numClippingPlanes: nClipPlanes,
        numClipIntersection: nClipIntersection,
        dithering: material.dithering,
        shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
        shadowMapType: renderer.shadowMap.type,
        toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
        physicallyCorrectLights: renderer.physicallyCorrectLights,
        premultipliedAlpha: material.premultipliedAlpha,
        alphaTest: material.alphaTest,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
        index0AttributeName: material.index0AttributeName,
        extensionDerivatives: material.extensions && material.extensions.derivatives,
        extensionFragDepth: material.extensions && material.extensions.frawbuffers,
        extensionDrawbuffers: material.extensions && material.extensions.drawbuffers,
        extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: isWebGL2 || extensions.get('EXT_frag_depth') !== null,
        rendererExtensionDrawBuffers: isWebGL2 || extensions.get('WEBGL_draw_buffers') !== null,
        rendererExtensionShaderTextureLod: isWebGL2 || extensions.get('EXT_shader_texture_lod') !== null,
        onBeforeCompile: material.onBeforeCompile
      };
      return parameters;
    };

    this.getProgramCacheKey = function (parameters) {
      var array = [];

      if (parameters.shaderID) {
        array.push(parameters.shaderID);
      } else {
        array.push(parameters.fragmentShader);
        array.push(parameters.vertexShader);
      }

      if (parameters.defines !== undefined) {
        for (var name in parameters.defines) {
          array.push(name);
          array.push(parameters.defines[name]);
        }
      }

      if (parameters.isRawShaderMaterial === undefined) {
        for (var i = 0; i < parameterNames.length; i++) {
          array.push(parameters[parameterNames[i]]);
        }

        array.push(renderer.outputEncoding);
        array.push(renderer.gammaFactor);
      }

      array.push(parameters.onBeforeCompile.toString());
      return array.join();
    };

    this.acquireProgram = function (parameters, cacheKey) {
      var program;

      for (var p = 0, pl = programs.length; p < pl; p++) {
        var preexistingProgram = programs[p];

        if (preexistingProgram.cacheKey === cacheKey) {
          program = preexistingProgram;
          ++program.usedTimes;
          break;
        }
      }

      if (program === undefined) {
        program = new WebGLProgram(renderer, cacheKey, parameters);
        programs.push(program);
      }

      return program;
    };

    this.releaseProgram = function (program) {
      if (--program.usedTimes === 0) {
        var i = programs.indexOf(program);
        programs[i] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    };

    this.programs = programs;
  }

  function WebGLProperties() {
    var properties = new WeakMap();

    function get(object) {
      var map = properties.get(object);

      if (map === undefined) {
        map = {};
        properties.set(object, map);
      }

      return map;
    }

    function remove(object) {
      properties["delete"](object);
    }

    function update(object, key, value) {
      properties.get(object)[key] = value;
    }

    function dispose() {
      properties = new WeakMap();
    }

    return {
      get: get,
      remove: remove,
      update: update,
      dispose: dispose
    };
  }

  function painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.program !== b.program) {
      return a.program.id - b.program.id;
    } else if (a.material.id !== b.material.id) {
      return a.material.id - b.material.id;
    } else if (a.z !== b.z) {
      return a.z - b.z;
    } else {
      return a.id - b.id;
    }
  }

  function reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }

  function WebGLRenderList() {
    var renderItems = [];
    var renderItemsIndex = 0;
    var opaque = [];
    var transparent = [];
    var defaultProgram = {
      id: -1
    };

    function init() {
      renderItemsIndex = 0;
      opaque.length = 0;
      transparent.length = 0;
    }

    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
      var renderItem = renderItems[renderItemsIndex];

      if (renderItem === undefined) {
        renderItem = {
          id: object.id,
          object: object,
          geometry: geometry,
          material: material,
          program: material.program || defaultProgram,
          groupOrder: groupOrder,
          renderOrder: object.renderOrder,
          z: z,
          group: group
        };
        renderItems[renderItemsIndex] = renderItem;
      } else {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.program = material.program || defaultProgram;
        renderItem.groupOrder = groupOrder;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z;
        renderItem.group = group;
      }

      renderItemsIndex++;
      return renderItem;
    }

    function push(object, geometry, material, groupOrder, z, group) {
      var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      (material.transparent === true ? transparent : opaque).push(renderItem);
    }

    function unshift(object, geometry, material, groupOrder, z, group) {
      var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      (material.transparent === true ? transparent : opaque).unshift(renderItem);
    }

    function sort(customOpaqueSort, customTransparentSort) {
      if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
      if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
    }

    return {
      opaque: opaque,
      transparent: transparent,
      init: init,
      push: push,
      unshift: unshift,
      sort: sort
    };
  }

  function WebGLRenderLists() {
    var lists = new WeakMap();

    function onSceneDispose(event) {
      var scene = event.target;
      scene.removeEventListener('dispose', onSceneDispose);
      lists["delete"](scene);
    }

    function get(scene, camera) {
      var cameras = lists.get(scene);
      var list;

      if (cameras === undefined) {
        list = new WebGLRenderList();
        lists.set(scene, new WeakMap());
        lists.get(scene).set(camera, list);
        scene.addEventListener('dispose', onSceneDispose);
      } else {
        list = cameras.get(camera);

        if (list === undefined) {
          list = new WebGLRenderList();
          cameras.set(camera, list);
        }
      }

      return list;
    }

    function dispose() {
      lists = new WeakMap();
    }

    return {
      get: get,
      dispose: dispose
    };
  }

  function UniformsCache() {
    var lights = {};
    return {
      get: function get(light) {
        if (lights[light.id] !== undefined) {
          return lights[light.id];
        }

        var uniforms;

        switch (light.type) {
          case 'DirectionalLight':
            uniforms = {
              direction: new Vector3(),
              color: new Color(),
              shadow: false,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;

          case 'SpotLight':
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
              shadow: false,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;

          case 'PointLight':
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0,
              shadow: false,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1000
            };
            break;

          case 'HemisphereLight':
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;

          case 'RectAreaLight':
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
            };
            break;
        }

        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }

  var nextVersion = 0;

  function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
  }

  function WebGLLights() {
    var cache = new UniformsCache();
    var state = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      point: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    };

    for (var i = 0; i < 9; i++) {
      state.probe.push(new Vector3());
    }

    var vector3 = new Vector3();
    var matrix4 = new Matrix4();
    var matrix42 = new Matrix4();

    function setup(lights, shadows, camera) {
      var r = 0,
          g = 0,
          b = 0;

      for (var i = 0; i < 9; i++) {
        state.probe[i].set(0, 0, 0);
      }

      var directionalLength = 0;
      var pointLength = 0;
      var spotLength = 0;
      var rectAreaLength = 0;
      var hemiLength = 0;
      var numDirectionalShadows = 0;
      var numPointShadows = 0;
      var numSpotShadows = 0;
      var viewMatrix = camera.matrixWorldInverse;
      lights.sort(shadowCastingLightsFirst);

      for (var i = 0, l = lights.length; i < l; i++) {
        var light = lights[i];
        var color = light.color;
        var intensity = light.intensity;
        var distance = light.distance;
        var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

        if (light.isAmbientLight) {
          r += color.r * intensity;
          g += color.g * intensity;
          b += color.b * intensity;
        } else if (light.isLightProbe) {
          for (var j = 0; j < 9; j++) {
            state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
          }
        } else if (light.isDirectionalLight) {
          var uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity);
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          uniforms.shadow = light.castShadow;

          if (light.castShadow) {
            var shadow = light.shadow;
            uniforms.shadowBias = shadow.bias;
            uniforms.shadowRadius = shadow.radius;
            uniforms.shadowMapSize = shadow.mapSize;
            state.directionalShadowMap[directionalLength] = shadowMap;
            state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
            numDirectionalShadows++;
          }

          state.directional[directionalLength] = uniforms;
          directionalLength++;
        } else if (light.isSpotLight) {
          var uniforms = cache.get(light);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.distance = distance;
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          uniforms.coneCos = Math.cos(light.angle);
          uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
          uniforms.decay = light.decay;
          uniforms.shadow = light.castShadow;

          if (light.castShadow) {
            var shadow = light.shadow;
            uniforms.shadowBias = shadow.bias;
            uniforms.shadowRadius = shadow.radius;
            uniforms.shadowMapSize = shadow.mapSize;
            state.spotShadowMap[spotLength] = shadowMap;
            state.spotShadowMatrix[spotLength] = light.shadow.matrix;
            numSpotShadows++;
          }

          state.spot[spotLength] = uniforms;
          spotLength++;
        } else if (light.isRectAreaLight) {
          var uniforms = cache.get(light);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          matrix42.identity();
          matrix4.copy(light.matrixWorld);
          matrix4.premultiply(viewMatrix);
          matrix42.extractRotation(matrix4);
          uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
          uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
          uniforms.halfWidth.applyMatrix4(matrix42);
          uniforms.halfHeight.applyMatrix4(matrix42);
          state.rectArea[rectAreaLength] = uniforms;
          rectAreaLength++;
        } else if (light.isPointLight) {
          var uniforms = cache.get(light);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity);
          uniforms.distance = light.distance;
          uniforms.decay = light.decay;
          uniforms.shadow = light.castShadow;

          if (light.castShadow) {
            var shadow = light.shadow;
            uniforms.shadowBias = shadow.bias;
            uniforms.shadowRadius = shadow.radius;
            uniforms.shadowMapSize = shadow.mapSize;
            uniforms.shadowCameraNear = shadow.camera.near;
            uniforms.shadowCameraFar = shadow.camera.far;
            state.pointShadowMap[pointLength] = shadowMap;
            state.pointShadowMatrix[pointLength] = light.shadow.matrix;
            numPointShadows++;
          }

          state.point[pointLength] = uniforms;
          pointLength++;
        } else if (light.isHemisphereLight) {
          var uniforms = cache.get(light);
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          uniforms.direction.transformDirection(viewMatrix);
          uniforms.direction.normalize();
          uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
          uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
          state.hemi[hemiLength] = uniforms;
          hemiLength++;
        }
      }

      state.ambient[0] = r;
      state.ambient[1] = g;
      state.ambient[2] = b;
      var hash = state.hash;

      if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
        state.directional.length = directionalLength;
        state.spot.length = spotLength;
        state.rectArea.length = rectAreaLength;
        state.point.length = pointLength;
        state.hemi.length = hemiLength;
        state.directionalShadowMap.length = numDirectionalShadows;
        state.pointShadowMap.length = numPointShadows;
        state.spotShadowMap.length = numSpotShadows;
        state.directionalShadowMatrix.length = numDirectionalShadows;
        state.pointShadowMatrix.length = numPointShadows;
        state.spotShadowMatrix.length = numSpotShadows;
        hash.directionalLength = directionalLength;
        hash.pointLength = pointLength;
        hash.spotLength = spotLength;
        hash.rectAreaLength = rectAreaLength;
        hash.hemiLength = hemiLength;
        hash.numDirectionalShadows = numDirectionalShadows;
        hash.numPointShadows = numPointShadows;
        hash.numSpotShadows = numSpotShadows;
        state.version = nextVersion++;
      }
    }

    return {
      setup: setup,
      state: state
    };
  }

  function WebGLRenderState() {
    var lights = new WebGLLights();
    var lightsArray = [];
    var shadowsArray = [];

    function init() {
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }

    function pushLight(light) {
      lightsArray.push(light);
    }

    function pushShadow(shadowLight) {
      shadowsArray.push(shadowLight);
    }

    function setupLights(camera) {
      lights.setup(lightsArray, shadowsArray, camera);
    }

    var state = {
      lightsArray: lightsArray,
      shadowsArray: shadowsArray,
      lights: lights
    };
    return {
      init: init,
      state: state,
      setupLights: setupLights,
      pushLight: pushLight,
      pushShadow: pushShadow
    };
  }

  function WebGLRenderStates() {
    var renderStates = new WeakMap();

    function onSceneDispose(event) {
      var scene = event.target;
      scene.removeEventListener('dispose', onSceneDispose);
      renderStates["delete"](scene);
    }

    function get(scene, camera) {
      var renderState;

      if (renderStates.has(scene) === false) {
        renderState = new WebGLRenderState();
        renderStates.set(scene, new WeakMap());
        renderStates.get(scene).set(camera, renderState);
        scene.addEventListener('dispose', onSceneDispose);
      } else {
        if (renderStates.get(scene).has(camera) === false) {
          renderState = new WebGLRenderState();
          renderStates.get(scene).set(camera, renderState);
        } else {
          renderState = renderStates.get(scene).get(camera);
        }
      }

      return renderState;
    }

    function dispose() {
      renderStates = new WeakMap();
    }

    return {
      get: get,
      dispose: dispose
    };
  }

  function MeshDepthMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshDepthMaterial';
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }

  MeshDepthMaterial.prototype = Object.create(Material.prototype);
  MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

  MeshDepthMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  };

  function MeshDistanceMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshDistanceMaterial';
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1000;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }

  MeshDistanceMaterial.prototype = Object.create(Material.prototype);
  MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
  MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

  MeshDistanceMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  };

  var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
  var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

  function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
    var _frustum = new Frustum(),
        _shadowMapSize = new Vector2(),
        _viewportSize = new Vector2(),
        _viewport = new Vector4(),
        _depthMaterials = [],
        _distanceMaterials = [],
        _materialCache = {};

    var shadowSide = {
      0: BackSide,
      1: FrontSide,
      2: DoubleSide
    };
    var shadowMaterialVertical = new ShaderMaterial({
      defines: {
        SAMPLE_RATE: 2.0 / 8.0,
        HALF_SAMPLE_RATE: 1.0 / 8.0
      },
      uniforms: {
        shadow_pass: {
          value: null
        },
        resolution: {
          value: new Vector2()
        },
        radius: {
          value: 4.0
        }
      },
      vertexShader: vsm_vert,
      fragmentShader: vsm_frag
    });
    var shadowMaterialHorizonal = shadowMaterialVertical.clone();
    shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
    var fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    var scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;

    this.render = function (lights, scene, camera) {
      if (scope.enabled === false) return;
      if (scope.autoUpdate === false && scope.needsUpdate === false) return;
      if (lights.length === 0) return;

      var currentRenderTarget = _renderer.getRenderTarget();

      var activeCubeFace = _renderer.getActiveCubeFace();

      var activeMipmapLevel = _renderer.getActiveMipmapLevel();

      var _state = _renderer.state;

      _state.setBlending(NoBlending);

      _state.buffers.color.setClear(1, 1, 1, 1);

      _state.buffers.depth.setTest(true);

      _state.setScissorTest(false);

      for (var i = 0, il = lights.length; i < il; i++) {
        var light = lights[i];
        var shadow = light.shadow;

        if (shadow === undefined) {
          console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
          continue;
        }

        _shadowMapSize.copy(shadow.mapSize);

        var shadowFrameExtents = shadow.getFrameExtents();

        _shadowMapSize.multiply(shadowFrameExtents);

        _viewportSize.copy(shadow.mapSize);

        if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
          console.warn('THREE.WebGLShadowMap:', light, 'has shadow exceeding max texture size, reducing');

          if (_shadowMapSize.x > maxTextureSize) {
            _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
            _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
            shadow.mapSize.x = _viewportSize.x;
          }

          if (_shadowMapSize.y > maxTextureSize) {
            _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
            _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
            shadow.mapSize.y = _viewportSize.y;
          }
        }

        if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
          var pars = {
            minFilter: LinearFilter,
            magFilter: LinearFilter,
            format: RGBAFormat
          };
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.camera.updateProjectionMatrix();
        }

        if (shadow.map === null) {
          var pars = {
            minFilter: NearestFilter,
            magFilter: NearestFilter,
            format: RGBAFormat
          };
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.camera.updateProjectionMatrix();
        }

        _renderer.setRenderTarget(shadow.map);

        _renderer.clear();

        var viewportCount = shadow.getViewportCount();

        for (var vp = 0; vp < viewportCount; vp++) {
          var viewport = shadow.getViewport(vp);

          _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

          _state.viewport(_viewport);

          shadow.updateMatrices(light, vp);
          _frustum = shadow.getFrustum();
          renderObject(scene, camera, shadow.camera, light, this.type);
        }

        if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
          VSMPass(shadow, camera);
        }
      }

      scope.needsUpdate = false;

      _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };

    function VSMPass(shadow, camera) {
      var geometry = _objects.update(fullScreenMesh);

      shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
      shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialVertical.uniforms.radius.value = shadow.radius;

      _renderer.setRenderTarget(shadow.mapPass);

      _renderer.clear();

      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);

      shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
      shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;

      _renderer.setRenderTarget(shadow.map);

      _renderer.clear();

      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
    }

    function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
      var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
      var material = _depthMaterials[index];

      if (material === undefined) {
        material = new MeshDepthMaterial({
          depthPacking: RGBADepthPacking,
          morphTargets: useMorphing,
          skinning: useSkinning
        });
        _depthMaterials[index] = material;
      }

      return material;
    }

    function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
      var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
      var material = _distanceMaterials[index];

      if (material === undefined) {
        material = new MeshDistanceMaterial({
          morphTargets: useMorphing,
          skinning: useSkinning
        });
        _distanceMaterials[index] = material;
      }

      return material;
    }

    function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
      var geometry = object.geometry;
      var result = null;
      var getMaterialVariant = getDepthMaterialVariant;
      var customMaterial = object.customDepthMaterial;

      if (light.isPointLight === true) {
        getMaterialVariant = getDistanceMaterialVariant;
        customMaterial = object.customDistanceMaterial;
      }

      if (customMaterial === undefined) {
        var useMorphing = false;

        if (material.morphTargets === true) {
          if (geometry.isBufferGeometry === true) {
            useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
          } else if (geometry.isGeometry === true) {
            useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
          }
        }

        var useSkinning = false;

        if (object.isSkinnedMesh === true) {
          if (material.skinning === true) {
            useSkinning = true;
          } else {
            console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
          }
        }

        var useInstancing = object.isInstancedMesh === true;
        result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
      } else {
        result = customMaterial;
      }

      if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
        var keyA = result.uuid,
            keyB = material.uuid;
        var materialsForVariant = _materialCache[keyA];

        if (materialsForVariant === undefined) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }

        var cachedMaterial = materialsForVariant[keyB];

        if (cachedMaterial === undefined) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
        }

        result = cachedMaterial;
      }

      result.visible = material.visible;
      result.wireframe = material.wireframe;

      if (type === VSMShadowMap) {
        result.side = material.shadowSide !== null ? material.shadowSide : material.side;
      } else {
        result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
      }

      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;
      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;

      if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
        result.referencePosition.setFromMatrixPosition(light.matrixWorld);
        result.nearDistance = shadowCameraNear;
        result.farDistance = shadowCameraFar;
      }

      return result;
    }

    function renderObject(object, camera, shadowCamera, light, type) {
      if (object.visible === false) return;
      var visible = object.layers.test(camera.layers);

      if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

          var geometry = _objects.update(object);

          var material = object.material;

          if (Array.isArray(material)) {
            var groups = geometry.groups;

            for (var k = 0, kl = groups.length; k < kl; k++) {
              var group = groups[k];
              var groupMaterial = material[group.materialIndex];

              if (groupMaterial && groupMaterial.visible) {
                var depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              }
            }
          } else if (material.visible) {
            var depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);

            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          }
        }
      }

      var children = object.children;

      for (var i = 0, l = children.length; i < l; i++) {
        renderObject(children[i], camera, shadowCamera, light, type);
      }
    }
  }

  function WebGLState(gl, extensions, capabilities) {
    var _equationToGL, _factorToGL;

    var isWebGL2 = capabilities.isWebGL2;

    function ColorBuffer() {
      var locked = false;
      var color = new Vector4();
      var currentColorMask = null;
      var currentColorClear = new Vector4(0, 0, 0, 0);
      return {
        setMask: function setMask(colorMask) {
          if (currentColorMask !== colorMask && !locked) {
            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
            currentColorMask = colorMask;
          }
        },
        setLocked: function setLocked(lock) {
          locked = lock;
        },
        setClear: function setClear(r, g, b, a, premultipliedAlpha) {
          if (premultipliedAlpha === true) {
            r *= a;
            g *= a;
            b *= a;
          }

          color.set(r, g, b, a);

          if (currentColorClear.equals(color) === false) {
            gl.clearColor(r, g, b, a);
            currentColorClear.copy(color);
          }
        },
        reset: function reset() {
          locked = false;
          currentColorMask = null;
          currentColorClear.set(-1, 0, 0, 0);
        }
      };
    }

    function DepthBuffer() {
      var locked = false;
      var currentDepthMask = null;
      var currentDepthFunc = null;
      var currentDepthClear = null;
      return {
        setTest: function setTest(depthTest) {
          if (depthTest) {
            enable(2929);
          } else {
            disable(2929);
          }
        },
        setMask: function setMask(depthMask) {
          if (currentDepthMask !== depthMask && !locked) {
            gl.depthMask(depthMask);
            currentDepthMask = depthMask;
          }
        },
        setFunc: function setFunc(depthFunc) {
          if (currentDepthFunc !== depthFunc) {
            if (depthFunc) {
              switch (depthFunc) {
                case NeverDepth:
                  gl.depthFunc(512);
                  break;

                case AlwaysDepth:
                  gl.depthFunc(519);
                  break;

                case LessDepth:
                  gl.depthFunc(513);
                  break;

                case LessEqualDepth:
                  gl.depthFunc(515);
                  break;

                case EqualDepth:
                  gl.depthFunc(514);
                  break;

                case GreaterEqualDepth:
                  gl.depthFunc(518);
                  break;

                case GreaterDepth:
                  gl.depthFunc(516);
                  break;

                case NotEqualDepth:
                  gl.depthFunc(517);
                  break;

                default:
                  gl.depthFunc(515);
              }
            } else {
              gl.depthFunc(515);
            }

            currentDepthFunc = depthFunc;
          }
        },
        setLocked: function setLocked(lock) {
          locked = lock;
        },
        setClear: function setClear(depth) {
          if (currentDepthClear !== depth) {
            gl.clearDepth(depth);
            currentDepthClear = depth;
          }
        },
        reset: function reset() {
          locked = false;
          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;
        }
      };
    }

    function StencilBuffer() {
      var locked = false;
      var currentStencilMask = null;
      var currentStencilFunc = null;
      var currentStencilRef = null;
      var currentStencilFuncMask = null;
      var currentStencilFail = null;
      var currentStencilZFail = null;
      var currentStencilZPass = null;
      var currentStencilClear = null;
      return {
        setTest: function setTest(stencilTest) {
          if (!locked) {
            if (stencilTest) {
              enable(2960);
            } else {
              disable(2960);
            }
          }
        },
        setMask: function setMask(stencilMask) {
          if (currentStencilMask !== stencilMask && !locked) {
            gl.stencilMask(stencilMask);
            currentStencilMask = stencilMask;
          }
        },
        setFunc: function setFunc(stencilFunc, stencilRef, stencilMask) {
          if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;
          }
        },
        setOp: function setOp(stencilFail, stencilZFail, stencilZPass) {
          if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;
          }
        },
        setLocked: function setLocked(lock) {
          locked = lock;
        },
        setClear: function setClear(stencil) {
          if (currentStencilClear !== stencil) {
            gl.clearStencil(stencil);
            currentStencilClear = stencil;
          }
        },
        reset: function reset() {
          locked = false;
          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;
        }
      };
    }

    var colorBuffer = new ColorBuffer();
    var depthBuffer = new DepthBuffer();
    var stencilBuffer = new StencilBuffer();
    var maxVertexAttributes = gl.getParameter(34921);
    var newAttributes = new Uint8Array(maxVertexAttributes);
    var enabledAttributes = new Uint8Array(maxVertexAttributes);
    var attributeDivisors = new Uint8Array(maxVertexAttributes);
    var enabledCapabilities = {};
    var currentProgram = null;
    var currentBlendingEnabled = null;
    var currentBlending = null;
    var currentBlendEquation = null;
    var currentBlendSrc = null;
    var currentBlendDst = null;
    var currentBlendEquationAlpha = null;
    var currentBlendSrcAlpha = null;
    var currentBlendDstAlpha = null;
    var currentPremultipledAlpha = false;
    var currentFlipSided = null;
    var currentCullFace = null;
    var currentLineWidth = null;
    var currentPolygonOffsetFactor = null;
    var currentPolygonOffsetUnits = null;
    var maxTextures = gl.getParameter(35661);
    var lineWidthAvailable = false;
    var version = 0;
    var glVersion = gl.getParameter(7938);

    if (glVersion.indexOf('WebGL') !== -1) {
      version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 1.0;
    } else if (glVersion.indexOf('OpenGL ES') !== -1) {
      version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 2.0;
    }

    var currentTextureSlot = null;
    var currentBoundTextures = {};
    var currentScissor = new Vector4();
    var currentViewport = new Vector4();

    function createTexture(type, target, count) {
      var data = new Uint8Array(4);
      var texture = gl.createTexture();
      gl.bindTexture(type, texture);
      gl.texParameteri(type, 10241, 9728);
      gl.texParameteri(type, 10240, 9728);

      for (var i = 0; i < count; i++) {
        gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
      }

      return texture;
    }

    var emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);

    function initAttributes() {
      for (var i = 0, l = newAttributes.length; i < l; i++) {
        newAttributes[i] = 0;
      }
    }

    function enableAttribute(attribute) {
      enableAttributeAndDivisor(attribute, 0);
    }

    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
      newAttributes[attribute] = 1;

      if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }

      if (attributeDivisors[attribute] !== meshPerAttribute) {
        var extension = isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
        extension[isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    }

    function disableUnusedAttributes() {
      for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
        if (enabledAttributes[i] !== newAttributes[i]) {
          gl.disableVertexAttribArray(i);
          enabledAttributes[i] = 0;
        }
      }
    }

    function enable(id) {
      if (enabledCapabilities[id] !== true) {
        gl.enable(id);
        enabledCapabilities[id] = true;
      }
    }

    function disable(id) {
      if (enabledCapabilities[id] !== false) {
        gl.disable(id);
        enabledCapabilities[id] = false;
      }
    }

    function useProgram(program) {
      if (currentProgram !== program) {
        gl.useProgram(program);
        currentProgram = program;
        return true;
      }

      return false;
    }

    var equationToGL = (_equationToGL = {}, _defineProperty(_equationToGL, AddEquation, 32774), _defineProperty(_equationToGL, SubtractEquation, 32778), _defineProperty(_equationToGL, ReverseSubtractEquation, 32779), _equationToGL);

    if (isWebGL2) {
      equationToGL[MinEquation] = 32775;
      equationToGL[MaxEquation] = 32776;
    } else {
      var extension = extensions.get('EXT_blend_minmax');

      if (extension !== null) {
        equationToGL[MinEquation] = extension.MIN_EXT;
        equationToGL[MaxEquation] = extension.MAX_EXT;
      }
    }

    var factorToGL = (_factorToGL = {}, _defineProperty(_factorToGL, ZeroFactor, 0), _defineProperty(_factorToGL, OneFactor, 1), _defineProperty(_factorToGL, SrcColorFactor, 768), _defineProperty(_factorToGL, SrcAlphaFactor, 770), _defineProperty(_factorToGL, SrcAlphaSaturateFactor, 776), _defineProperty(_factorToGL, DstColorFactor, 774), _defineProperty(_factorToGL, DstAlphaFactor, 772), _defineProperty(_factorToGL, OneMinusSrcColorFactor, 769), _defineProperty(_factorToGL, OneMinusSrcAlphaFactor, 771), _defineProperty(_factorToGL, OneMinusDstColorFactor, 775), _defineProperty(_factorToGL, OneMinusDstAlphaFactor, 773), _factorToGL);

    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
      if (blending === NoBlending) {
        if (currentBlendingEnabled) {
          disable(3042);
          currentBlendingEnabled = false;
        }

        return;
      }

      if (!currentBlendingEnabled) {
        enable(3042);
        currentBlendingEnabled = true;
      }

      if (blending !== CustomBlending) {
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
          if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
            gl.blendEquation(32774);
            currentBlendEquation = AddEquation;
            currentBlendEquationAlpha = AddEquation;
          }

          if (premultipliedAlpha) {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(1, 771, 1, 771);
                break;

              case AdditiveBlending:
                gl.blendFunc(1, 1);
                break;

              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 0, 769, 771);
                break;

              case MultiplyBlending:
                gl.blendFuncSeparate(0, 768, 0, 770);
                break;

              default:
                console.error('THREE.WebGLState: Invalid blending: ', blending);
                break;
            }
          } else {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(770, 771, 1, 771);
                break;

              case AdditiveBlending:
                gl.blendFunc(770, 1);
                break;

              case SubtractiveBlending:
                gl.blendFunc(0, 769);
                break;

              case MultiplyBlending:
                gl.blendFunc(0, 768);
                break;

              default:
                console.error('THREE.WebGLState: Invalid blending: ', blending);
                break;
            }
          }

          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentBlending = blending;
          currentPremultipledAlpha = premultipliedAlpha;
        }

        return;
      }

      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;

      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }

      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }

      currentBlending = blending;
      currentPremultipledAlpha = null;
    }

    function setMaterial(material, frontFaceCW) {
      material.side === DoubleSide ? disable(2884) : enable(2884);
      var flipSided = material.side === BackSide;
      if (frontFaceCW) flipSided = !flipSided;
      setFlipSided(flipSided);
      material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
      depthBuffer.setFunc(material.depthFunc);
      depthBuffer.setTest(material.depthTest);
      depthBuffer.setMask(material.depthWrite);
      colorBuffer.setMask(material.colorWrite);
      var stencilWrite = material.stencilWrite;
      stencilBuffer.setTest(stencilWrite);

      if (stencilWrite) {
        stencilBuffer.setMask(material.stencilWriteMask);
        stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
        stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
      }

      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    }

    function setFlipSided(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl.frontFace(2304);
        } else {
          gl.frontFace(2305);
        }

        currentFlipSided = flipSided;
      }
    }

    function setCullFace(cullFace) {
      if (cullFace !== CullFaceNone) {
        enable(2884);

        if (cullFace !== currentCullFace) {
          if (cullFace === CullFaceBack) {
            gl.cullFace(1029);
          } else if (cullFace === CullFaceFront) {
            gl.cullFace(1028);
          } else {
            gl.cullFace(1032);
          }
        }
      } else {
        disable(2884);
      }

      currentCullFace = cullFace;
    }

    function setLineWidth(width) {
      if (width !== currentLineWidth) {
        if (lineWidthAvailable) gl.lineWidth(width);
        currentLineWidth = width;
      }
    }

    function setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        enable(32823);

        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      } else {
        disable(32823);
      }
    }

    function setScissorTest(scissorTest) {
      if (scissorTest) {
        enable(3089);
      } else {
        disable(3089);
      }
    }

    function activeTexture(webglSlot) {
      if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;

      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    }

    function bindTexture(webglType, webglTexture) {
      if (currentTextureSlot === null) {
        activeTexture();
      }

      var boundTexture = currentBoundTextures[currentTextureSlot];

      if (boundTexture === undefined) {
        boundTexture = {
          type: undefined,
          texture: undefined
        };
        currentBoundTextures[currentTextureSlot] = boundTexture;
      }

      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    }

    function unbindTexture() {
      var boundTexture = currentBoundTextures[currentTextureSlot];

      if (boundTexture !== undefined && boundTexture.type !== undefined) {
        gl.bindTexture(boundTexture.type, null);
        boundTexture.type = undefined;
        boundTexture.texture = undefined;
      }
    }

    function compressedTexImage2D() {
      try {
        gl.compressedTexImage2D.apply(gl, arguments);
      } catch (error) {
        console.error('THREE.WebGLState:', error);
      }
    }

    function texImage2D() {
      try {
        gl.texImage2D.apply(gl, arguments);
      } catch (error) {
        console.error('THREE.WebGLState:', error);
      }
    }

    function texImage3D() {
      try {
        gl.texImage3D.apply(gl, arguments);
      } catch (error) {
        console.error('THREE.WebGLState:', error);
      }
    }

    function scissor(scissor) {
      if (currentScissor.equals(scissor) === false) {
        gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
        currentScissor.copy(scissor);
      }
    }

    function viewport(viewport) {
      if (currentViewport.equals(viewport) === false) {
        gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
        currentViewport.copy(viewport);
      }
    }

    function reset() {
      for (var i = 0; i < enabledAttributes.length; i++) {
        if (enabledAttributes[i] === 1) {
          gl.disableVertexAttribArray(i);
          enabledAttributes[i] = 0;
        }
      }

      enabledCapabilities = {};
      currentTextureSlot = null;
      currentBoundTextures = {};
      currentProgram = null;
      currentBlending = null;
      currentFlipSided = null;
      currentCullFace = null;
      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();
    }

    return {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      initAttributes: initAttributes,
      enableAttribute: enableAttribute,
      enableAttributeAndDivisor: enableAttributeAndDivisor,
      disableUnusedAttributes: disableUnusedAttributes,
      enable: enable,
      disable: disable,
      useProgram: useProgram,
      setBlending: setBlending,
      setMaterial: setMaterial,
      setFlipSided: setFlipSided,
      setCullFace: setCullFace,
      setLineWidth: setLineWidth,
      setPolygonOffset: setPolygonOffset,
      setScissorTest: setScissorTest,
      activeTexture: activeTexture,
      bindTexture: bindTexture,
      unbindTexture: unbindTexture,
      compressedTexImage2D: compressedTexImage2D,
      texImage2D: texImage2D,
      texImage3D: texImage3D,
      scissor: scissor,
      viewport: viewport,
      reset: reset
    };
  }

  function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    var _wrappingToGL, _filterToGL;

    var isWebGL2 = capabilities.isWebGL2;
    var maxTextures = capabilities.maxTextures;
    var maxCubemapSize = capabilities.maxCubemapSize;
    var maxTextureSize = capabilities.maxTextureSize;
    var maxSamples = capabilities.maxSamples;

    var _videoTextures = new WeakMap();

    var _canvas;

    var useOffscreenCanvas = false;

    try {
      useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {}

    function createCanvas(width, height) {
      return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    }

    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
      var scale = 1;

      if (image.width > maxSize || image.height > maxSize) {
        scale = maxSize / Math.max(image.width, image.height);
      }

      if (scale < 1 || needsPowerOfTwo === true) {
        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
          var floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
          var width = floor(scale * image.width);
          var height = floor(scale * image.height);
          if (_canvas === undefined) _canvas = createCanvas(width, height);
          var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
          canvas.width = width;
          canvas.height = height;
          var context = canvas.getContext('2d');
          context.drawImage(image, 0, 0, width, height);
          console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
          return canvas;
        } else {
          if ('data' in image) {
            console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
          }

          return image;
        }
      }

      return image;
    }

    function isPowerOfTwo(image) {
      return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
    }

    function textureNeedsPowerOfTwo(texture) {
      if (isWebGL2) return false;
      return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }

    function textureNeedsGenerateMipmaps(texture, supportsMips) {
      return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }

    function generateMipmap(target, texture, width, height) {
      _gl.generateMipmap(target);

      var textureProperties = properties.get(texture);
      textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
    }

    function getInternalFormat(internalFormatName, glFormat, glType) {
      if (isWebGL2 === false) return glFormat;

      if (internalFormatName !== null) {
        if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
        console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
      }

      var internalFormat = glFormat;

      if (glFormat === 6403) {
        if (glType === 5126) internalFormat = 33326;
        if (glType === 5131) internalFormat = 33325;
        if (glType === 5121) internalFormat = 33321;
      }

      if (glFormat === 6407) {
        if (glType === 5126) internalFormat = 34837;
        if (glType === 5131) internalFormat = 34843;
        if (glType === 5121) internalFormat = 32849;
      }

      if (glFormat === 6408) {
        if (glType === 5126) internalFormat = 34836;
        if (glType === 5131) internalFormat = 34842;
        if (glType === 5121) internalFormat = 32856;
      }

      if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
        extensions.get('EXT_color_buffer_float');
      } else if (internalFormat === 34843 || internalFormat === 34837) {
        console.warn('THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.');
      }

      return internalFormat;
    }

    function filterFallback(f) {
      if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
        return 9728;
      }

      return 9729;
    }

    function onTextureDispose(event) {
      var texture = event.target;
      texture.removeEventListener('dispose', onTextureDispose);
      deallocateTexture(texture);

      if (texture.isVideoTexture) {
        _videoTextures["delete"](texture);
      }

      info.memory.textures--;
    }

    function onRenderTargetDispose(event) {
      var renderTarget = event.target;
      renderTarget.removeEventListener('dispose', onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
      info.memory.textures--;
    }

    function deallocateTexture(texture) {
      var textureProperties = properties.get(texture);
      if (textureProperties.__webglInit === undefined) return;

      _gl.deleteTexture(textureProperties.__webglTexture);

      properties.remove(texture);
    }

    function deallocateRenderTarget(renderTarget) {
      var renderTargetProperties = properties.get(renderTarget);
      var textureProperties = properties.get(renderTarget.texture);
      if (!renderTarget) return;

      if (textureProperties.__webglTexture !== undefined) {
        _gl.deleteTexture(textureProperties.__webglTexture);
      }

      if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
      }

      if (renderTarget.isWebGLCubeRenderTarget) {
        for (var i = 0; i < 6; i++) {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

          if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
        }
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      }

      if (renderTarget.isWebGLMultiviewRenderTarget) {
        _gl.deleteTexture(renderTargetProperties.__webglColorTexture);

        _gl.deleteTexture(renderTargetProperties.__webglDepthStencilTexture);

        info.memory.textures -= 2;

        for (var i = 0, il = renderTargetProperties.__webglViewFramebuffers.length; i < il; i++) {
          _gl.deleteFramebuffer(renderTargetProperties.__webglViewFramebuffers[i]);
        }
      }

      properties.remove(renderTarget.texture);
      properties.remove(renderTarget);
    }

    var textureUnits = 0;

    function resetTextureUnits() {
      textureUnits = 0;
    }

    function allocateTextureUnit() {
      var textureUnit = textureUnits;

      if (textureUnit >= maxTextures) {
        console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
      }

      textureUnits += 1;
      return textureUnit;
    }

    function setTexture2D(texture, slot) {
      var textureProperties = properties.get(texture);
      if (texture.isVideoTexture) updateVideoTexture(texture);

      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        var image = texture.image;

        if (image === undefined) {
          console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
        } else if (image.complete === false) {
          console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
        } else {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
      }

      state.activeTexture(33984 + slot);
      state.bindTexture(3553, textureProperties.__webglTexture);
    }

    function setTexture2DArray(texture, slot) {
      var textureProperties = properties.get(texture);

      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }

      state.activeTexture(33984 + slot);
      state.bindTexture(35866, textureProperties.__webglTexture);
    }

    function setTexture3D(texture, slot) {
      var textureProperties = properties.get(texture);

      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }

      state.activeTexture(33984 + slot);
      state.bindTexture(32879, textureProperties.__webglTexture);
    }

    function setTextureCube(texture, slot) {
      if (texture.image.length !== 6) return;
      var textureProperties = properties.get(texture);

      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);

        _gl.pixelStorei(37440, texture.flipY);

        var isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
        var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        var cubeImage = [];

        for (var i = 0; i < 6; i++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
          } else {
            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
          }
        }

        var image = cubeImage[0],
            supportsMips = isPowerOfTwo(image) || isWebGL2,
            glFormat = utils.convert(texture.format),
            glType = utils.convert(texture.type),
            glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(34067, texture, supportsMips);
        var mipmaps;

        if (isCompressed) {
          for (var i = 0; i < 6; i++) {
            mipmaps = cubeImage[i].mipmaps;

            for (var j = 0; j < mipmaps.length; j++) {
              var mipmap = mipmaps[j];

              if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                if (glFormat !== null) {
                  state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                } else {
                  console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                }
              } else {
                state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }

          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          mipmaps = texture.mipmaps;

          for (var i = 0; i < 6; i++) {
            if (isDataTexture) {
              state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

              for (var j = 0; j < mipmaps.length; j++) {
                var mipmap = mipmaps[j];
                var mipmapImage = mipmap.image[i].image;
                state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            } else {
              state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);

              for (var j = 0; j < mipmaps.length; j++) {
                var mipmap = mipmaps[j];
                state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
              }
            }
          }

          textureProperties.__maxMipLevel = mipmaps.length;
        }

        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067, texture, image.width, image.height);
        }

        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
      } else {
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
      }
    }

    function setTextureCubeDynamic(texture, slot) {
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, properties.get(texture).__webglTexture);
    }

    var wrappingToGL = (_wrappingToGL = {}, _defineProperty(_wrappingToGL, RepeatWrapping, 10497), _defineProperty(_wrappingToGL, ClampToEdgeWrapping, 33071), _defineProperty(_wrappingToGL, MirroredRepeatWrapping, 33648), _wrappingToGL);
    var filterToGL = (_filterToGL = {}, _defineProperty(_filterToGL, NearestFilter, 9728), _defineProperty(_filterToGL, NearestMipmapNearestFilter, 9984), _defineProperty(_filterToGL, NearestMipmapLinearFilter, 9986), _defineProperty(_filterToGL, LinearFilter, 9729), _defineProperty(_filterToGL, LinearMipmapNearestFilter, 9985), _defineProperty(_filterToGL, LinearMipmapLinearFilter, 9987), _filterToGL);

    function setTextureParameters(textureType, texture, supportsMips) {
      if (supportsMips) {
        _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);

        _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);

        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
        }

        _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);

        _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
      } else {
        _gl.texParameteri(textureType, 10242, 33071);

        _gl.texParameteri(textureType, 10243, 33071);

        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, 33071);
        }

        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
          console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
        }

        _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));

        _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));

        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
          console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
        }
      }

      var extension = extensions.get('EXT_texture_filter_anisotropic');

      if (extension) {
        if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
        if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;

        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }

    function initTexture(textureProperties, texture) {
      if (textureProperties.__webglInit === undefined) {
        textureProperties.__webglInit = true;
        texture.addEventListener('dispose', onTextureDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
      }
    }

    function uploadTexture(textureProperties, texture, slot) {
      var textureType = 3553;
      if (texture.isDataTexture2DArray) textureType = 35866;
      if (texture.isDataTexture3D) textureType = 32879;
      initTexture(textureProperties, texture);
      state.activeTexture(33984 + slot);
      state.bindTexture(textureType, textureProperties.__webglTexture);

      _gl.pixelStorei(37440, texture.flipY);

      _gl.pixelStorei(37441, texture.premultiplyAlpha);

      _gl.pixelStorei(3317, texture.unpackAlignment);

      var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
      var image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
      var supportsMips = isPowerOfTwo(image) || isWebGL2,
          glFormat = utils.convert(texture.format),
          glType = utils.convert(texture.type),
          glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      setTextureParameters(textureType, texture, supportsMips);
      var mipmap,
          mipmaps = texture.mipmaps;

      if (texture.isDepthTexture) {
        glInternalFormat = 6402;

        if (texture.type === FloatType) {
          if (isWebGL2 === false) throw new Error('Float Depth Texture only supported in WebGL2.0');
          glInternalFormat = 36012;
        } else if (isWebGL2) {
          glInternalFormat = 33189;
        }

        if (texture.format === DepthFormat && glInternalFormat === 6402) {
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
            texture.type = UnsignedShortType;
            glType = utils.convert(texture.type);
          }
        }

        if (texture.format === DepthStencilFormat) {
          glInternalFormat = 34041;

          if (texture.type !== UnsignedInt248Type) {
            console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
            texture.type = UnsignedInt248Type;
            glType = utils.convert(texture.type);
          }
        }

        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          for (var i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }

          texture.generateMipmaps = false;
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          textureProperties.__maxMipLevel = 0;
        }
      } else if (texture.isCompressedTexture) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];

          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
            }
          } else {
            state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }

        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else if (texture.isDataTexture2DArray) {
        state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      } else if (texture.isDataTexture3D) {
        state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          for (var i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
          }

          texture.generateMipmaps = false;
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
          textureProperties.__maxMipLevel = 0;
        }
      }

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType, texture, image.width, image.height);
      }

      textureProperties.__version = texture.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }

    function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
      var glFormat = utils.convert(renderTarget.texture.format);
      var glType = utils.convert(renderTarget.texture.type);
      var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);

      _gl.bindFramebuffer(36160, framebuffer);

      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);

      _gl.bindFramebuffer(36160, null);
    }

    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
      _gl.bindRenderbuffer(36161, renderbuffer);

      if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
        if (isMultisample) {
          var samples = getRenderTargetSamples(renderTarget);

          _gl.renderbufferStorageMultisample(36161, samples, 33189, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, 33189, renderTarget.width, renderTarget.height);
        }

        _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
      } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
        if (isMultisample) {
          var samples = getRenderTargetSamples(renderTarget);

          _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
        }

        _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
      } else {
        var glFormat = utils.convert(renderTarget.texture.format);
        var glType = utils.convert(renderTarget.texture.type);
        var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);

        if (isMultisample) {
          var samples = getRenderTargetSamples(renderTarget);

          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }

      _gl.bindRenderbuffer(36161, null);
    }

    function setupDepthTexture(framebuffer, renderTarget) {
      var isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
      if (isCube) throw new Error('Depth Texture with cube render targets is not supported');

      _gl.bindFramebuffer(36160, framebuffer);

      if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
      }

      if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
      }

      setTexture2D(renderTarget.depthTexture, 0);

      var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

      if (renderTarget.depthTexture.format === DepthFormat) {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
      } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
      } else {
        throw new Error('Unknown depthTexture format');
      }
    }

    function setupDepthRenderbuffer(renderTarget) {
      var renderTargetProperties = properties.get(renderTarget);
      var isCube = renderTarget.isWebGLCubeRenderTarget === true;

      if (renderTarget.depthTexture) {
        if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
      } else {
        if (isCube) {
          renderTargetProperties.__webglDepthbuffer = [];

          for (var i = 0; i < 6; i++) {
            _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);

            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
          }
        } else {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);

          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
        }
      }

      _gl.bindFramebuffer(36160, null);
    }

    function setupRenderTarget(renderTarget) {
      var renderTargetProperties = properties.get(renderTarget);
      var textureProperties = properties.get(renderTarget.texture);
      renderTarget.addEventListener('dispose', onRenderTargetDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
      var isCube = renderTarget.isWebGLCubeRenderTarget === true;
      var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
      var isMultiview = renderTarget.isWebGLMultiviewRenderTarget === true;
      var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;

      if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];

        for (var i = 0; i < 6; i++) {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

        if (isMultisample) {
          if (isWebGL2) {
            renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
            renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

            _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);

            var glFormat = utils.convert(renderTarget.texture.format);
            var glType = utils.convert(renderTarget.texture.type);
            var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
            var samples = getRenderTargetSamples(renderTarget);

            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);

            _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);

            _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);

            _gl.bindRenderbuffer(36161, null);

            if (renderTarget.depthBuffer) {
              renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
            }

            _gl.bindFramebuffer(36160, null);
          } else {
            console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
          }
        } else if (isMultiview) {
          var width = renderTarget.width;
          var height = renderTarget.height;
          var numViews = renderTarget.numViews;

          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);

          var ext = extensions.get('OVR_multiview2');
          info.memory.textures += 2;

          var colorTexture = _gl.createTexture();

          _gl.bindTexture(35866, colorTexture);

          _gl.texParameteri(35866, 10240, 9728);

          _gl.texParameteri(35866, 10241, 9728);

          _gl.texImage3D(35866, 0, 32856, width, height, numViews, 0, 6408, 5121, null);

          ext.framebufferTextureMultiviewOVR(36160, 36064, colorTexture, 0, 0, numViews);

          var depthStencilTexture = _gl.createTexture();

          _gl.bindTexture(35866, depthStencilTexture);

          _gl.texParameteri(35866, 10240, 9728);

          _gl.texParameteri(35866, 10241, 9728);

          _gl.texImage3D(35866, 0, 35056, width, height, numViews, 0, 34041, 34042, null);

          ext.framebufferTextureMultiviewOVR(36160, 33306, depthStencilTexture, 0, 0, numViews);
          var viewFramebuffers = new Array(numViews);

          for (var i = 0; i < numViews; ++i) {
            viewFramebuffers[i] = _gl.createFramebuffer();

            _gl.bindFramebuffer(36160, viewFramebuffers[i]);

            _gl.framebufferTextureLayer(36160, 36064, colorTexture, 0, i);
          }

          renderTargetProperties.__webglColorTexture = colorTexture;
          renderTargetProperties.__webglDepthStencilTexture = depthStencilTexture;
          renderTargetProperties.__webglViewFramebuffers = viewFramebuffers;

          _gl.bindFramebuffer(36160, null);

          _gl.bindTexture(35866, null);
        }
      }

      if (isCube) {
        state.bindTexture(34067, textureProperties.__webglTexture);
        setTextureParameters(34067, renderTarget.texture, supportsMips);

        for (var i = 0; i < 6; i++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
        }

        if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
          generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
        }

        state.bindTexture(34067, null);
      } else if (!isMultiview) {
        state.bindTexture(3553, textureProperties.__webglTexture);
        setTextureParameters(3553, renderTarget.texture, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);

        if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
          generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
        }

        state.bindTexture(3553, null);
      }

      if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
      }
    }

    function updateRenderTargetMipmap(renderTarget) {
      var texture = renderTarget.texture;
      var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;

        var webglTexture = properties.get(texture).__webglTexture;

        state.bindTexture(target, webglTexture);
        generateMipmap(target, texture, renderTarget.width, renderTarget.height);
        state.bindTexture(target, null);
      }
    }

    function updateMultisampleRenderTarget(renderTarget) {
      if (renderTarget.isWebGLMultisampleRenderTarget) {
        if (isWebGL2) {
          var renderTargetProperties = properties.get(renderTarget);

          _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);

          _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);

          var width = renderTarget.width;
          var height = renderTarget.height;
          var mask = 16384;
          if (renderTarget.depthBuffer) mask |= 256;
          if (renderTarget.stencilBuffer) mask |= 1024;

          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
        } else {
          console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
      }
    }

    function getRenderTargetSamples(renderTarget) {
      return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
    }

    function updateVideoTexture(texture) {
      var frame = info.render.frame;

      if (_videoTextures.get(texture) !== frame) {
        _videoTextures.set(texture, frame);

        texture.update();
      }
    }

    var warnedTexture2D = false;
    var warnedTextureCube = false;

    function safeSetTexture2D(texture, slot) {
      if (texture && texture.isWebGLRenderTarget) {
        if (warnedTexture2D === false) {
          console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
          warnedTexture2D = true;
        }

        texture = texture.texture;
      }

      setTexture2D(texture, slot);
    }

    function safeSetTextureCube(texture, slot) {
      if (texture && texture.isWebGLCubeRenderTarget) {
        if (warnedTextureCube === false) {
          console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
          warnedTextureCube = true;
        }

        texture = texture.texture;
      }

      if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
        setTextureCube(texture, slot);
      } else {
        setTextureCubeDynamic(texture, slot);
      }
    }

    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setTextureCubeDynamic = setTextureCubeDynamic;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
  }

  function WebGLUtils(gl, extensions, capabilities) {
    var isWebGL2 = capabilities.isWebGL2;

    function convert(p) {
      var extension;
      if (p === UnsignedByteType) return 5121;
      if (p === UnsignedShort4444Type) return 32819;
      if (p === UnsignedShort5551Type) return 32820;
      if (p === UnsignedShort565Type) return 33635;
      if (p === ByteType) return 5120;
      if (p === ShortType) return 5122;
      if (p === UnsignedShortType) return 5123;
      if (p === IntType) return 5124;
      if (p === UnsignedIntType) return 5125;
      if (p === FloatType) return 5126;

      if (p === HalfFloatType) {
        if (isWebGL2) return 5131;
        extension = extensions.get('OES_texture_half_float');

        if (extension !== null) {
          return extension.HALF_FLOAT_OES;
        } else {
          return null;
        }
      }

      if (p === AlphaFormat) return 6406;
      if (p === RGBFormat) return 6407;
      if (p === RGBAFormat) return 6408;
      if (p === LuminanceFormat) return 6409;
      if (p === LuminanceAlphaFormat) return 6410;
      if (p === DepthFormat) return 6402;
      if (p === DepthStencilFormat) return 34041;
      if (p === RedFormat) return 6403;
      if (p === RedIntegerFormat) return 36244;
      if (p === RGFormat) return 33319;
      if (p === RGIntegerFormat) return 33320;
      if (p === RGBIntegerFormat) return 36248;
      if (p === RGBAIntegerFormat) return 36249;

      if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
        extension = extensions.get('WEBGL_compressed_texture_s3tc');

        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }

      if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
        extension = extensions.get('WEBGL_compressed_texture_pvrtc');

        if (extension !== null) {
          if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else {
          return null;
        }
      }

      if (p === RGB_ETC1_Format) {
        extension = extensions.get('WEBGL_compressed_texture_etc1');

        if (extension !== null) {
          return extension.COMPRESSED_RGB_ETC1_WEBGL;
        } else {
          return null;
        }
      }

      if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
        extension = extensions.get('WEBGL_compressed_texture_astc');

        if (extension !== null) {
          return p;
        } else {
          return null;
        }
      }

      if (p === UnsignedInt248Type) {
        if (isWebGL2) return 34042;
        extension = extensions.get('WEBGL_depth_texture');

        if (extension !== null) {
          return extension.UNSIGNED_INT_24_8_WEBGL;
        } else {
          return null;
        }
      }
    }

    return {
      convert: convert
    };
  }

  function WebGLMultiviewRenderTarget(width, height, numViews, options) {
    WebGLRenderTarget.call(this, width, height, options);
    this.depthBuffer = false;
    this.stencilBuffer = false;
    this.numViews = numViews;
  }

  WebGLMultiviewRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
    constructor: WebGLMultiviewRenderTarget,
    isWebGLMultiviewRenderTarget: true,
    copy: function copy(source) {
      WebGLRenderTarget.prototype.copy.call(this, source);
      this.numViews = source.numViews;
      return this;
    },
    setNumViews: function setNumViews(numViews) {
      if (this.numViews !== numViews) {
        this.numViews = numViews;
        this.dispose();
      }

      return this;
    }
  });

  function WebGLMultiview(renderer, gl) {
    var DEFAULT_NUMVIEWS = 2;
    var extensions = renderer.extensions;
    var properties = renderer.properties;
    var renderTarget, currentRenderTarget;
    var mat3, mat4, cameraArray, renderSize;
    var available;
    var maxNumViews = 0;

    function isAvailable() {
      if (available === undefined) {
        var extension = extensions.get('OVR_multiview2');
        available = extension !== null && gl.getContextAttributes().antialias === false;

        if (available) {
          maxNumViews = gl.getParameter(extension.MAX_VIEWS_OVR);
          renderTarget = new WebGLMultiviewRenderTarget(0, 0, DEFAULT_NUMVIEWS);
          renderSize = new Vector2();
          mat4 = [];
          mat3 = [];
          cameraArray = [];

          for (var i = 0; i < maxNumViews; i++) {
            mat4[i] = new Matrix4();
            mat3[i] = new Matrix3();
          }
        }
      }

      return available;
    }

    function getCameraArray(camera) {
      if (camera.isArrayCamera) return camera.cameras;
      cameraArray[0] = camera;
      return cameraArray;
    }

    function updateCameraProjectionMatricesUniform(camera, uniforms) {
      var cameras = getCameraArray(camera);

      for (var i = 0; i < cameras.length; i++) {
        mat4[i].copy(cameras[i].projectionMatrix);
      }

      uniforms.setValue(gl, 'projectionMatrices', mat4);
    }

    function updateCameraViewMatricesUniform(camera, uniforms) {
      var cameras = getCameraArray(camera);

      for (var i = 0; i < cameras.length; i++) {
        mat4[i].copy(cameras[i].matrixWorldInverse);
      }

      uniforms.setValue(gl, 'viewMatrices', mat4);
    }

    function updateObjectMatricesUniforms(object, camera, uniforms) {
      var cameras = getCameraArray(camera);

      for (var i = 0; i < cameras.length; i++) {
        mat4[i].multiplyMatrices(cameras[i].matrixWorldInverse, object.matrixWorld);
        mat3[i].getNormalMatrix(mat4[i]);
      }

      uniforms.setValue(gl, 'modelViewMatrices', mat4);
      uniforms.setValue(gl, 'normalMatrices', mat3);
    }

    function isMultiviewCompatible(camera) {
      if (camera.isArrayCamera === undefined) return true;
      var cameras = camera.cameras;
      if (cameras.length > maxNumViews) return false;

      for (var i = 1, il = cameras.length; i < il; i++) {
        if (cameras[0].viewport.z !== cameras[i].viewport.z || cameras[0].viewport.w !== cameras[i].viewport.w) return false;
      }

      return true;
    }

    function resizeRenderTarget(camera) {
      if (currentRenderTarget) {
        renderSize.set(currentRenderTarget.width, currentRenderTarget.height);
      } else {
        renderer.getDrawingBufferSize(renderSize);
      }

      if (camera.isArrayCamera) {
        var viewport = camera.cameras[0].viewport;
        renderTarget.setSize(viewport.z, viewport.w);
        renderTarget.setNumViews(camera.cameras.length);
      } else {
        renderTarget.setSize(renderSize.x, renderSize.y);
        renderTarget.setNumViews(DEFAULT_NUMVIEWS);
      }
    }

    function attachCamera(camera) {
      if (isMultiviewCompatible(camera) === false) return;
      currentRenderTarget = renderer.getRenderTarget();
      resizeRenderTarget(camera);
      renderer.setRenderTarget(renderTarget);
    }

    function detachCamera(camera) {
      if (renderTarget !== renderer.getRenderTarget()) return;
      renderer.setRenderTarget(currentRenderTarget);
      flush(camera);
    }

    function flush(camera) {
      var srcRenderTarget = renderTarget;
      var numViews = srcRenderTarget.numViews;

      var srcFramebuffers = properties.get(srcRenderTarget).__webglViewFramebuffers;

      var viewWidth = srcRenderTarget.width;
      var viewHeight = srcRenderTarget.height;

      if (camera.isArrayCamera) {
        for (var i = 0; i < numViews; i++) {
          var viewport = camera.cameras[i].viewport;
          var x1 = viewport.x;
          var y1 = viewport.y;
          var x2 = x1 + viewport.z;
          var y2 = y1 + viewport.w;
          gl.bindFramebuffer(36008, srcFramebuffers[i]);
          gl.blitFramebuffer(0, 0, viewWidth, viewHeight, x1, y1, x2, y2, 16384, 9728);
        }
      } else {
        gl.bindFramebuffer(36008, srcFramebuffers[0]);
        gl.blitFramebuffer(0, 0, viewWidth, viewHeight, 0, 0, renderSize.x, renderSize.y, 16384, 9728);
      }
    }

    this.isAvailable = isAvailable;
    this.attachCamera = attachCamera;
    this.detachCamera = detachCamera;
    this.updateCameraProjectionMatricesUniform = updateCameraProjectionMatricesUniform;
    this.updateCameraViewMatricesUniform = updateCameraViewMatricesUniform;
    this.updateObjectMatricesUniforms = updateObjectMatricesUniforms;
  }

  function ArrayCamera(array) {
    PerspectiveCamera.call(this);
    this.cameras = array || [];
  }

  ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
    constructor: ArrayCamera,
    isArrayCamera: true
  });

  function Group() {
    Object3D.call(this);
    this.type = 'Group';
  }

  Group.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Group,
    isGroup: true
  });

  function WebXRManager(renderer, gl) {
    var scope = this;
    var session = null;
    var referenceSpace = null;
    var referenceSpaceType = 'local-floor';
    var pose = null;
    var controllers = [];
    var inputSourcesMap = new Map();
    var cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    var cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    var cameraVR = new ArrayCamera([cameraL, cameraR]);
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    var _currentDepthNear = null;
    var _currentDepthFar = null;
    this.enabled = false;
    this.isPresenting = false;

    this.getController = function (id) {
      var controller = controllers[id];

      if (controller === undefined) {
        controller = {};
        controllers[id] = controller;
      }

      if (controller.targetRay === undefined) {
        controller.targetRay = new Group();
        controller.targetRay.matrixAutoUpdate = false;
        controller.targetRay.visible = false;
      }

      return controller.targetRay;
    };

    this.getControllerGrip = function (id) {
      var controller = controllers[id];

      if (controller === undefined) {
        controller = {};
        controllers[id] = controller;
      }

      if (controller.grip === undefined) {
        controller.grip = new Group();
        controller.grip.matrixAutoUpdate = false;
        controller.grip.visible = false;
      }

      return controller.grip;
    };

    function onSessionEvent(event) {
      var controller = inputSourcesMap.get(event.inputSource);

      if (controller) {
        if (controller.targetRay) {
          controller.targetRay.dispatchEvent({
            type: event.type
          });
        }

        if (controller.grip) {
          controller.grip.dispatchEvent({
            type: event.type
          });
        }
      }
    }

    function onSessionEnd() {
      inputSourcesMap.forEach(function (controller, inputSource) {
        if (controller.targetRay) {
          controller.targetRay.dispatchEvent({
            type: 'disconnected',
            data: inputSource
          });
          controller.targetRay.visible = false;
        }

        if (controller.grip) {
          controller.grip.dispatchEvent({
            type: 'disconnected',
            data: inputSource
          });
          controller.grip.visible = false;
        }
      });
      inputSourcesMap.clear();
      renderer.setFramebuffer(null);
      renderer.setRenderTarget(renderer.getRenderTarget());
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({
        type: 'sessionend'
      });
    }

    function onRequestReferenceSpace(value) {
      referenceSpace = value;
      animation.setContext(session);
      animation.start();
      scope.isPresenting = true;
      scope.dispatchEvent({
        type: 'sessionstart'
      });
    }

    this.setFramebufferScaleFactor = function () {};

    this.setReferenceSpaceType = function (value) {
      referenceSpaceType = value;
    };

    this.getReferenceSpace = function () {
      return referenceSpace;
    };

    this.getSession = function () {
      return session;
    };

    this.setSession = function (value) {
      session = value;

      if (session !== null) {
        session.addEventListener('select', onSessionEvent);
        session.addEventListener('selectstart', onSessionEvent);
        session.addEventListener('selectend', onSessionEvent);
        session.addEventListener('squeeze', onSessionEvent);
        session.addEventListener('squeezestart', onSessionEvent);
        session.addEventListener('squeezeend', onSessionEvent);
        session.addEventListener('end', onSessionEnd);
        var attributes = gl.getContextAttributes();
        var layerInit = {
          antialias: attributes.antialias,
          alpha: attributes.alpha,
          depth: attributes.depth,
          stencil: attributes.stencil
        };
        var baseLayer = new XRWebGLLayer(session, gl, layerInit);
        session.updateRenderState({
          baseLayer: baseLayer
        });
        session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);
        session.addEventListener('inputsourceschange', updateInputSources);
      }
    };

    function updateInputSources(event) {
      var inputSources = session.inputSources;

      for (var i = 0; i < controllers.length; i++) {
        inputSourcesMap.set(inputSources[i], controllers[i]);
      }

      for (var i = 0; i < event.removed.length; i++) {
        var inputSource = event.removed[i];
        var controller = inputSourcesMap.get(inputSource);

        if (controller) {
          if (controller.targetRay) {
            controller.targetRay.dispatchEvent({
              type: 'disconnected',
              data: inputSource
            });
          }

          if (controller.grip) {
            controller.grip.dispatchEvent({
              type: 'disconnected',
              data: inputSource
            });
          }

          inputSourcesMap["delete"](inputSource);
        }
      }

      for (var i = 0; i < event.added.length; i++) {
        var inputSource = event.added[i];
        var controller = inputSourcesMap.get(inputSource);

        if (controller) {
          if (controller.targetRay) {
            controller.targetRay.dispatchEvent({
              type: 'connected',
              data: inputSource
            });
          }

          if (controller.grip) {
            controller.grip.dispatchEvent({
              type: 'connected',
              data: inputSource
            });
          }
        }
      }
    }

    var cameraLPos = new Vector3();
    var cameraRPos = new Vector3();

    function setProjectionFromUnion(camera, cameraL, cameraR) {
      cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
      var ipd = cameraLPos.distanceTo(cameraRPos);
      var projL = cameraL.projectionMatrix.elements;
      var projR = cameraR.projectionMatrix.elements;
      var near = projL[14] / (projL[10] - 1);
      var far = projL[14] / (projL[10] + 1);
      var topFov = (projL[9] + 1) / projL[5];
      var bottomFov = (projL[9] - 1) / projL[5];
      var leftFov = (projL[8] - 1) / projL[0];
      var rightFov = (projR[8] + 1) / projR[0];
      var left = near * leftFov;
      var right = near * rightFov;
      var zOffset = ipd / (-leftFov + rightFov);
      var xOffset = zOffset * -leftFov;
      cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.getInverse(camera.matrixWorld);
      var near2 = near + zOffset;
      var far2 = far + zOffset;
      var left2 = left - xOffset;
      var right2 = right + (ipd - xOffset);
      var top2 = topFov * far / far2 * near2;
      var bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }

    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }

      camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    }

    this.getCamera = function (camera) {
      cameraVR.near = cameraR.near = cameraL.near = camera.near;
      cameraVR.far = cameraR.far = cameraL.far = camera.far;

      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }

      var parent = camera.parent;
      var cameras = cameraVR.cameras;
      updateCamera(cameraVR, parent);

      for (var i = 0; i < cameras.length; i++) {
        updateCamera(cameras[i], parent);
      }

      camera.matrixWorld.copy(cameraVR.matrixWorld);
      var children = camera.children;

      for (var i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(true);
      }

      setProjectionFromUnion(cameraVR, cameraL, cameraR);
      return cameraVR;
    };

    var onAnimationFrameCallback = null;

    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(referenceSpace);

      if (pose !== null) {
        var views = pose.views;
        var baseLayer = session.renderState.baseLayer;
        renderer.setFramebuffer(baseLayer.framebuffer);

        for (var i = 0; i < views.length; i++) {
          var view = views[i];
          var viewport = baseLayer.getViewport(view);
          var camera = cameraVR.cameras[i];
          camera.matrix.fromArray(view.transform.matrix);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

          if (i === 0) {
            cameraVR.matrix.copy(camera.matrix);
          }
        }
      }

      var inputSources = session.inputSources;

      for (var i = 0; i < controllers.length; i++) {
        var controller = controllers[i];
        var inputSource = inputSources[i];
        var inputPose = null;
        var gripPose = null;

        if (inputSource) {
          if (controller.targetRay) {
            inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

            if (inputPose !== null) {
              controller.targetRay.matrix.fromArray(inputPose.transform.matrix);
              controller.targetRay.matrix.decompose(controller.targetRay.position, controller.targetRay.rotation, controller.targetRay.scale);
            }
          }

          if (controller.grip && inputSource.gripSpace) {
            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

            if (gripPose !== null) {
              controller.grip.matrix.fromArray(gripPose.transform.matrix);
              controller.grip.matrix.decompose(controller.grip.position, controller.grip.rotation, controller.grip.scale);
            }
          }
        }

        if (controller.targetRay) {
          controller.targetRay.visible = inputPose !== null;
        }

        if (controller.grip) {
          controller.grip.visible = gripPose !== null;
        }
      }

      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
    }

    var animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);

    this.setAnimationLoop = function (callback) {
      onAnimationFrameCallback = callback;
    };

    this.dispose = function () {};
  }

  Object.assign(WebXRManager.prototype, EventDispatcher.prototype);

  function WebGLRenderer(parameters) {
    parameters = parameters || {};

    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
        _context = parameters.context !== undefined ? parameters.context : null,
        _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
        _depth = parameters.depth !== undefined ? parameters.depth : true,
        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
        _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
        _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

    var currentRenderList = null;
    var currentRenderState = null;
    this.domElement = _canvas;
    this.debug = {
      checkShaderErrors: true
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.gammaFactor = 2.0;
    this.outputEncoding = LinearEncoding;
    this.physicallyCorrectLights = false;
    this.toneMapping = LinearToneMapping;
    this.toneMappingExposure = 1.0;
    this.toneMappingWhitePoint = 1.0;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;

    var _this = this,
        _isContextLost = false,
        _framebuffer = null,
        _currentActiveCubeFace = 0,
        _currentActiveMipmapLevel = 0,
        _currentRenderTarget = null,
        _currentFramebuffer = null,
        _currentMaterialId = -1,
        _currentGeometryProgram = {
      geometry: null,
      program: null,
      wireframe: false
    },
        _currentCamera = null,
        _currentArrayCamera = null,
        _currentViewport = new Vector4(),
        _currentScissor = new Vector4(),
        _currentScissorTest = null,
        _width = _canvas.width,
        _height = _canvas.height,
        _pixelRatio = 1,
        _opaqueSort = null,
        _transparentSort = null,
        _viewport = new Vector4(0, 0, _width, _height),
        _scissor = new Vector4(0, 0, _width, _height),
        _scissorTest = false,
        _frustum = new Frustum(),
        _clipping = new WebGLClipping(),
        _clippingEnabled = false,
        _localClippingEnabled = false,
        _projScreenMatrix = new Matrix4(),
        _vector3 = new Vector3();

    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }

    var _gl;

    try {
      var contextAttributes = {
        alpha: _alpha,
        depth: _depth,
        stencil: _stencil,
        antialias: _antialias,
        premultipliedAlpha: _premultipliedAlpha,
        preserveDrawingBuffer: _preserveDrawingBuffer,
        powerPreference: _powerPreference,
        failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
        xrCompatible: true
      };

      _canvas.addEventListener('webglcontextlost', onContextLost, false);

      _canvas.addEventListener('webglcontextrestored', onContextRestore, false);

      _gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);

      if (_gl === null) {
        if (_canvas.getContext('webgl') !== null) {
          throw new Error('Error creating WebGL context with your selected attributes.');
        } else {
          throw new Error('Error creating WebGL context.');
        }
      }

      if (_gl.getShaderPrecisionFormat === undefined) {
        _gl.getShaderPrecisionFormat = function () {
          return {
            'rangeMin': 1,
            'rangeMax': 1,
            'precision': 1
          };
        };
      }
    } catch (error) {
      console.error('THREE.WebGLRenderer: ' + error.message);
      throw error;
    }

    var extensions, capabilities, state, info;
    var properties, textures, attributes, geometries, objects;
    var programCache, renderLists, renderStates;
    var background, morphtargets, bufferRenderer, indexedBufferRenderer;
    var utils;

    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters);

      if (capabilities.isWebGL2 === false) {
        extensions.get('WEBGL_depth_texture');
        extensions.get('OES_texture_float');
        extensions.get('OES_texture_half_float');
        extensions.get('OES_texture_half_float_linear');
        extensions.get('OES_standard_derivatives');
        extensions.get('OES_element_index_uint');
        extensions.get('ANGLE_instanced_arrays');
      }

      extensions.get('OES_texture_float_linear');
      utils = new WebGLUtils(_gl, extensions, capabilities);
      state = new WebGLState(_gl, extensions, capabilities);
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      attributes = new WebGLAttributes(_gl, capabilities);
      geometries = new WebGLGeometries(_gl, attributes, info);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl);
      programCache = new WebGLPrograms(_this, extensions, capabilities);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates();
      background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.state = state;
      _this.info = info;
    }

    initGLContext();
    var xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    var multiview = new WebGLMultiview(_this, _gl);
    var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
    this.shadowMap = shadowMap;

    this.getContext = function () {
      return _gl;
    };

    this.getContextAttributes = function () {
      return _gl.getContextAttributes();
    };

    this.forceContextLoss = function () {
      var extension = extensions.get('WEBGL_lose_context');
      if (extension) extension.loseContext();
    };

    this.forceContextRestore = function () {
      var extension = extensions.get('WEBGL_lose_context');
      if (extension) extension.restoreContext();
    };

    this.getPixelRatio = function () {
      return _pixelRatio;
    };

    this.setPixelRatio = function (value) {
      if (value === undefined) return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };

    this.getSize = function (target) {
      if (target === undefined) {
        console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
        target = new Vector2();
      }

      return target.set(_width, _height);
    };

    this.setSize = function (width, height, updateStyle) {
      if (xr.isPresenting) {
        console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
        return;
      }

      _width = width;
      _height = height;
      _canvas.width = Math.floor(width * _pixelRatio);
      _canvas.height = Math.floor(height * _pixelRatio);

      if (updateStyle !== false) {
        _canvas.style.width = width + 'px';
        _canvas.style.height = height + 'px';
      }

      this.setViewport(0, 0, width, height);
    };

    this.getDrawingBufferSize = function (target) {
      if (target === undefined) {
        console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
        target = new Vector2();
      }

      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };

    this.setDrawingBufferSize = function (width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      _canvas.width = Math.floor(width * pixelRatio);
      _canvas.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };

    this.getCurrentViewport = function (target) {
      if (target === undefined) {
        console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
        target = new Vector4();
      }

      return target.copy(_currentViewport);
    };

    this.getViewport = function (target) {
      return target.copy(_viewport);
    };

    this.setViewport = function (x, y, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width, height);
      }

      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };

    this.getScissor = function (target) {
      return target.copy(_scissor);
    };

    this.setScissor = function (x, y, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width, height);
      }

      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };

    this.getScissorTest = function () {
      return _scissorTest;
    };

    this.setScissorTest = function (_boolean) {
      state.setScissorTest(_scissorTest = _boolean);
    };

    this.setOpaqueSort = function (method) {
      _opaqueSort = method;
    };

    this.setTransparentSort = function (method) {
      _transparentSort = method;
    };

    this.getClearColor = function () {
      return background.getClearColor();
    };

    this.setClearColor = function () {
      background.setClearColor.apply(background, arguments);
    };

    this.getClearAlpha = function () {
      return background.getClearAlpha();
    };

    this.setClearAlpha = function () {
      background.setClearAlpha.apply(background, arguments);
    };

    this.clear = function (color, depth, stencil) {
      var bits = 0;
      if (color === undefined || color) bits |= 16384;
      if (depth === undefined || depth) bits |= 256;
      if (stencil === undefined || stencil) bits |= 1024;

      _gl.clear(bits);
    };

    this.clearColor = function () {
      this.clear(true, false, false);
    };

    this.clearDepth = function () {
      this.clear(false, true, false);
    };

    this.clearStencil = function () {
      this.clear(false, false, true);
    };

    this.dispose = function () {
      _canvas.removeEventListener('webglcontextlost', onContextLost, false);

      _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      objects.dispose();
      xr.dispose();
      animation.stop();
    };

    function onContextLost(event) {
      event.preventDefault();
      console.log('THREE.WebGLRenderer: Context Lost.');
      _isContextLost = true;
    }

    function onContextRestore() {
      console.log('THREE.WebGLRenderer: Context Restored.');
      _isContextLost = false;
      initGLContext();
    }

    function onMaterialDispose(event) {
      var material = event.target;
      material.removeEventListener('dispose', onMaterialDispose);
      deallocateMaterial(material);
    }

    function deallocateMaterial(material) {
      releaseMaterialProgramReference(material);
      properties.remove(material);
    }

    function releaseMaterialProgramReference(material) {
      var programInfo = properties.get(material).program;
      material.program = undefined;

      if (programInfo !== undefined) {
        programCache.releaseProgram(programInfo);
      }
    }

    function renderObjectImmediate(object, program) {
      object.render(function (object) {
        _this.renderBufferImmediate(object, program);
      });
    }

    this.renderBufferImmediate = function (object, program) {
      state.initAttributes();
      var buffers = properties.get(object);
      if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
      if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
      if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
      if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
      var programAttributes = program.getAttributes();

      if (object.hasPositions) {
        _gl.bindBuffer(34962, buffers.position);

        _gl.bufferData(34962, object.positionArray, 35048);

        state.enableAttribute(programAttributes.position);

        _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
      }

      if (object.hasNormals) {
        _gl.bindBuffer(34962, buffers.normal);

        _gl.bufferData(34962, object.normalArray, 35048);

        state.enableAttribute(programAttributes.normal);

        _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
      }

      if (object.hasUvs) {
        _gl.bindBuffer(34962, buffers.uv);

        _gl.bufferData(34962, object.uvArray, 35048);

        state.enableAttribute(programAttributes.uv);

        _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
      }

      if (object.hasColors) {
        _gl.bindBuffer(34962, buffers.color);

        _gl.bufferData(34962, object.colorArray, 35048);

        state.enableAttribute(programAttributes.color);

        _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
      }

      state.disableUnusedAttributes();

      _gl.drawArrays(4, 0, object.count);

      object.count = 0;
    };

    var tempScene = new Scene();

    this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
      if (scene === null) scene = tempScene;
      var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      var program = setProgram(camera, scene, material, object);
      state.setMaterial(material, frontFaceCW);
      var updateBuffers = false;

      if (_currentGeometryProgram.geometry !== geometry.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== (material.wireframe === true)) {
        _currentGeometryProgram.geometry = geometry.id;
        _currentGeometryProgram.program = program.id;
        _currentGeometryProgram.wireframe = material.wireframe === true;
        updateBuffers = true;
      }

      if (material.morphTargets || material.morphNormals) {
        morphtargets.update(object, geometry, material, program);
        updateBuffers = true;
      }

      var index = geometry.index;
      var position = geometry.attributes.position;

      if (index === null) {
        if (position === undefined || position.count === 0) return;
      } else if (index.count === 0) {
        return;
      }

      var rangeFactor = 1;

      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        rangeFactor = 2;
      }

      var attribute;
      var renderer = bufferRenderer;

      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }

      if (updateBuffers) {
        setupVertexAttributes(object, geometry, material, program);

        if (index !== null) {
          _gl.bindBuffer(34963, attribute.buffer);
        }
      }

      var dataCount = index !== null ? index.count : position.count;
      var rangeStart = geometry.drawRange.start * rangeFactor;
      var rangeCount = geometry.drawRange.count * rangeFactor;
      var groupStart = group !== null ? group.start * rangeFactor : 0;
      var groupCount = group !== null ? group.count * rangeFactor : Infinity;
      var drawStart = Math.max(rangeStart, groupStart);
      var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
      var drawCount = Math.max(0, drawEnd - drawStart + 1);
      if (drawCount === 0) return;

      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(1);
        } else {
          renderer.setMode(4);
        }
      } else if (object.isLine) {
        var lineWidth = material.linewidth;
        if (lineWidth === undefined) lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());

        if (object.isLineSegments) {
          renderer.setMode(1);
        } else if (object.isLineLoop) {
          renderer.setMode(2);
        } else {
          renderer.setMode(3);
        }
      } else if (object.isPoints) {
        renderer.setMode(0);
      } else if (object.isSprite) {
        renderer.setMode(4);
      }

      if (object.isInstancedMesh) {
        renderer.renderInstances(geometry, drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        renderer.renderInstances(geometry, drawStart, drawCount, geometry.maxInstancedCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };

    function setupVertexAttributes(object, geometry, material, program) {
      if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
        if (extensions.get('ANGLE_instanced_arrays') === null) return;
      }

      state.initAttributes();
      var geometryAttributes = geometry.attributes;
      var programAttributes = program.getAttributes();
      var materialDefaultAttributeValues = material.defaultAttributeValues;

      for (var name in programAttributes) {
        var programAttribute = programAttributes[name];

        if (programAttribute >= 0) {
          var geometryAttribute = geometryAttributes[name];

          if (geometryAttribute !== undefined) {
            var normalized = geometryAttribute.normalized;
            var size = geometryAttribute.itemSize;
            var attribute = attributes.get(geometryAttribute);
            if (attribute === undefined) continue;
            var buffer = attribute.buffer;
            var type = attribute.type;
            var bytesPerElement = attribute.bytesPerElement;

            if (geometryAttribute.isInterleavedBufferAttribute) {
              var data = geometryAttribute.data;
              var stride = data.stride;
              var offset = geometryAttribute.offset;

              if (data && data.isInstancedInterleavedBuffer) {
                state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

                if (geometry.maxInstancedCount === undefined) {
                  geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                }
              } else {
                state.enableAttribute(programAttribute);
              }

              _gl.bindBuffer(34962, buffer);

              _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
            } else {
              if (geometryAttribute.isInstancedBufferAttribute) {
                state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

                if (geometry.maxInstancedCount === undefined) {
                  geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                state.enableAttribute(programAttribute);
              }

              _gl.bindBuffer(34962, buffer);

              _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
            }
          } else if (name === 'instanceMatrix') {
            var attribute = attributes.get(object.instanceMatrix);
            if (attribute === undefined) continue;
            var buffer = attribute.buffer;
            var type = attribute.type;
            state.enableAttributeAndDivisor(programAttribute + 0, 1);
            state.enableAttributeAndDivisor(programAttribute + 1, 1);
            state.enableAttributeAndDivisor(programAttribute + 2, 1);
            state.enableAttributeAndDivisor(programAttribute + 3, 1);

            _gl.bindBuffer(34962, buffer);

            _gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);

            _gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);

            _gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);

            _gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
          } else if (materialDefaultAttributeValues !== undefined) {
            var value = materialDefaultAttributeValues[name];

            if (value !== undefined) {
              switch (value.length) {
                case 2:
                  _gl.vertexAttrib2fv(programAttribute, value);

                  break;

                case 3:
                  _gl.vertexAttrib3fv(programAttribute, value);

                  break;

                case 4:
                  _gl.vertexAttrib4fv(programAttribute, value);

                  break;

                default:
                  _gl.vertexAttrib1fv(programAttribute, value);

              }
            }
          }
        }
      }

      state.disableUnusedAttributes();
    }

    this.compile = function (scene, camera) {
      currentRenderState = renderStates.get(scene, camera);
      currentRenderState.init();
      scene.traverse(function (object) {
        if (object.isLight) {
          currentRenderState.pushLight(object);

          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      currentRenderState.setupLights(camera);
      var compiled = {};
      scene.traverse(function (object) {
        if (object.material) {
          if (Array.isArray(object.material)) {
            for (var i = 0; i < object.material.length; i++) {
              if (object.material[i].uuid in compiled === false) {
                initMaterial(object.material[i], scene, object);
                compiled[object.material[i].uuid] = true;
              }
            }
          } else if (object.material.uuid in compiled === false) {
            initMaterial(object.material, scene, object);
            compiled[object.material.uuid] = true;
          }
        }
      });
    };

    var onAnimationFrameCallback = null;

    function onAnimationFrame(time) {
      if (xr.isPresenting) return;
      if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }

    var animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== 'undefined') animation.setContext(window);

    this.setAnimationLoop = function (callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      animation.start();
    };

    this.render = function (scene, camera) {
      var renderTarget, forceClear;

      if (arguments[2] !== undefined) {
        console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
        renderTarget = arguments[2];
      }

      if (arguments[3] !== undefined) {
        console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
        forceClear = arguments[3];
      }

      if (!(camera && camera.isCamera)) {
        console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
        return;
      }

      if (_isContextLost) return;
      _currentGeometryProgram.geometry = null;
      _currentGeometryProgram.program = null;
      _currentGeometryProgram.wireframe = false;
      _currentMaterialId = -1;
      _currentCamera = null;
      if (scene.autoUpdate === true) scene.updateMatrixWorld();
      if (camera.parent === null) camera.updateMatrixWorld();

      if (xr.enabled && xr.isPresenting) {
        camera = xr.getCamera(camera);
      }

      currentRenderState = renderStates.get(scene, camera);
      currentRenderState.init();
      scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);

      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

      _frustum.setFromProjectionMatrix(_projScreenMatrix);

      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
      currentRenderList = renderLists.get(scene, camera);
      currentRenderList.init();
      projectObject(scene, camera, 0, _this.sortObjects);

      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }

      if (_clippingEnabled) _clipping.beginShadows();
      var shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      currentRenderState.setupLights(camera);
      if (_clippingEnabled) _clipping.endShadows();
      if (this.info.autoReset) this.info.reset();

      if (renderTarget !== undefined) {
        this.setRenderTarget(renderTarget);
      }

      if (xr.enabled && multiview.isAvailable()) {
        multiview.attachCamera(camera);
      }

      background.render(currentRenderList, scene, camera, forceClear);
      var opaqueObjects = currentRenderList.opaque;
      var transparentObjects = currentRenderList.transparent;

      if (scene.overrideMaterial) {
        var overrideMaterial = scene.overrideMaterial;
        if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
        if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial);
      } else {
        if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera);
        if (transparentObjects.length) renderObjects(transparentObjects, scene, camera);
      }

      scene.onAfterRender(_this, scene, camera);

      if (_currentRenderTarget !== null) {
        textures.updateRenderTargetMipmap(_currentRenderTarget);
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
      }

      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);

      if (xr.enabled) {
        if (multiview.isAvailable()) {
          multiview.detachCamera(camera);
        }
      }

      currentRenderList = null;
      currentRenderState = null;
    };

    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false) return;
      var visible = object.layers.test(camera.layers);

      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true) object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);

          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }

            var geometry = objects.update(object);
            var material = object.material;

            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        } else if (object.isImmediateRenderObject) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (object.isSkinnedMesh) {
            if (object.skeleton.frame !== info.render.frame) {
              object.skeleton.update();
              object.skeleton.frame = info.render.frame;
            }
          }

          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }

            var geometry = objects.update(object);
            var material = object.material;

            if (Array.isArray(material)) {
              var groups = geometry.groups;

              for (var i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                var groupMaterial = material[group.materialIndex];

                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        }
      }

      var children = object.children;

      for (var i = 0, l = children.length; i < l; i++) {
        projectObject(children[i], camera, groupOrder, sortObjects);
      }
    }

    function renderObjects(renderList, scene, camera, overrideMaterial) {
      for (var i = 0, l = renderList.length; i < l; i++) {
        var renderItem = renderList[i];
        var object = renderItem.object;
        var geometry = renderItem.geometry;
        var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
        var group = renderItem.group;

        if (camera.isArrayCamera) {
          _currentArrayCamera = camera;

          if (xr.enabled && multiview.isAvailable()) {
            renderObject(object, scene, camera, geometry, material, group);
          } else {
            var cameras = camera.cameras;

            for (var j = 0, jl = cameras.length; j < jl; j++) {
              var camera2 = cameras[j];

              if (object.layers.test(camera2.layers)) {
                state.viewport(_currentViewport.copy(camera2.viewport));
                currentRenderState.setupLights(camera2);
                renderObject(object, scene, camera2, geometry, material, group);
              }
            }
          }
        } else {
          _currentArrayCamera = null;
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }

    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

      if (object.isImmediateRenderObject) {
        var program = setProgram(camera, scene, material, object);
        state.setMaterial(material);
        _currentGeometryProgram.geometry = null;
        _currentGeometryProgram.program = null;
        _currentGeometryProgram.wireframe = false;
        renderObjectImmediate(object, program);
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }

      object.onAfterRender(_this, scene, camera, geometry, material, group);
      currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    }

    function initMaterial(material, scene, object) {
      var materialProperties = properties.get(material);
      var lights = currentRenderState.state.lights;
      var shadowsArray = currentRenderState.state.shadowsArray;
      var lightsStateVersion = lights.state.version;
      var parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object);
      var programCacheKey = programCache.getProgramCacheKey(parameters);
      var program = materialProperties.program;
      var programChange = true;

      if (program === undefined) {
        material.addEventListener('dispose', onMaterialDispose);
      } else if (program.cacheKey !== programCacheKey) {
        releaseMaterialProgramReference(material);
      } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
        materialProperties.lightsStateVersion = lightsStateVersion;
        programChange = false;
      } else if (parameters.shaderID !== undefined) {
        return;
      } else {
        programChange = false;
      }

      if (programChange) {
        program = programCache.acquireProgram(parameters, programCacheKey);
        materialProperties.program = program;
        materialProperties.uniforms = parameters.uniforms;
        materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
        materialProperties.outputEncoding = _this.outputEncoding;
        material.program = program;
      }

      var programAttributes = program.getAttributes();

      if (material.morphTargets) {
        material.numSupportedMorphTargets = 0;

        for (var i = 0; i < _this.maxMorphTargets; i++) {
          if (programAttributes['morphTarget' + i] >= 0) {
            material.numSupportedMorphTargets++;
          }
        }
      }

      if (material.morphNormals) {
        material.numSupportedMorphNormals = 0;

        for (var i = 0; i < _this.maxMorphNormals; i++) {
          if (programAttributes['morphNormal' + i] >= 0) {
            material.numSupportedMorphNormals++;
          }
        }
      }

      var uniforms = materialProperties.uniforms;

      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        materialProperties.numClippingPlanes = _clipping.numPlanes;
        materialProperties.numIntersection = _clipping.numIntersection;
        uniforms.clippingPlanes = _clipping.uniform;
      }

      materialProperties.fog = scene.fog;
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;

      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.pointLights.value = lights.state.point;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }

      var progUniforms = materialProperties.program.getUniforms(),
          uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
      materialProperties.uniformsList = uniformsList;
    }

    function setProgram(camera, scene, material, object) {
      textures.resetTextureUnits();
      var fog = scene.fog;
      var environment = material.isMeshStandardMaterial ? scene.environment : null;
      var materialProperties = properties.get(material);
      var lights = currentRenderState.state.lights;

      if (_clippingEnabled) {
        if (_localClippingEnabled || camera !== _currentCamera) {
          var useCache = camera === _currentCamera && material.id === _currentMaterialId;

          _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
        }
      }

      if (material.version === materialProperties.__version) {
        if (materialProperties.program === undefined) {
          initMaterial(material, scene, object);
        } else if (material.fog && materialProperties.fog !== fog) {
          initMaterial(material, scene, object);
        } else if (materialProperties.environment !== environment) {
          initMaterial(material, scene, object);
        } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          initMaterial(material, scene, object);
        } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
          initMaterial(material, scene, object);
        } else if (materialProperties.outputEncoding !== _this.outputEncoding) {
          initMaterial(material, scene, object);
        }
      } else {
        initMaterial(material, scene, object);
        materialProperties.__version = material.version;
      }

      var refreshProgram = false;
      var refreshMaterial = false;
      var refreshLights = false;
      var program = materialProperties.program,
          p_uniforms = program.getUniforms(),
          m_uniforms = materialProperties.uniforms;

      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }

      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }

      if (refreshProgram || _currentCamera !== camera) {
        if (program.numMultiviewViews > 0) {
          multiview.updateCameraProjectionMatricesUniform(camera, p_uniforms);
        } else {
          p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
        }

        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
        }

        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }

        if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
          var uCamPos = p_uniforms.map.cameraPosition;

          if (uCamPos !== undefined) {
            uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
          }
        }

        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
        }

        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
          if (program.numMultiviewViews > 0) {
            multiview.updateCameraViewMatricesUniform(camera, p_uniforms);
          } else {
            p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
          }
        }
      }

      if (material.skinning) {
        p_uniforms.setOptional(_gl, object, 'bindMatrix');
        p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
        var skeleton = object.skeleton;

        if (skeleton) {
          var bones = skeleton.bones;

          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === undefined) {
              var size = Math.sqrt(bones.length * 4);
              size = MathUtils.ceilPowerOfTwo(size);
              size = Math.max(size, 4);
              var boneMatrices = new Float32Array(size * size * 4);
              boneMatrices.set(skeleton.boneMatrices);
              var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
              skeleton.boneMatrices = boneMatrices;
              skeleton.boneTexture = boneTexture;
              skeleton.boneTextureSize = size;
            }

            p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
            p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
          } else {
            p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
          }
        }
      }

      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
      }

      if (refreshMaterial) {
        p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
        p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);

        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }

        if (fog && material.fog) {
          refreshUniformsFog(m_uniforms, fog);
        }

        if (material.isMeshBasicMaterial) {
          refreshUniformsCommon(m_uniforms, material);
        } else if (material.isMeshLambertMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          refreshUniformsLambert(m_uniforms, material);
        } else if (material.isMeshToonMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          refreshUniformsToon(m_uniforms, material);
        } else if (material.isMeshPhongMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          refreshUniformsPhong(m_uniforms, material);
        } else if (material.isMeshStandardMaterial) {
          refreshUniformsCommon(m_uniforms, material, environment);

          if (material.isMeshPhysicalMaterial) {
            refreshUniformsPhysical(m_uniforms, material, environment);
          } else {
            refreshUniformsStandard(m_uniforms, material, environment);
          }
        } else if (material.isMeshMatcapMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          refreshUniformsMatcap(m_uniforms, material);
        } else if (material.isMeshDepthMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          refreshUniformsDepth(m_uniforms, material);
        } else if (material.isMeshDistanceMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          refreshUniformsDistance(m_uniforms, material);
        } else if (material.isMeshNormalMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          refreshUniformsNormal(m_uniforms, material);
        } else if (material.isLineBasicMaterial) {
          refreshUniformsLine(m_uniforms, material);

          if (material.isLineDashedMaterial) {
            refreshUniformsDash(m_uniforms, material);
          }
        } else if (material.isPointsMaterial) {
          refreshUniformsPoints(m_uniforms, material);
        } else if (material.isSpriteMaterial) {
          refreshUniformsSprites(m_uniforms, material);
        } else if (material.isShadowMaterial) {
          m_uniforms.color.value.copy(material.color);
          m_uniforms.opacity.value = material.opacity;
        }

        if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
        if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);

        if (material.isShaderMaterial) {
          material.uniformsNeedUpdate = false;
        }
      }

      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }

      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, 'center', object.center);
      }

      if (program.numMultiviewViews > 0) {
        multiview.updateObjectMatricesUniforms(object, camera, p_uniforms);
      } else {
        p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
        p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
      }

      p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
      return program;
    }

    function refreshUniformsCommon(uniforms, material, environment) {
      uniforms.opacity.value = material.opacity;

      if (material.color) {
        uniforms.diffuse.value.copy(material.color);
      }

      if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      }

      if (material.map) {
        uniforms.map.value = material.map;
      }

      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }

      if (material.specularMap) {
        uniforms.specularMap.value = material.specularMap;
      }

      var envMap = material.envMap || environment;

      if (envMap) {
        uniforms.envMap.value = envMap;
        uniforms.flipEnvMap.value = envMap.isCubeTexture ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;
        uniforms.maxMipLevel.value = properties.get(envMap).__maxMipLevel;
      }

      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
      }

      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
      }

      var uvScaleMap;

      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.specularMap) {
        uvScaleMap = material.specularMap;
      } else if (material.displacementMap) {
        uvScaleMap = material.displacementMap;
      } else if (material.normalMap) {
        uvScaleMap = material.normalMap;
      } else if (material.bumpMap) {
        uvScaleMap = material.bumpMap;
      } else if (material.roughnessMap) {
        uvScaleMap = material.roughnessMap;
      } else if (material.metalnessMap) {
        uvScaleMap = material.metalnessMap;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      } else if (material.emissiveMap) {
        uvScaleMap = material.emissiveMap;
      }

      if (uvScaleMap !== undefined) {
        if (uvScaleMap.isWebGLRenderTarget) {
          uvScaleMap = uvScaleMap.texture;
        }

        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }

        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }

      var uv2ScaleMap;

      if (material.aoMap) {
        uv2ScaleMap = material.aoMap;
      } else if (material.lightMap) {
        uv2ScaleMap = material.lightMap;
      }

      if (uv2ScaleMap !== undefined) {
        if (uv2ScaleMap.isWebGLRenderTarget) {
          uv2ScaleMap = uv2ScaleMap.texture;
        }

        if (uv2ScaleMap.matrixAutoUpdate === true) {
          uv2ScaleMap.updateMatrix();
        }

        uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
      }
    }

    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    }

    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }

    function refreshUniformsPoints(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * _pixelRatio;
      uniforms.scale.value = _height * 0.5;

      if (material.map) {
        uniforms.map.value = material.map;
      }

      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }

      var uvScaleMap;

      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }

      if (uvScaleMap !== undefined) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }

        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }

    function refreshUniformsSprites(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.rotation.value = material.rotation;

      if (material.map) {
        uniforms.map.value = material.map;
      }

      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }

      var uvScaleMap;

      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }

      if (uvScaleMap !== undefined) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }

        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }

    function refreshUniformsFog(uniforms, fog) {
      uniforms.fogColor.value.copy(fog.color);

      if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }

    function refreshUniformsLambert(uniforms, material) {
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
    }

    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value.copy(material.specular);
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);

      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }

      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide) uniforms.bumpScale.value *= -1;
      }

      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide) uniforms.normalScale.value.negate();
      }

      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }

    function refreshUniformsToon(uniforms, material) {
      uniforms.specular.value.copy(material.specular);
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);

      if (material.gradientMap) {
        uniforms.gradientMap.value = material.gradientMap;
      }

      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }

      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide) uniforms.bumpScale.value *= -1;
      }

      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide) uniforms.normalScale.value.negate();
      }

      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }

    function refreshUniformsStandard(uniforms, material, environment) {
      uniforms.roughness.value = material.roughness;
      uniforms.metalness.value = material.metalness;

      if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
      }

      if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
      }

      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }

      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide) uniforms.bumpScale.value *= -1;
      }

      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide) uniforms.normalScale.value.negate();
      }

      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }

      if (material.envMap || environment) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
      }
    }

    function refreshUniformsPhysical(uniforms, material, environment) {
      refreshUniformsStandard(uniforms, material, environment);
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.sheen) uniforms.sheen.value.copy(material.sheen);

      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }

      uniforms.transparency.value = material.transparency;
    }

    function refreshUniformsMatcap(uniforms, material) {
      if (material.matcap) {
        uniforms.matcap.value = material.matcap;
      }

      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide) uniforms.bumpScale.value *= -1;
      }

      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide) uniforms.normalScale.value.negate();
      }

      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }

    function refreshUniformsDepth(uniforms, material) {
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }

    function refreshUniformsDistance(uniforms, material) {
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }

      uniforms.referencePosition.value.copy(material.referencePosition);
      uniforms.nearDistance.value = material.nearDistance;
      uniforms.farDistance.value = material.farDistance;
    }

    function refreshUniformsNormal(uniforms, material) {
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide) uniforms.bumpScale.value *= -1;
      }

      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide) uniforms.normalScale.value.negate();
      }

      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }

    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }

    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }

    this.setFramebuffer = function (value) {
      if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(36160, value);
      _framebuffer = value;
    };

    this.getActiveCubeFace = function () {
      return _currentActiveCubeFace;
    };

    this.getActiveMipmapLevel = function () {
      return _currentActiveMipmapLevel;
    };

    this.getRenderTarget = function () {
      return _currentRenderTarget;
    };

    this.setRenderTarget = function (renderTarget, activeCubeFace, activeMipmapLevel) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;

      if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
        textures.setupRenderTarget(renderTarget);
      }

      var framebuffer = _framebuffer;
      var isCube = false;

      if (renderTarget) {
        var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

        if (renderTarget.isWebGLCubeRenderTarget) {
          framebuffer = __webglFramebuffer[activeCubeFace || 0];
          isCube = true;
        } else if (renderTarget.isWebGLMultisampleRenderTarget) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          framebuffer = __webglFramebuffer;
        }

        _currentViewport.copy(renderTarget.viewport);

        _currentScissor.copy(renderTarget.scissor);

        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

        _currentScissorTest = _scissorTest;
      }

      if (_currentFramebuffer !== framebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);

        _currentFramebuffer = framebuffer;
      }

      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);

      if (isCube) {
        var textureProperties = properties.get(renderTarget.texture);

        _gl.framebufferTexture2D(36160, 36064, 34069 + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);
      }
    };

    this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
        return;
      }

      var framebuffer = properties.get(renderTarget).__webglFramebuffer;

      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }

      if (framebuffer) {
        var restore = false;

        if (framebuffer !== _currentFramebuffer) {
          _gl.bindFramebuffer(36160, framebuffer);

          restore = true;
        }

        try {
          var texture = renderTarget.texture;
          var textureFormat = texture.format;
          var textureType = texture.type;

          if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
            return;
          }

          if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
            return;
          }

          if (_gl.checkFramebufferStatus(36160) === 36053) {
            if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
              _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
            }
          } else {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
          }
        } finally {
          if (restore) {
            _gl.bindFramebuffer(36160, _currentFramebuffer);
          }
        }
      }
    };

    this.copyFramebufferToTexture = function (position, texture, level) {
      if (level === undefined) level = 0;
      var levelScale = Math.pow(2, -level);
      var width = Math.floor(texture.image.width * levelScale);
      var height = Math.floor(texture.image.height * levelScale);
      var glFormat = utils.convert(texture.format);
      textures.setTexture2D(texture, 0);

      _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);

      state.unbindTexture();
    };

    this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
      var width = srcTexture.image.width;
      var height = srcTexture.image.height;
      var glFormat = utils.convert(dstTexture.format);
      var glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);

      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
      } else {
        _gl.texSubImage2D(3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
      }

      state.unbindTexture();
    };

    this.initTexture = function (texture) {
      textures.setTexture2D(texture, 0);
      state.unbindTexture();
    };

    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
      }));
    }
  }

  function FogExp2(color, density) {
    this.name = '';
    this.color = new Color(color);
    this.density = density !== undefined ? density : 0.00025;
  }

  Object.assign(FogExp2.prototype, {
    isFogExp2: true,
    clone: function clone() {
      return new FogExp2(this.color, this.density);
    },
    toJSON: function toJSON() {
      return {
        type: 'FogExp2',
        color: this.color.getHex(),
        density: this.density
      };
    }
  });

  function Fog(color, near, far) {
    this.name = '';
    this.color = new Color(color);
    this.near = near !== undefined ? near : 1;
    this.far = far !== undefined ? far : 1000;
  }

  Object.assign(Fog.prototype, {
    isFog: true,
    clone: function clone() {
      return new Fog(this.color, this.near, this.far);
    },
    toJSON: function toJSON() {
      return {
        type: 'Fog',
        color: this.color.getHex(),
        near: this.near,
        far: this.far
      };
    }
  });

  function InterleavedBuffer(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== undefined ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = {
      offset: 0,
      count: -1
    };
    this.version = 0;
  }

  Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
    set: function set(value) {
      if (value === true) this.version++;
    }
  });
  Object.assign(InterleavedBuffer.prototype, {
    isInterleavedBuffer: true,
    onUploadCallback: function onUploadCallback() {},
    setUsage: function setUsage(value) {
      this.usage = value;
      return this;
    },
    copy: function copy(source) {
      this.array = new source.array.constructor(source.array);
      this.count = source.count;
      this.stride = source.stride;
      this.usage = source.usage;
      return this;
    },
    copyAt: function copyAt(index1, attribute, index2) {
      index1 *= this.stride;
      index2 *= attribute.stride;

      for (var i = 0, l = this.stride; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }

      return this;
    },
    set: function set(value, offset) {
      if (offset === undefined) offset = 0;
      this.array.set(value, offset);
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    onUpload: function onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
  });

  var _vector$6 = new Vector3();

  function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
  }

  Object.defineProperties(InterleavedBufferAttribute.prototype, {
    count: {
      get: function get() {
        return this.data.count;
      }
    },
    array: {
      get: function get() {
        return this.data.array;
      }
    }
  });
  Object.assign(InterleavedBufferAttribute.prototype, {
    isInterleavedBufferAttribute: true,
    applyMatrix4: function applyMatrix4(m) {
      for (var i = 0, l = this.data.count; i < l; i++) {
        _vector$6.x = this.getX(i);
        _vector$6.y = this.getY(i);
        _vector$6.z = this.getZ(i);

        _vector$6.applyMatrix4(m);

        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }

      return this;
    },
    setX: function setX(index, x) {
      this.data.array[index * this.data.stride + this.offset] = x;
      return this;
    },
    setY: function setY(index, y) {
      this.data.array[index * this.data.stride + this.offset + 1] = y;
      return this;
    },
    setZ: function setZ(index, z) {
      this.data.array[index * this.data.stride + this.offset + 2] = z;
      return this;
    },
    setW: function setW(index, w) {
      this.data.array[index * this.data.stride + this.offset + 3] = w;
      return this;
    },
    getX: function getX(index) {
      return this.data.array[index * this.data.stride + this.offset];
    },
    getY: function getY(index) {
      return this.data.array[index * this.data.stride + this.offset + 1];
    },
    getZ: function getZ(index) {
      return this.data.array[index * this.data.stride + this.offset + 2];
    },
    getW: function getW(index) {
      return this.data.array[index * this.data.stride + this.offset + 3];
    },
    setXY: function setXY(index, x, y) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      return this;
    },
    setXYZ: function setXYZ(index, x, y, z) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      return this;
    },
    setXYZW: function setXYZW(index, x, y, z, w) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      this.data.array[index + 3] = w;
      return this;
    }
  });

  function SpriteMaterial(parameters) {
    Material.call(this);
    this.type = 'SpriteMaterial';
    this.color = new Color(0xffffff);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }

  SpriteMaterial.prototype = Object.create(Material.prototype);
  SpriteMaterial.prototype.constructor = SpriteMaterial;
  SpriteMaterial.prototype.isSpriteMaterial = true;

  SpriteMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  };

  var _geometry;

  var _intersectPoint = new Vector3();

  var _worldScale = new Vector3();

  var _mvPosition = new Vector3();

  var _alignedPosition = new Vector2();

  var _rotatedPosition = new Vector2();

  var _viewWorldMatrix = new Matrix4();

  var _vA$1 = new Vector3();

  var _vB$1 = new Vector3();

  var _vC$1 = new Vector3();

  var _uvA$1 = new Vector2();

  var _uvB$1 = new Vector2();

  var _uvC$1 = new Vector2();

  function Sprite(material) {
    Object3D.call(this);
    this.type = 'Sprite';

    if (_geometry === undefined) {
      _geometry = new BufferGeometry();
      var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
      var interleavedBuffer = new InterleavedBuffer(float32Array, 5);

      _geometry.setIndex([0, 1, 2, 0, 2, 3]);

      _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

      _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }

    this.geometry = _geometry;
    this.material = material !== undefined ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }

  Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Sprite,
    isSprite: true,
    raycast: function raycast(raycaster, intersects) {
      if (raycaster.camera === null) {
        console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
      }

      _worldScale.setFromMatrixScale(this.matrixWorld);

      _viewWorldMatrix.copy(raycaster.camera.matrixWorld);

      this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

      _mvPosition.setFromMatrixPosition(this.modelViewMatrix);

      if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
        _worldScale.multiplyScalar(-_mvPosition.z);
      }

      var rotation = this.material.rotation;
      var sin, cos;

      if (rotation !== 0) {
        cos = Math.cos(rotation);
        sin = Math.sin(rotation);
      }

      var center = this.center;
      transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

      _uvA$1.set(0, 0);

      _uvB$1.set(1, 0);

      _uvC$1.set(1, 1);

      var intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);

      if (intersect === null) {
        transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

        _uvB$1.set(0, 1);

        intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);

        if (intersect === null) {
          return;
        }
      }

      var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far) return;
      intersects.push({
        distance: distance,
        point: _intersectPoint.clone(),
        uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
        face: null,
        object: this
      });
    },
    clone: function clone() {
      return new this.constructor(this.material).copy(this);
    },
    copy: function copy(source) {
      Object3D.prototype.copy.call(this, source);
      if (source.center !== undefined) this.center.copy(source.center);
      return this;
    }
  });

  function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);

    if (sin !== undefined) {
      _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
      _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else {
      _rotatedPosition.copy(_alignedPosition);
    }

    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;
    vertexPosition.applyMatrix4(_viewWorldMatrix);
  }

  var _v1$4 = new Vector3();

  var _v2$2 = new Vector3();

  function LOD() {
    Object3D.call(this);
    this.type = 'LOD';
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      }
    });
    this.autoUpdate = true;
  }

  LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: LOD,
    isLOD: true,
    copy: function copy(source) {
      Object3D.prototype.copy.call(this, source, false);
      var levels = source.levels;

      for (var i = 0, l = levels.length; i < l; i++) {
        var level = levels[i];
        this.addLevel(level.object.clone(), level.distance);
      }

      this.autoUpdate = source.autoUpdate;
      return this;
    },
    addLevel: function addLevel(object, distance) {
      if (distance === undefined) distance = 0;
      distance = Math.abs(distance);
      var levels = this.levels;

      for (var l = 0; l < levels.length; l++) {
        if (distance < levels[l].distance) {
          break;
        }
      }

      levels.splice(l, 0, {
        distance: distance,
        object: object
      });
      this.add(object);
      return this;
    },
    getObjectForDistance: function getObjectForDistance(distance) {
      var levels = this.levels;

      if (levels.length > 0) {
        for (var i = 1, l = levels.length; i < l; i++) {
          if (distance < levels[i].distance) {
            break;
          }
        }

        return levels[i - 1].object;
      }

      return null;
    },
    raycast: function raycast(raycaster, intersects) {
      var levels = this.levels;

      if (levels.length > 0) {
        _v1$4.setFromMatrixPosition(this.matrixWorld);

        var distance = raycaster.ray.origin.distanceTo(_v1$4);
        this.getObjectForDistance(distance).raycast(raycaster, intersects);
      }
    },
    update: function update(camera) {
      var levels = this.levels;

      if (levels.length > 1) {
        _v1$4.setFromMatrixPosition(camera.matrixWorld);

        _v2$2.setFromMatrixPosition(this.matrixWorld);

        var distance = _v1$4.distanceTo(_v2$2);

        levels[0].object.visible = true;

        for (var i = 1, l = levels.length; i < l; i++) {
          if (distance >= levels[i].distance) {
            levels[i - 1].object.visible = false;
            levels[i].object.visible = true;
          } else {
            break;
          }
        }

        for (; i < l; i++) {
          levels[i].object.visible = false;
        }
      }
    },
    toJSON: function toJSON(meta) {
      var data = Object3D.prototype.toJSON.call(this, meta);
      if (this.autoUpdate === false) data.object.autoUpdate = false;
      data.object.levels = [];
      var levels = this.levels;

      for (var i = 0, l = levels.length; i < l; i++) {
        var level = levels[i];
        data.object.levels.push({
          object: level.object.uuid,
          distance: level.distance
        });
      }

      return data;
    }
  });

  function SkinnedMesh(geometry, material) {
    if (geometry && geometry.isGeometry) {
      console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }

    Mesh.call(this, geometry, material);
    this.type = 'SkinnedMesh';
    this.bindMode = 'attached';
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
  }

  SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: SkinnedMesh,
    isSkinnedMesh: true,
    bind: function bind(skeleton, bindMatrix) {
      this.skeleton = skeleton;

      if (bindMatrix === undefined) {
        this.updateMatrixWorld(true);
        this.skeleton.calculateInverses();
        bindMatrix = this.matrixWorld;
      }

      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.getInverse(bindMatrix);
    },
    pose: function pose() {
      this.skeleton.pose();
    },
    normalizeSkinWeights: function normalizeSkinWeights() {
      var vector = new Vector4();
      var skinWeight = this.geometry.attributes.skinWeight;

      for (var i = 0, l = skinWeight.count; i < l; i++) {
        vector.x = skinWeight.getX(i);
        vector.y = skinWeight.getY(i);
        vector.z = skinWeight.getZ(i);
        vector.w = skinWeight.getW(i);
        var scale = 1.0 / vector.manhattanLength();

        if (scale !== Infinity) {
          vector.multiplyScalar(scale);
        } else {
          vector.set(1, 0, 0, 0);
        }

        skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
      }
    },
    updateMatrixWorld: function updateMatrixWorld(force) {
      Mesh.prototype.updateMatrixWorld.call(this, force);

      if (this.bindMode === 'attached') {
        this.bindMatrixInverse.getInverse(this.matrixWorld);
      } else if (this.bindMode === 'detached') {
        this.bindMatrixInverse.getInverse(this.bindMatrix);
      } else {
        console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
      }
    },
    clone: function clone() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  });

  var _offsetMatrix = new Matrix4();

  var _identityMatrix = new Matrix4();

  function Skeleton(bones, boneInverses) {
    bones = bones || [];
    this.bones = bones.slice(0);
    this.boneMatrices = new Float32Array(this.bones.length * 16);
    this.frame = -1;

    if (boneInverses === undefined) {
      this.calculateInverses();
    } else {
      if (this.bones.length === boneInverses.length) {
        this.boneInverses = boneInverses.slice(0);
      } else {
        console.warn('THREE.Skeleton boneInverses is the wrong length.');
        this.boneInverses = [];

        for (var i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }

  Object.assign(Skeleton.prototype, {
    calculateInverses: function calculateInverses() {
      this.boneInverses = [];

      for (var i = 0, il = this.bones.length; i < il; i++) {
        var inverse = new Matrix4();

        if (this.bones[i]) {
          inverse.getInverse(this.bones[i].matrixWorld);
        }

        this.boneInverses.push(inverse);
      }
    },
    pose: function pose() {
      var bone, i, il;

      for (i = 0, il = this.bones.length; i < il; i++) {
        bone = this.bones[i];

        if (bone) {
          bone.matrixWorld.getInverse(this.boneInverses[i]);
        }
      }

      for (i = 0, il = this.bones.length; i < il; i++) {
        bone = this.bones[i];

        if (bone) {
          if (bone.parent && bone.parent.isBone) {
            bone.matrix.getInverse(bone.parent.matrixWorld);
            bone.matrix.multiply(bone.matrixWorld);
          } else {
            bone.matrix.copy(bone.matrixWorld);
          }

          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        }
      }
    },
    update: function update() {
      var bones = this.bones;
      var boneInverses = this.boneInverses;
      var boneMatrices = this.boneMatrices;
      var boneTexture = this.boneTexture;

      for (var i = 0, il = bones.length; i < il; i++) {
        var matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

        _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);

        _offsetMatrix.toArray(boneMatrices, i * 16);
      }

      if (boneTexture !== undefined) {
        boneTexture.needsUpdate = true;
      }
    },
    clone: function clone() {
      return new Skeleton(this.bones, this.boneInverses);
    },
    getBoneByName: function getBoneByName(name) {
      for (var i = 0, il = this.bones.length; i < il; i++) {
        var bone = this.bones[i];

        if (bone.name === name) {
          return bone;
        }
      }

      return undefined;
    }
  });

  function Bone() {
    Object3D.call(this);
    this.type = 'Bone';
  }

  Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Bone,
    isBone: true
  });

  var _instanceLocalMatrix = new Matrix4();

  var _instanceWorldMatrix = new Matrix4();

  var _instanceIntersects = [];

  var _mesh = new Mesh();

  function InstancedMesh(geometry, material, count) {
    Mesh.call(this, geometry, material);
    this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
    this.count = count;
    this.frustumCulled = false;
  }

  InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: InstancedMesh,
    isInstancedMesh: true,
    getMatrixAt: function getMatrixAt(index, matrix) {
      matrix.fromArray(this.instanceMatrix.array, index * 16);
    },
    raycast: function raycast(raycaster, intersects) {
      var matrixWorld = this.matrixWorld;
      var raycastTimes = this.count;
      _mesh.geometry = this.geometry;
      _mesh.material = this.material;
      if (_mesh.material === undefined) return;

      for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {
        this.getMatrixAt(instanceId, _instanceLocalMatrix);

        _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);

        _mesh.matrixWorld = _instanceWorldMatrix;

        _mesh.raycast(raycaster, _instanceIntersects);

        if (_instanceIntersects.length > 0) {
          _instanceIntersects[0].instanceId = instanceId;
          _instanceIntersects[0].object = this;
          intersects.push(_instanceIntersects[0]);
          _instanceIntersects.length = 0;
        }
      }
    },
    setMatrixAt: function setMatrixAt(index, matrix) {
      matrix.toArray(this.instanceMatrix.array, index * 16);
    },
    updateMorphTargets: function updateMorphTargets() {}
  });

  function LineBasicMaterial(parameters) {
    Material.call(this);
    this.type = 'LineBasicMaterial';
    this.color = new Color(0xffffff);
    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';
    this.setValues(parameters);
  }

  LineBasicMaterial.prototype = Object.create(Material.prototype);
  LineBasicMaterial.prototype.constructor = LineBasicMaterial;
  LineBasicMaterial.prototype.isLineBasicMaterial = true;

  LineBasicMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    return this;
  };

  var _start = new Vector3();

  var _end = new Vector3();

  var _inverseMatrix$1 = new Matrix4();

  var _ray$1 = new Ray();

  var _sphere$2 = new Sphere();

  function Line(geometry, material, mode) {
    if (mode === 1) {
      console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');
    }

    Object3D.call(this);
    this.type = 'Line';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new LineBasicMaterial();
  }

  Line.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Line,
    isLine: true,
    computeLineDistances: function computeLineDistances() {
      var geometry = this.geometry;

      if (geometry.isBufferGeometry) {
        if (geometry.index === null) {
          var positionAttribute = geometry.attributes.position;
          var lineDistances = [0];

          for (var i = 1, l = positionAttribute.count; i < l; i++) {
            _start.fromBufferAttribute(positionAttribute, i - 1);

            _end.fromBufferAttribute(positionAttribute, i);

            lineDistances[i] = lineDistances[i - 1];
            lineDistances[i] += _start.distanceTo(_end);
          }

          geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        }
      } else if (geometry.isGeometry) {
        var vertices = geometry.vertices;
        var lineDistances = geometry.lineDistances;
        lineDistances[0] = 0;

        for (var i = 1, l = vertices.length; i < l; i++) {
          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
        }
      }

      return this;
    },
    raycast: function raycast(raycaster, intersects) {
      var precision = raycaster.linePrecision;
      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

      _sphere$2.copy(geometry.boundingSphere);

      _sphere$2.applyMatrix4(matrixWorld);

      _sphere$2.radius += precision;
      if (raycaster.ray.intersectsSphere(_sphere$2) === false) return;

      _inverseMatrix$1.getInverse(matrixWorld);

      _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

      var localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localPrecisionSq = localPrecision * localPrecision;
      var vStart = new Vector3();
      var vEnd = new Vector3();
      var interSegment = new Vector3();
      var interRay = new Vector3();
      var step = this && this.isLineSegments ? 2 : 1;

      if (geometry.isBufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;

        if (index !== null) {
          var indices = index.array;

          for (var i = 0, l = indices.length - 1; i < l; i += step) {
            var a = indices[i];
            var b = indices[i + 1];
            vStart.fromArray(positions, a * 3);
            vEnd.fromArray(positions, b * 3);

            var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

            if (distSq > localPrecisionSq) continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far) continue;
            intersects.push({
              distance: distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        } else {
          for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
            vStart.fromArray(positions, 3 * i);
            vEnd.fromArray(positions, 3 * i + 3);

            var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

            if (distSq > localPrecisionSq) continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far) continue;
            intersects.push({
              distance: distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      } else if (geometry.isGeometry) {
        var vertices = geometry.vertices;
        var nbVertices = vertices.length;

        for (var i = 0; i < nbVertices - 1; i += step) {
          var distSq = _ray$1.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);

          if (distSq > localPrecisionSq) continue;
          interRay.applyMatrix4(this.matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    },
    clone: function clone() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  });

  var _start$1 = new Vector3();

  var _end$1 = new Vector3();

  function LineSegments(geometry, material) {
    Line.call(this, geometry, material);
    this.type = 'LineSegments';
  }

  LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineSegments,
    isLineSegments: true,
    computeLineDistances: function computeLineDistances() {
      var geometry = this.geometry;

      if (geometry.isBufferGeometry) {
        if (geometry.index === null) {
          var positionAttribute = geometry.attributes.position;
          var lineDistances = [];

          for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
            _start$1.fromBufferAttribute(positionAttribute, i);

            _end$1.fromBufferAttribute(positionAttribute, i + 1);

            lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
            lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
          }

          geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        }
      } else if (geometry.isGeometry) {
        var vertices = geometry.vertices;
        var lineDistances = geometry.lineDistances;

        for (var i = 0, l = vertices.length; i < l; i += 2) {
          _start$1.copy(vertices[i]);

          _end$1.copy(vertices[i + 1]);

          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
        }
      }

      return this;
    }
  });

  function LineLoop(geometry, material) {
    Line.call(this, geometry, material);
    this.type = 'LineLoop';
  }

  LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineLoop,
    isLineLoop: true
  });

  function PointsMaterial(parameters) {
    Material.call(this);
    this.type = 'PointsMaterial';
    this.color = new Color(0xffffff);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
  }

  PointsMaterial.prototype = Object.create(Material.prototype);
  PointsMaterial.prototype.constructor = PointsMaterial;
  PointsMaterial.prototype.isPointsMaterial = true;

  PointsMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
  };

  var _inverseMatrix$2 = new Matrix4();

  var _ray$2 = new Ray();

  var _sphere$3 = new Sphere();

  var _position$1 = new Vector3();

  function Points(geometry, material) {
    Object3D.call(this);
    this.type = 'Points';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new PointsMaterial();
    this.updateMorphTargets();
  }

  Points.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Points,
    isPoints: true,
    raycast: function raycast(raycaster, intersects) {
      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld;
      var threshold = raycaster.params.Points.threshold;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

      _sphere$3.copy(geometry.boundingSphere);

      _sphere$3.applyMatrix4(matrixWorld);

      _sphere$3.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;

      _inverseMatrix$2.getInverse(matrixWorld);

      _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);

      var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localThresholdSq = localThreshold * localThreshold;

      if (geometry.isBufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;

        if (index !== null) {
          var indices = index.array;

          for (var i = 0, il = indices.length; i < il; i++) {
            var a = indices[i];

            _position$1.fromArray(positions, a * 3);

            testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
          }
        } else {
          for (var i = 0, l = positions.length / 3; i < l; i++) {
            _position$1.fromArray(positions, i * 3);

            testPoint(_position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
          }
        }
      } else {
        var vertices = geometry.vertices;

        for (var i = 0, l = vertices.length; i < l; i++) {
          testPoint(vertices[i], i, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      }
    },
    updateMorphTargets: function updateMorphTargets() {
      var geometry = this.geometry;
      var m, ml, name;

      if (geometry.isBufferGeometry) {
        var morphAttributes = geometry.morphAttributes;
        var keys = Object.keys(morphAttributes);

        if (keys.length > 0) {
          var morphAttribute = morphAttributes[keys[0]];

          if (morphAttribute !== undefined) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};

            for (m = 0, ml = morphAttribute.length; m < ml; m++) {
              name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        var morphTargets = geometry.morphTargets;

        if (morphTargets !== undefined && morphTargets.length > 0) {
          console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
      }
    },
    clone: function clone() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  });

  function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
    var rayPointDistanceSq = _ray$2.distanceSqToPoint(point);

    if (rayPointDistanceSq < localThresholdSq) {
      var intersectPoint = new Vector3();

      _ray$2.closestPointToPoint(point, intersectPoint);

      intersectPoint.applyMatrix4(matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far) return;
      intersects.push({
        distance: distance,
        distanceToRay: Math.sqrt(rayPointDistanceSq),
        point: intersectPoint,
        index: index,
        face: null,
        object: object
      });
    }
  }

  function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== undefined ? format : RGBFormat;
    this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.generateMipmaps = false;
  }

  VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
    constructor: VideoTexture,
    isVideoTexture: true,
    update: function update() {
      var video = this.image;

      if (video.readyState >= video.HAVE_CURRENT_DATA) {
        this.needsUpdate = true;
      }
    }
  });

  function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
      width: width,
      height: height
    };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }

  CompressedTexture.prototype = Object.create(Texture.prototype);
  CompressedTexture.prototype.constructor = CompressedTexture;
  CompressedTexture.prototype.isCompressedTexture = true;

  function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }

  CanvasTexture.prototype = Object.create(Texture.prototype);
  CanvasTexture.prototype.constructor = CanvasTexture;
  CanvasTexture.prototype.isCanvasTexture = true;

  function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== undefined ? format : DepthFormat;

    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
    }

    if (type === undefined && format === DepthFormat) type = UnsignedShortType;
    if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {
      width: width,
      height: height
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }

  DepthTexture.prototype = Object.create(Texture.prototype);
  DepthTexture.prototype.constructor = DepthTexture;
  DepthTexture.prototype.isDepthTexture = true;

  function WireframeGeometry(geometry) {
    BufferGeometry.call(this);
    this.type = 'WireframeGeometry';
    var vertices = [];
    var i, j, l, o, ol;
    var edge = [0, 0],
        edges = {},
        e,
        edge1,
        edge2;
    var key,
        keys = ['a', 'b', 'c'];
    var vertex;

    if (geometry && geometry.isGeometry) {
      var faces = geometry.faces;

      for (i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];

        for (j = 0; j < 3; j++) {
          edge1 = face[keys[j]];
          edge2 = face[keys[(j + 1) % 3]];
          edge[0] = Math.min(edge1, edge2);
          edge[1] = Math.max(edge1, edge2);
          key = edge[0] + ',' + edge[1];

          if (edges[key] === undefined) {
            edges[key] = {
              index1: edge[0],
              index2: edge[1]
            };
          }
        }
      }

      for (key in edges) {
        e = edges[key];
        vertex = geometry.vertices[e.index1];
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex = geometry.vertices[e.index2];
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else if (geometry && geometry.isBufferGeometry) {
      var position, indices, groups;
      var group, start, count;
      var index1, index2;
      vertex = new Vector3();

      if (geometry.index !== null) {
        position = geometry.attributes.position;
        indices = geometry.index;
        groups = geometry.groups;

        if (groups.length === 0) {
          groups = [{
            start: 0,
            count: indices.count,
            materialIndex: 0
          }];
        }

        for (o = 0, ol = groups.length; o < ol; ++o) {
          group = groups[o];
          start = group.start;
          count = group.count;

          for (i = start, l = start + count; i < l; i += 3) {
            for (j = 0; j < 3; j++) {
              edge1 = indices.getX(i + j);
              edge2 = indices.getX(i + (j + 1) % 3);
              edge[0] = Math.min(edge1, edge2);
              edge[1] = Math.max(edge1, edge2);
              key = edge[0] + ',' + edge[1];

              if (edges[key] === undefined) {
                edges[key] = {
                  index1: edge[0],
                  index2: edge[1]
                };
              }
            }
          }
        }

        for (key in edges) {
          e = edges[key];
          vertex.fromBufferAttribute(position, e.index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          vertex.fromBufferAttribute(position, e.index2);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      } else {
        position = geometry.attributes.position;

        for (i = 0, l = position.count / 3; i < l; i++) {
          for (j = 0; j < 3; j++) {
            index1 = 3 * i + j;
            vertex.fromBufferAttribute(position, index1);
            vertices.push(vertex.x, vertex.y, vertex.z);
            index2 = 3 * i + (j + 1) % 3;
            vertex.fromBufferAttribute(position, index2);
            vertices.push(vertex.x, vertex.y, vertex.z);
          }
        }
      }
    }

    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  }

  WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
  WireframeGeometry.prototype.constructor = WireframeGeometry;

  function ParametricGeometry(func, slices, stacks) {
    Geometry.call(this);
    this.type = 'ParametricGeometry';
    this.parameters = {
      func: func,
      slices: slices,
      stacks: stacks
    };
    this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
    this.mergeVertices();
  }

  ParametricGeometry.prototype = Object.create(Geometry.prototype);
  ParametricGeometry.prototype.constructor = ParametricGeometry;

  function ParametricBufferGeometry(func, slices, stacks) {
    BufferGeometry.call(this);
    this.type = 'ParametricBufferGeometry';
    this.parameters = {
      func: func,
      slices: slices,
      stacks: stacks
    };
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var EPS = 0.00001;
    var normal = new Vector3();
    var p0 = new Vector3(),
        p1 = new Vector3();
    var pu = new Vector3(),
        pv = new Vector3();
    var i, j;

    if (func.length < 3) {
      console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
    }

    var sliceCount = slices + 1;

    for (i = 0; i <= stacks; i++) {
      var v = i / stacks;

      for (j = 0; j <= slices; j++) {
        var u = j / slices;
        func(u, v, p0);
        vertices.push(p0.x, p0.y, p0.z);

        if (u - EPS >= 0) {
          func(u - EPS, v, p1);
          pu.subVectors(p0, p1);
        } else {
          func(u + EPS, v, p1);
          pu.subVectors(p1, p0);
        }

        if (v - EPS >= 0) {
          func(u, v - EPS, p1);
          pv.subVectors(p0, p1);
        } else {
          func(u, v + EPS, p1);
          pv.subVectors(p1, p0);
        }

        normal.crossVectors(pu, pv).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u, v);
      }
    }

    for (i = 0; i < stacks; i++) {
      for (j = 0; j < slices; j++) {
        var a = i * sliceCount + j;
        var b = i * sliceCount + j + 1;
        var c = (i + 1) * sliceCount + j + 1;
        var d = (i + 1) * sliceCount + j;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

  ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

  function PolyhedronGeometry(vertices, indices, radius, detail) {
    Geometry.call(this);
    this.type = 'PolyhedronGeometry';
    this.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    };
    this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
    this.mergeVertices();
  }

  PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
  PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

  function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
    BufferGeometry.call(this);
    this.type = 'PolyhedronBufferGeometry';
    this.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    };
    radius = radius || 1;
    detail = detail || 0;
    var vertexBuffer = [];
    var uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }

    function subdivide(detail) {
      var a = new Vector3();
      var b = new Vector3();
      var c = new Vector3();

      for (var i = 0; i < indices.length; i += 3) {
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c);
        subdivideFace(a, b, c, detail);
      }
    }

    function subdivideFace(a, b, c, detail) {
      var cols = Math.pow(2, detail);
      var v = [];
      var i, j;

      for (i = 0; i <= cols; i++) {
        v[i] = [];
        var aj = a.clone().lerp(c, i / cols);
        var bj = b.clone().lerp(c, i / cols);
        var rows = cols - i;

        for (j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }

      for (i = 0; i < cols; i++) {
        for (j = 0; j < 2 * (cols - i) - 1; j++) {
          var k = Math.floor(j / 2);

          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }

    function applyRadius(radius) {
      var vertex = new Vector3();

      for (var i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        vertex.normalize().multiplyScalar(radius);
        vertexBuffer[i + 0] = vertex.x;
        vertexBuffer[i + 1] = vertex.y;
        vertexBuffer[i + 2] = vertex.z;
      }
    }

    function generateUVs() {
      var vertex = new Vector3();

      for (var i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        var u = azimuth(vertex) / 2 / Math.PI + 0.5;
        var v = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }

      correctUVs();
      correctSeam();
    }

    function correctSeam() {
      for (var i = 0; i < uvBuffer.length; i += 6) {
        var x0 = uvBuffer[i + 0];
        var x1 = uvBuffer[i + 2];
        var x2 = uvBuffer[i + 4];
        var max = Math.max(x0, x1, x2);
        var min = Math.min(x0, x1, x2);

        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i + 0] += 1;
          if (x1 < 0.2) uvBuffer[i + 2] += 1;
          if (x2 < 0.2) uvBuffer[i + 4] += 1;
        }
      }
    }

    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }

    function getVertexByIndex(index, vertex) {
      var stride = index * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }

    function correctUVs() {
      var a = new Vector3();
      var b = new Vector3();
      var c = new Vector3();
      var centroid = new Vector3();
      var uvA = new Vector2();
      var uvB = new Vector2();
      var uvC = new Vector2();

      for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        var azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }

    function correctUV(uv, stride, vector, azimuth) {
      if (azimuth < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }

      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
      }
    }

    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }

    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }

  PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

  function TetrahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = 'TetrahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
    this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
    this.mergeVertices();
  }

  TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
  TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

  function TetrahedronBufferGeometry(radius, detail) {
    var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
    var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'TetrahedronBufferGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

  TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
  TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

  function OctahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = 'OctahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
    this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
    this.mergeVertices();
  }

  OctahedronGeometry.prototype = Object.create(Geometry.prototype);
  OctahedronGeometry.prototype.constructor = OctahedronGeometry;

  function OctahedronBufferGeometry(radius, detail) {
    var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
    var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'OctahedronBufferGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

  OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
  OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

  function IcosahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = 'IcosahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
    this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
    this.mergeVertices();
  }

  IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
  IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

  function IcosahedronBufferGeometry(radius, detail) {
    var t = (1 + Math.sqrt(5)) / 2;
    var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
    var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'IcosahedronBufferGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

  IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
  IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

  function DodecahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = 'DodecahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
    this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
    this.mergeVertices();
  }

  DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
  DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

  function DodecahedronBufferGeometry(radius, detail) {
    var t = (1 + Math.sqrt(5)) / 2;
    var r = 1 / t;
    var vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
    var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'DodecahedronBufferGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

  DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
  DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

  function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
    Geometry.call(this);
    this.type = 'TubeGeometry';
    this.parameters = {
      path: path,
      tubularSegments: tubularSegments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed
    };
    if (taper !== undefined) console.warn('THREE.TubeGeometry: taper has been removed.');
    var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
    this.tangents = bufferGeometry.tangents;
    this.normals = bufferGeometry.normals;
    this.binormals = bufferGeometry.binormals;
    this.fromBufferGeometry(bufferGeometry);
    this.mergeVertices();
  }

  TubeGeometry.prototype = Object.create(Geometry.prototype);
  TubeGeometry.prototype.constructor = TubeGeometry;

  function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
    BufferGeometry.call(this);
    this.type = 'TubeBufferGeometry';
    this.parameters = {
      path: path,
      tubularSegments: tubularSegments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed
    };
    tubularSegments = tubularSegments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    var frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    var vertex = new Vector3();
    var normal = new Vector3();
    var uv = new Vector2();
    var P = new Vector3();
    var i, j;
    var vertices = [];
    var normals = [];
    var uvs = [];
    var indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    function generateBufferData() {
      for (i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      }

      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }

    function generateSegment(i) {
      P = path.getPointAt(i / tubularSegments, P);
      var N = frames.normals[i];
      var B = frames.binormals[i];

      for (j = 0; j <= radialSegments; j++) {
        var v = j / radialSegments * Math.PI * 2;
        var sin = Math.sin(v);
        var cos = -Math.cos(v);
        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex.x = P.x + radius * normal.x;
        vertex.y = P.y + radius * normal.y;
        vertex.z = P.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }

    function generateIndices() {
      for (j = 1; j <= tubularSegments; j++) {
        for (i = 1; i <= radialSegments; i++) {
          var a = (radialSegments + 1) * (j - 1) + (i - 1);
          var b = (radialSegments + 1) * j + (i - 1);
          var c = (radialSegments + 1) * j + i;
          var d = (radialSegments + 1) * (j - 1) + i;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }

    function generateUVs() {
      for (i = 0; i <= tubularSegments; i++) {
        for (j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }

  TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

  TubeBufferGeometry.prototype.toJSON = function () {
    var data = BufferGeometry.prototype.toJSON.call(this);
    data.path = this.parameters.path.toJSON();
    return data;
  };

  function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
    Geometry.call(this);
    this.type = 'TorusKnotGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      tubularSegments: tubularSegments,
      radialSegments: radialSegments,
      p: p,
      q: q
    };
    if (heightScale !== undefined) console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
    this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
    this.mergeVertices();
  }

  TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
  TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

  function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
    BufferGeometry.call(this);
    this.type = 'TorusKnotBufferGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      tubularSegments: tubularSegments,
      radialSegments: radialSegments,
      p: p,
      q: q
    };
    radius = radius || 1;
    tube = tube || 0.4;
    tubularSegments = Math.floor(tubularSegments) || 64;
    radialSegments = Math.floor(radialSegments) || 8;
    p = p || 2;
    q = q || 3;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var i, j;
    var vertex = new Vector3();
    var normal = new Vector3();
    var P1 = new Vector3();
    var P2 = new Vector3();
    var B = new Vector3();
    var T = new Vector3();
    var N = new Vector3();

    for (i = 0; i <= tubularSegments; ++i) {
      var u = i / tubularSegments * p * Math.PI * 2;
      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T);
      B.normalize();
      N.normalize();

      for (j = 0; j <= radialSegments; ++j) {
        var v = j / radialSegments * Math.PI * 2;
        var cx = -tube * Math.cos(v);
        var cy = tube * Math.sin(v);
        vertex.x = P1.x + (cx * N.x + cy * B.x);
        vertex.y = P1.y + (cx * N.y + cy * B.y);
        vertex.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.subVectors(vertex, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }

    for (j = 1; j <= tubularSegments; j++) {
      for (i = 1; i <= radialSegments; i++) {
        var a = (radialSegments + 1) * (j - 1) + (i - 1);
        var b = (radialSegments + 1) * j + (i - 1);
        var c = (radialSegments + 1) * j + i;
        var d = (radialSegments + 1) * (j - 1) + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    function calculatePositionOnCurve(u, p, q, radius, position) {
      var cu = Math.cos(u);
      var su = Math.sin(u);
      var quOverP = q / p * u;
      var cs = Math.cos(quOverP);
      position.x = radius * (2 + cs) * 0.5 * cu;
      position.y = radius * (2 + cs) * su * 0.5;
      position.z = radius * Math.sin(quOverP) * 0.5;
    }
  }

  TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

  function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
    Geometry.call(this);
    this.type = 'TorusGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };
    this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
    this.mergeVertices();
  }

  TorusGeometry.prototype = Object.create(Geometry.prototype);
  TorusGeometry.prototype.constructor = TorusGeometry;

  function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
    BufferGeometry.call(this);
    this.type = 'TorusBufferGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };
    radius = radius || 1;
    tube = tube || 0.4;
    radialSegments = Math.floor(radialSegments) || 8;
    tubularSegments = Math.floor(tubularSegments) || 6;
    arc = arc || Math.PI * 2;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var center = new Vector3();
    var vertex = new Vector3();
    var normal = new Vector3();
    var j, i;

    for (j = 0; j <= radialSegments; j++) {
      for (i = 0; i <= tubularSegments; i++) {
        var u = i / tubularSegments * arc;
        var v = j / radialSegments * Math.PI * 2;
        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z);
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }

    for (j = 1; j <= radialSegments; j++) {
      for (i = 1; i <= tubularSegments; i++) {
        var a = (tubularSegments + 1) * j + i - 1;
        var b = (tubularSegments + 1) * (j - 1) + i - 1;
        var c = (tubularSegments + 1) * (j - 1) + i;
        var d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

  TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
  var Earcut = {
    triangulate: function triangulate(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length,
          outerLen = hasHoles ? holeIndices[0] * dim : data.length,
          outerNode = linkedList(data, 0, outerLen, dim, true),
          triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev) return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }

        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
      }

      earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
      return triangles;
    }
  };

  function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i = start; i < end; i += dim) {
        last = insertNode(i, data[i], data[i + 1], last);
      }
    } else {
      for (i = end - dim; i >= start; i -= dim) {
        last = insertNode(i, data[i], data[i + 1], last);
      }
    }

    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }

    return last;
  }

  function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start,
        again;

    do {
      again = false;

      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next) break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);

    return end;
  }

  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    var stop = ear,
        prev,
        next;

    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;

      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }

      ear = next;

      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(ear, triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }

        break;
      }
    }
  }

  function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;
    if (area(a, b, c) >= 0) return false;
    var p = ear.next.next;

    while (p !== ear.prev) {
      if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.next;
    }

    return true;
  }

  function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;
    if (area(a, b, c) >= 0) return false;
    var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
        minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
        maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
        maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    var p = ear.prevZ,
        n = ear.nextZ;

    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }

    while (p && p.z >= minZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
    }

    while (n && n.z <= maxZ) {
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }

    return true;
  }

  function cureLocalIntersections(start, triangles, dim) {
    var p = start;

    do {
      var a = p.prev,
          b = p.next.next;

      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim);
        triangles.push(p.i / dim);
        triangles.push(b.i / dim);
        removeNode(p);
        removeNode(p.next);
        p = start = b;
      }

      p = p.next;
    } while (p !== start);

    return p;
  }

  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    var a = start;

    do {
      var b = a.next.next;

      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          var c = splitPolygon(a, b);
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);
          earcutLinked(a, triangles, dim, minX, minY, invSize);
          earcutLinked(c, triangles, dim, minX, minY, invSize);
          return;
        }

        b = b.next;
      }

      a = a.next;
    } while (a !== start);
  }

  function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i,
        len,
        start,
        end,
        list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next) list.steiner = true;
      queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    for (i = 0; i < queue.length; i++) {
      eliminateHole(queue[i], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
  }

  function compareX(a, b) {
    return a.x - b.x;
  }

  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);

    if (outerNode) {
      var b = splitPolygon(outerNode, hole);
      filterPoints(b, b.next);
    }
  }

  function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

        if (x <= hx && x > qx) {
          qx = x;

          if (x === hx) {
            if (hy === p.y) return p;
            if (hy === p.next.y) return p.next;
          }

          m = p.x < p.next.x ? p : p.next;
        }
      }

      p = p.next;
    } while (p !== outerNode);

    if (!m) return null;
    if (hx === qx) return m.prev;
    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;
    p = m.next;

    while (p !== stop) {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x);

        if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
          m = p;
          tanMin = tan;
        }
      }

      p = p.next;
    }

    return m;
  }

  function indexCurve(start, minX, minY, invSize) {
    var p = start;

    do {
      if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }

  function sortLinked(list) {
    var i,
        p,
        q,
        e,
        tail,
        numMerges,
        pSize,
        qSize,
        inSize = 1;

    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;

      while (p) {
        numMerges++;
        q = p;
        pSize = 0;

        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q) break;
        }

        qSize = inSize;

        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }

          if (tail) tail.nextZ = e;else list = e;
          e.prevZ = tail;
          tail = e;
        }

        p = q;
      }

      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);

    return list;
  }

  function zOrder(x, y, minX, minY, invSize) {
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
  }

  function getLeftmost(start) {
    var p = start,
        leftmost = start;

    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
      p = p.next;
    } while (p !== start);

    return leftmost;
  }

  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
  }

  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
  }

  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }

  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }

  function intersects(p1, q1, p2, q2) {
    if (equals(p1, p2) && equals(q1, q2) || equals(p1, q2) && equals(p2, q1)) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
  }

  function intersectsPolygon(a, b) {
    var p = a;

    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
      p = p.next;
    } while (p !== a);

    return false;
  }

  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }

  function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;

    do {
      if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
      p = p.next;
    } while (p !== a);

    return inside;
  }

  function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }

  function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }

    return p;
  }

  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
  }

  function Node(i, x, y) {
    this.i = i;
    this.x = x;
    this.y = y;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }

  function signedArea(data, start, end, dim) {
    var sum = 0;

    for (var i = start, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }

    return sum;
  }

  var ShapeUtils = {
    area: function area(contour) {
      var n = contour.length;
      var a = 0.0;

      for (var p = n - 1, q = 0; q < n; p = q++) {
        a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
      }

      return a * 0.5;
    },
    isClockWise: function isClockWise(pts) {
      return ShapeUtils.area(pts) < 0;
    },
    triangulateShape: function triangulateShape(contour, holes) {
      var vertices = [];
      var holeIndices = [];
      var faces = [];
      removeDupEndPts(contour);
      addContour(vertices, contour);
      var holeIndex = contour.length;
      holes.forEach(removeDupEndPts);

      for (var i = 0; i < holes.length; i++) {
        holeIndices.push(holeIndex);
        holeIndex += holes[i].length;
        addContour(vertices, holes[i]);
      }

      var triangles = Earcut.triangulate(vertices, holeIndices);

      for (var i = 0; i < triangles.length; i += 3) {
        faces.push(triangles.slice(i, i + 3));
      }

      return faces;
    }
  };

  function removeDupEndPts(points) {
    var l = points.length;

    if (l > 2 && points[l - 1].equals(points[0])) {
      points.pop();
    }
  }

  function addContour(vertices, contour) {
    for (var i = 0; i < contour.length; i++) {
      vertices.push(contour[i].x);
      vertices.push(contour[i].y);
    }
  }

  function ExtrudeGeometry(shapes, options) {
    Geometry.call(this);
    this.type = 'ExtrudeGeometry';
    this.parameters = {
      shapes: shapes,
      options: options
    };
    this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
    this.mergeVertices();
  }

  ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
  ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

  ExtrudeGeometry.prototype.toJSON = function () {
    var data = Geometry.prototype.toJSON.call(this);
    var shapes = this.parameters.shapes;
    var options = this.parameters.options;
    return toJSON(shapes, options, data);
  };

  function ExtrudeBufferGeometry(shapes, options) {
    BufferGeometry.call(this);
    this.type = 'ExtrudeBufferGeometry';
    this.parameters = {
      shapes: shapes,
      options: options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    var scope = this;
    var verticesArray = [];
    var uvArray = [];

    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      addShape(shape);
    }

    this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();

    function addShape(shape) {
      var placeholder = [];
      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      var steps = options.steps !== undefined ? options.steps : 1;
      var depth = options.depth !== undefined ? options.depth : 100;
      var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
      var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
      var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
      var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      var extrudePath = options.extrudePath;
      var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

      if (options.amount !== undefined) {
        console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
        depth = options.amount;
      }

      var extrudePts,
          extrudeByPath = false;
      var splineTube, binormal, normal, position2;

      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }

      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }

      var ahole, h, hl;
      var shapePoints = shape.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !ShapeUtils.isClockWise(vertices);

      if (reverse) {
        vertices = vertices.reverse();

        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];

          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }

      var faces = ShapeUtils.triangulateShape(vertices, holes);
      var contour = vertices;

      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        vertices = vertices.concat(ahole);
      }

      function scalePt2(pt, vec, size) {
        if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
      }

      var b,
          bs,
          t,
          z,
          vert,
          vlen = vertices.length,
          face,
          flen = faces.length;

      function getBevelVec(inPt, inPrev, inNext) {
        var v_trans_x, v_trans_y, shrink_by;
        var v_prev_x = inPt.x - inPrev.x,
            v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x,
            v_next_y = inNext.y - inPt.y;
        var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

        if (Math.abs(collinear0) > Number.EPSILON) {
          var v_prev_len = Math.sqrt(v_prev_lensq);
          var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          var ptNextShift_x = inNext.x - v_next_y / v_next_len;
          var ptNextShift_y = inNext.y + v_next_x / v_next_len;
          var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          var direction_eq = false;

          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }

          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }

        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }

      var contourMovements = [];

      for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }

      var holesMovements = [],
          oneHoleMovements,
          verticesMovements = contourMovements.concat();

      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = [];

        for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il) j = 0;
          if (k === il) k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }

        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }

      for (b = 0; b < bevelSegments; b++) {
        t = b / bevelSegments;
        z = bevelThickness * Math.cos(t * Math.PI / 2);
        bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

        for (i = 0, il = contour.length; i < il; i++) {
          vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, -z);
        }

        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          oneHoleMovements = holesMovements[h];

          for (i = 0, il = ahole.length; i < il; i++) {
            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            v(vert.x, vert.y, -z);
          }
        }
      }

      bs = bevelSize + bevelOffset;

      for (i = 0; i < vlen; i++) {
        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }

      var s;

      for (s = 1; s <= steps; s++) {
        for (i = 0; i < vlen; i++) {
          vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s);
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }

      for (b = bevelSegments - 1; b >= 0; b--) {
        t = b / bevelSegments;
        z = bevelThickness * Math.cos(t * Math.PI / 2);
        bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

        for (i = 0, il = contour.length; i < il; i++) {
          vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, depth + z);
        }

        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          oneHoleMovements = holesMovements[h];

          for (i = 0, il = ahole.length; i < il; i++) {
            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }

      buildLidFaces();
      buildSideFaces();

      function buildLidFaces() {
        var start = verticesArray.length / 3;

        if (bevelEnabled) {
          var layer = 0;
          var offset = vlen * layer;

          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }

          layer = steps + bevelSegments * 2;
          offset = vlen * layer;

          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[2], face[1], face[0]);
          }

          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }

      function buildSideFaces() {
        var start = verticesArray.length / 3;
        var layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;

        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }

      function sidewalls(contour, layeroffset) {
        var j, k;
        i = contour.length;

        while (--i >= 0) {
          j = i;
          k = i - 1;
          if (k < 0) k = contour.length - 1;
          var s = 0,
              sl = steps + bevelSegments * 2;

          for (s = 0; s < sl; s++) {
            var slen1 = vlen * s;
            var slen2 = vlen * (s + 1);
            var a = layeroffset + j + slen1,
                b = layeroffset + k + slen1,
                c = layeroffset + k + slen2,
                d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }

      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }

      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        var nextIndex = verticesArray.length / 3;
        var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }

      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        var nextIndex = verticesArray.length / 3;
        var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }

      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }

      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }

  ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

  ExtrudeBufferGeometry.prototype.toJSON = function () {
    var data = BufferGeometry.prototype.toJSON.call(this);
    var shapes = this.parameters.shapes;
    var options = this.parameters.options;
    return toJSON(shapes, options, data);
  };

  var WorldUVGenerator = {
    generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {
      var a_x = vertices[indexA * 3];
      var a_y = vertices[indexA * 3 + 1];
      var b_x = vertices[indexB * 3];
      var b_y = vertices[indexB * 3 + 1];
      var c_x = vertices[indexC * 3];
      var c_y = vertices[indexC * 3 + 1];
      return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
    },
    generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {
      var a_x = vertices[indexA * 3];
      var a_y = vertices[indexA * 3 + 1];
      var a_z = vertices[indexA * 3 + 2];
      var b_x = vertices[indexB * 3];
      var b_y = vertices[indexB * 3 + 1];
      var b_z = vertices[indexB * 3 + 2];
      var c_x = vertices[indexC * 3];
      var c_y = vertices[indexC * 3 + 1];
      var c_z = vertices[indexC * 3 + 2];
      var d_x = vertices[indexD * 3];
      var d_y = vertices[indexD * 3 + 1];
      var d_z = vertices[indexD * 3 + 2];

      if (Math.abs(a_y - b_y) < 0.01) {
        return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
      } else {
        return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
      }
    }
  };

  function toJSON(shapes, options, data) {
    data.shapes = [];

    if (Array.isArray(shapes)) {
      for (var i = 0, l = shapes.length; i < l; i++) {
        var shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }

    if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
    return data;
  }

  function TextGeometry(text, parameters) {
    Geometry.call(this);
    this.type = 'TextGeometry';
    this.parameters = {
      text: text,
      parameters: parameters
    };
    this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
    this.mergeVertices();
  }

  TextGeometry.prototype = Object.create(Geometry.prototype);
  TextGeometry.prototype.constructor = TextGeometry;

  function TextBufferGeometry(text, parameters) {
    parameters = parameters || {};
    var font = parameters.font;

    if (!(font && font.isFont)) {
      console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
      return new Geometry();
    }

    var shapes = font.generateShapes(text, parameters.size);
    parameters.depth = parameters.height !== undefined ? parameters.height : 50;
    if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
    if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
    if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
    ExtrudeBufferGeometry.call(this, shapes, parameters);
    this.type = 'TextBufferGeometry';
  }

  TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
  TextBufferGeometry.prototype.constructor = TextBufferGeometry;

  function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = 'SphereGeometry';
    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
    this.mergeVertices();
  }

  SphereGeometry.prototype = Object.create(Geometry.prototype);
  SphereGeometry.prototype.constructor = SphereGeometry;

  function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = 'SphereBufferGeometry';
    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    radius = radius || 1;
    widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
    heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
    var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    var ix, iy;
    var index = 0;
    var grid = [];
    var vertex = new Vector3();
    var normal = new Vector3();
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    for (iy = 0; iy <= heightSegments; iy++) {
      var verticesRow = [];
      var v = iy / heightSegments;
      var uOffset = 0;

      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }

      for (ix = 0; ix <= widthSegments; ix++) {
        var u = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }

      grid.push(verticesRow);
    }

    for (iy = 0; iy < heightSegments; iy++) {
      for (ix = 0; ix < widthSegments; ix++) {
        var a = grid[iy][ix + 1];
        var b = grid[iy][ix];
        var c = grid[iy + 1][ix];
        var d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    }

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

  SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

  function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = 'RingGeometry';
    this.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
    this.mergeVertices();
  }

  RingGeometry.prototype = Object.create(Geometry.prototype);
  RingGeometry.prototype.constructor = RingGeometry;

  function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = 'RingBufferGeometry';
    this.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    innerRadius = innerRadius || 0.5;
    outerRadius = outerRadius || 1;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
    phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var segment;
    var radius = innerRadius;
    var radiusStep = (outerRadius - innerRadius) / phiSegments;
    var vertex = new Vector3();
    var uv = new Vector2();
    var j, i;

    for (j = 0; j <= phiSegments; j++) {
      for (i = 0; i <= thetaSegments; i++) {
        segment = thetaStart + i / thetaSegments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, 0, 1);
        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }

      radius += radiusStep;
    }

    for (j = 0; j < phiSegments; j++) {
      var thetaSegmentLevel = j * (thetaSegments + 1);

      for (i = 0; i < thetaSegments; i++) {
        segment = i + thetaSegmentLevel;
        var a = segment;
        var b = segment + thetaSegments + 1;
        var c = segment + thetaSegments + 2;
        var d = segment + 1;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

  RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  RingBufferGeometry.prototype.constructor = RingBufferGeometry;

  function LatheGeometry(points, segments, phiStart, phiLength) {
    Geometry.call(this);
    this.type = 'LatheGeometry';
    this.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };
    this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
    this.mergeVertices();
  }

  LatheGeometry.prototype = Object.create(Geometry.prototype);
  LatheGeometry.prototype.constructor = LatheGeometry;

  function LatheBufferGeometry(points, segments, phiStart, phiLength) {
    BufferGeometry.call(this);
    this.type = 'LatheBufferGeometry';
    this.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };
    segments = Math.floor(segments) || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || Math.PI * 2;
    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);
    var indices = [];
    var vertices = [];
    var uvs = [];
    var base;
    var inverseSegments = 1.0 / segments;
    var vertex = new Vector3();
    var uv = new Vector2();
    var i, j;

    for (i = 0; i <= segments; i++) {
      var phi = phiStart + i * inverseSegments * phiLength;
      var sin = Math.sin(phi);
      var cos = Math.cos(phi);

      for (j = 0; j <= points.length - 1; j++) {
        vertex.x = points[j].x * sin;
        vertex.y = points[j].y;
        vertex.z = points[j].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z);
        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
      }
    }

    for (i = 0; i < segments; i++) {
      for (j = 0; j < points.length - 1; j++) {
        base = j + i * points.length;
        var a = base;
        var b = base + points.length;
        var c = base + points.length + 1;
        var d = base + 1;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    this.computeVertexNormals();

    if (phiLength === Math.PI * 2) {
      var normals = this.attributes.normal.array;
      var n1 = new Vector3();
      var n2 = new Vector3();
      var n = new Vector3();
      base = segments * points.length * 3;

      for (i = 0, j = 0; i < points.length; i++, j += 3) {
        n1.x = normals[j + 0];
        n1.y = normals[j + 1];
        n1.z = normals[j + 2];
        n2.x = normals[base + j + 0];
        n2.y = normals[base + j + 1];
        n2.z = normals[base + j + 2];
        n.addVectors(n1, n2).normalize();
        normals[j + 0] = normals[base + j + 0] = n.x;
        normals[j + 1] = normals[base + j + 1] = n.y;
        normals[j + 2] = normals[base + j + 2] = n.z;
      }
    }
  }

  LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

  function ShapeGeometry(shapes, curveSegments) {
    Geometry.call(this);
    this.type = 'ShapeGeometry';

    if (_typeof(curveSegments) === 'object') {
      console.warn('THREE.ShapeGeometry: Options parameter has been removed.');
      curveSegments = curveSegments.curveSegments;
    }

    this.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    };
    this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
    this.mergeVertices();
  }

  ShapeGeometry.prototype = Object.create(Geometry.prototype);
  ShapeGeometry.prototype.constructor = ShapeGeometry;

  ShapeGeometry.prototype.toJSON = function () {
    var data = Geometry.prototype.toJSON.call(this);
    var shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
  };

  function ShapeBufferGeometry(shapes, curveSegments) {
    BufferGeometry.call(this);
    this.type = 'ShapeBufferGeometry';
    this.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    };
    curveSegments = curveSegments || 12;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var groupStart = 0;
    var groupCount = 0;

    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (var i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i);
        groupStart += groupCount;
        groupCount = 0;
      }
    }

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    function addShape(shape) {
      var i, l, shapeHole;
      var indexOffset = vertices.length / 3;
      var points = shape.extractPoints(curveSegments);
      var shapeVertices = points.shape;
      var shapeHoles = points.holes;

      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }

      for (i = 0, l = shapeHoles.length; i < l; i++) {
        shapeHole = shapeHoles[i];

        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }

      var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);

      for (i = 0, l = shapeHoles.length; i < l; i++) {
        shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      }

      for (i = 0, l = shapeVertices.length; i < l; i++) {
        var vertex = shapeVertices[i];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y);
      }

      for (i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];
        var a = face[0] + indexOffset;
        var b = face[1] + indexOffset;
        var c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }

  ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

  ShapeBufferGeometry.prototype.toJSON = function () {
    var data = BufferGeometry.prototype.toJSON.call(this);
    var shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
  };

  function toJSON$1(shapes, data) {
    data.shapes = [];

    if (Array.isArray(shapes)) {
      for (var i = 0, l = shapes.length; i < l; i++) {
        var shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }

    return data;
  }

  function EdgesGeometry(geometry, thresholdAngle) {
    BufferGeometry.call(this);
    this.type = 'EdgesGeometry';
    this.parameters = {
      thresholdAngle: thresholdAngle
    };
    thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
    var vertices = [];
    var thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
    var edge = [0, 0],
        edges = {},
        edge1,
        edge2;
    var key,
        keys = ['a', 'b', 'c'];
    var geometry2;

    if (geometry.isBufferGeometry) {
      geometry2 = new Geometry();
      geometry2.fromBufferGeometry(geometry);
    } else {
      geometry2 = geometry.clone();
    }

    geometry2.mergeVertices();
    geometry2.computeFaceNormals();
    var sourceVertices = geometry2.vertices;
    var faces = geometry2.faces;

    for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];

      for (var j = 0; j < 3; j++) {
        edge1 = face[keys[j]];
        edge2 = face[keys[(j + 1) % 3]];
        edge[0] = Math.min(edge1, edge2);
        edge[1] = Math.max(edge1, edge2);
        key = edge[0] + ',' + edge[1];

        if (edges[key] === undefined) {
          edges[key] = {
            index1: edge[0],
            index2: edge[1],
            face1: i,
            face2: undefined
          };
        } else {
          edges[key].face2 = i;
        }
      }
    }

    for (key in edges) {
      var e = edges[key];

      if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
        var vertex = sourceVertices[e.index1];
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex = sourceVertices[e.index2];
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }

    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  }

  EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
  EdgesGeometry.prototype.constructor = EdgesGeometry;

  function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = 'CylinderGeometry';
    this.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
    this.mergeVertices();
  }

  CylinderGeometry.prototype = Object.create(Geometry.prototype);
  CylinderGeometry.prototype.constructor = CylinderGeometry;

  function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = 'CylinderBufferGeometry';
    this.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    var scope = this;
    radiusTop = radiusTop !== undefined ? radiusTop : 1;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
    height = height || 1;
    radialSegments = Math.floor(radialSegments) || 8;
    heightSegments = Math.floor(heightSegments) || 1;
    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var index = 0;
    var indexArray = [];
    var halfHeight = height / 2;
    var groupStart = 0;
    generateTorso();

    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    }

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    function generateTorso() {
      var x, y;
      var normal = new Vector3();
      var vertex = new Vector3();
      var groupCount = 0;
      var slope = (radiusBottom - radiusTop) / height;

      for (y = 0; y <= heightSegments; y++) {
        var indexRow = [];
        var v = y / heightSegments;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;

        for (x = 0; x <= radialSegments; x++) {
          var u = x / radialSegments;
          var theta = u * thetaLength + thetaStart;
          var sinTheta = Math.sin(theta);
          var cosTheta = Math.cos(theta);
          vertex.x = radius * sinTheta;
          vertex.y = -v * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, 1 - v);
          indexRow.push(index++);
        }

        indexArray.push(indexRow);
      }

      for (x = 0; x < radialSegments; x++) {
        for (y = 0; y < heightSegments; y++) {
          var a = indexArray[y][x];
          var b = indexArray[y + 1][x];
          var c = indexArray[y + 1][x + 1];
          var d = indexArray[y][x + 1];
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }

      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }

    function generateCap(top) {
      var x, centerIndexStart, centerIndexEnd;
      var uv = new Vector2();
      var vertex = new Vector3();
      var groupCount = 0;
      var radius = top === true ? radiusTop : radiusBottom;
      var sign = top === true ? 1 : -1;
      centerIndexStart = index;

      for (x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign, 0);
        normals.push(0, sign, 0);
        uvs.push(0.5, 0.5);
        index++;
      }

      centerIndexEnd = index;

      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var theta = u * thetaLength + thetaStart;
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, sign, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }

      for (x = 0; x < radialSegments; x++) {
        var c = centerIndexStart + x;
        var i = centerIndexEnd + x;

        if (top === true) {
          indices.push(i, i + 1, c);
        } else {
          indices.push(i + 1, i, c);
        }

        groupCount += 3;
      }

      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }

  CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

  function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = 'ConeGeometry';
    this.parameters = {
      radius: radius,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
  }

  ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
  ConeGeometry.prototype.constructor = ConeGeometry;

  function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = 'ConeBufferGeometry';
    this.parameters = {
      radius: radius,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
  }

  ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
  ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

  function CircleGeometry(radius, segments, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = 'CircleGeometry';
    this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
    this.mergeVertices();
  }

  CircleGeometry.prototype = Object.create(Geometry.prototype);
  CircleGeometry.prototype.constructor = CircleGeometry;

  function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = 'CircleBufferGeometry';
    this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    radius = radius || 1;
    segments = segments !== undefined ? Math.max(3, segments) : 8;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var i, s;
    var vertex = new Vector3();
    var uv = new Vector2();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);

    for (s = 0, i = 3; s <= segments; s++, i += 3) {
      var segment = thetaStart + s / segments * thetaLength;
      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }

    for (i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    }

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }

  CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
  var Geometries = Object.freeze({
    __proto__: null,
    WireframeGeometry: WireframeGeometry,
    ParametricGeometry: ParametricGeometry,
    ParametricBufferGeometry: ParametricBufferGeometry,
    TetrahedronGeometry: TetrahedronGeometry,
    TetrahedronBufferGeometry: TetrahedronBufferGeometry,
    OctahedronGeometry: OctahedronGeometry,
    OctahedronBufferGeometry: OctahedronBufferGeometry,
    IcosahedronGeometry: IcosahedronGeometry,
    IcosahedronBufferGeometry: IcosahedronBufferGeometry,
    DodecahedronGeometry: DodecahedronGeometry,
    DodecahedronBufferGeometry: DodecahedronBufferGeometry,
    PolyhedronGeometry: PolyhedronGeometry,
    PolyhedronBufferGeometry: PolyhedronBufferGeometry,
    TubeGeometry: TubeGeometry,
    TubeBufferGeometry: TubeBufferGeometry,
    TorusKnotGeometry: TorusKnotGeometry,
    TorusKnotBufferGeometry: TorusKnotBufferGeometry,
    TorusGeometry: TorusGeometry,
    TorusBufferGeometry: TorusBufferGeometry,
    TextGeometry: TextGeometry,
    TextBufferGeometry: TextBufferGeometry,
    SphereGeometry: SphereGeometry,
    SphereBufferGeometry: SphereBufferGeometry,
    RingGeometry: RingGeometry,
    RingBufferGeometry: RingBufferGeometry,
    PlaneGeometry: PlaneGeometry,
    PlaneBufferGeometry: PlaneBufferGeometry,
    LatheGeometry: LatheGeometry,
    LatheBufferGeometry: LatheBufferGeometry,
    ShapeGeometry: ShapeGeometry,
    ShapeBufferGeometry: ShapeBufferGeometry,
    ExtrudeGeometry: ExtrudeGeometry,
    ExtrudeBufferGeometry: ExtrudeBufferGeometry,
    EdgesGeometry: EdgesGeometry,
    ConeGeometry: ConeGeometry,
    ConeBufferGeometry: ConeBufferGeometry,
    CylinderGeometry: CylinderGeometry,
    CylinderBufferGeometry: CylinderBufferGeometry,
    CircleGeometry: CircleGeometry,
    CircleBufferGeometry: CircleBufferGeometry,
    BoxGeometry: BoxGeometry,
    BoxBufferGeometry: BoxBufferGeometry
  });

  function ShadowMaterial(parameters) {
    Material.call(this);
    this.type = 'ShadowMaterial';
    this.color = new Color(0x000000);
    this.transparent = true;
    this.setValues(parameters);
  }

  ShadowMaterial.prototype = Object.create(Material.prototype);
  ShadowMaterial.prototype.constructor = ShadowMaterial;
  ShadowMaterial.prototype.isShadowMaterial = true;

  ShadowMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    return this;
  };

  function RawShaderMaterial(parameters) {
    ShaderMaterial.call(this, parameters);
    this.type = 'RawShaderMaterial';
  }

  RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
  RawShaderMaterial.prototype.constructor = RawShaderMaterial;
  RawShaderMaterial.prototype.isRawShaderMaterial = true;

  function MeshStandardMaterial(parameters) {
    Material.call(this);
    this.defines = {
      'STANDARD': ''
    };
    this.type = 'MeshStandardMaterial';
    this.color = new Color(0xffffff);
    this.roughness = 1.0;
    this.metalness = 0.0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1.0;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }

  MeshStandardMaterial.prototype = Object.create(Material.prototype);
  MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

  MeshStandardMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.defines = {
      'STANDARD': ''
    };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };

  function MeshPhysicalMaterial(parameters) {
    MeshStandardMaterial.call(this);
    this.defines = {
      'STANDARD': '',
      'PHYSICAL': ''
    };
    this.type = 'MeshPhysicalMaterial';
    this.reflectivity = 0.5;
    this.clearcoat = 0.0;
    this.clearcoatRoughness = 0.0;
    this.sheen = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.transparency = 0.0;
    this.setValues(parameters);
  }

  MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
  MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

  MeshPhysicalMaterial.prototype.copy = function (source) {
    MeshStandardMaterial.prototype.copy.call(this, source);
    this.defines = {
      'STANDARD': '',
      'PHYSICAL': ''
    };
    this.reflectivity = source.reflectivity;
    this.clearcoat = source.clearcoat;
    this.clearcoatRoughness = source.clearcoatRoughness;
    if (source.sheen) this.sheen = (this.sheen || new Color()).copy(source.sheen);else this.sheen = null;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.transparency = source.transparency;
    return this;
  };

  function MeshPhongMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshPhongMaterial';
    this.color = new Color(0xffffff);
    this.specular = new Color(0x111111);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }

  MeshPhongMaterial.prototype = Object.create(Material.prototype);
  MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

  MeshPhongMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };

  function MeshToonMaterial(parameters) {
    Material.call(this);
    this.defines = {
      'TOON': ''
    };
    this.type = 'MeshToonMaterial';
    this.color = new Color(0xffffff);
    this.specular = new Color(0x111111);
    this.shininess = 30;
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }

  MeshToonMaterial.prototype = Object.create(Material.prototype);
  MeshToonMaterial.prototype.constructor = MeshToonMaterial;
  MeshToonMaterial.prototype.isMeshToonMaterial = true;

  MeshToonMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };

  function MeshNormalMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshNormalMaterial';
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }

  MeshNormalMaterial.prototype = Object.create(Material.prototype);
  MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

  MeshNormalMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };

  function MeshLambertMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshLambertMaterial';
    this.color = new Color(0xffffff);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }

  MeshLambertMaterial.prototype = Object.create(Material.prototype);
  MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

  MeshLambertMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };

  function MeshMatcapMaterial(parameters) {
    Material.call(this);
    this.defines = {
      'MATCAP': ''
    };
    this.type = 'MeshMatcapMaterial';
    this.color = new Color(0xffffff);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }

  MeshMatcapMaterial.prototype = Object.create(Material.prototype);
  MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
  MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

  MeshMatcapMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.defines = {
      'MATCAP': ''
    };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };

  function LineDashedMaterial(parameters) {
    LineBasicMaterial.call(this);
    this.type = 'LineDashedMaterial';
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }

  LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
  LineDashedMaterial.prototype.constructor = LineDashedMaterial;
  LineDashedMaterial.prototype.isLineDashedMaterial = true;

  LineDashedMaterial.prototype.copy = function (source) {
    LineBasicMaterial.prototype.copy.call(this, source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  };

  var Materials = Object.freeze({
    __proto__: null,
    ShadowMaterial: ShadowMaterial,
    SpriteMaterial: SpriteMaterial,
    RawShaderMaterial: RawShaderMaterial,
    ShaderMaterial: ShaderMaterial,
    PointsMaterial: PointsMaterial,
    MeshPhysicalMaterial: MeshPhysicalMaterial,
    MeshStandardMaterial: MeshStandardMaterial,
    MeshPhongMaterial: MeshPhongMaterial,
    MeshToonMaterial: MeshToonMaterial,
    MeshNormalMaterial: MeshNormalMaterial,
    MeshLambertMaterial: MeshLambertMaterial,
    MeshDepthMaterial: MeshDepthMaterial,
    MeshDistanceMaterial: MeshDistanceMaterial,
    MeshBasicMaterial: MeshBasicMaterial,
    MeshMatcapMaterial: MeshMatcapMaterial,
    LineDashedMaterial: LineDashedMaterial,
    LineBasicMaterial: LineBasicMaterial,
    Material: Material
  });
  var AnimationUtils = {
    arraySlice: function arraySlice(array, from, to) {
      if (AnimationUtils.isTypedArray(array)) {
        return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
      }

      return array.slice(from, to);
    },
    convertArray: function convertArray(array, type, forceClone) {
      if (!array || !forceClone && array.constructor === type) return array;

      if (typeof type.BYTES_PER_ELEMENT === 'number') {
        return new type(array);
      }

      return Array.prototype.slice.call(array);
    },
    isTypedArray: function isTypedArray(object) {
      return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    getKeyframeOrder: function getKeyframeOrder(times) {
      function compareTime(i, j) {
        return times[i] - times[j];
      }

      var n = times.length;
      var result = new Array(n);

      for (var i = 0; i !== n; ++i) {
        result[i] = i;
      }

      result.sort(compareTime);
      return result;
    },
    sortedArray: function sortedArray(values, stride, order) {
      var nValues = values.length;
      var result = new values.constructor(nValues);

      for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
        var srcOffset = order[i] * stride;

        for (var j = 0; j !== stride; ++j) {
          result[dstOffset++] = values[srcOffset + j];
        }
      }

      return result;
    },
    flattenJSON: function flattenJSON(jsonKeys, times, values, valuePropertyName) {
      var i = 1,
          key = jsonKeys[0];

      while (key !== undefined && key[valuePropertyName] === undefined) {
        key = jsonKeys[i++];
      }

      if (key === undefined) return;
      var value = key[valuePropertyName];
      if (value === undefined) return;

      if (Array.isArray(value)) {
        do {
          value = key[valuePropertyName];

          if (value !== undefined) {
            times.push(key.time);
            values.push.apply(values, value);
          }

          key = jsonKeys[i++];
        } while (key !== undefined);
      } else if (value.toArray !== undefined) {
        do {
          value = key[valuePropertyName];

          if (value !== undefined) {
            times.push(key.time);
            value.toArray(values, values.length);
          }

          key = jsonKeys[i++];
        } while (key !== undefined);
      } else {
        do {
          value = key[valuePropertyName];

          if (value !== undefined) {
            times.push(key.time);
            values.push(value);
          }

          key = jsonKeys[i++];
        } while (key !== undefined);
      }
    },
    subclip: function subclip(sourceClip, name, startFrame, endFrame, fps) {
      fps = fps || 30;
      var clip = sourceClip.clone();
      clip.name = name;
      var tracks = [];

      for (var i = 0; i < clip.tracks.length; ++i) {
        var track = clip.tracks[i];
        var valueSize = track.getValueSize();
        var times = [];
        var values = [];

        for (var j = 0; j < track.times.length; ++j) {
          var frame = track.times[j] * fps;
          if (frame < startFrame || frame >= endFrame) continue;
          times.push(track.times[j]);

          for (var k = 0; k < valueSize; ++k) {
            values.push(track.values[j * valueSize + k]);
          }
        }

        if (times.length === 0) continue;
        track.times = AnimationUtils.convertArray(times, track.times.constructor);
        track.values = AnimationUtils.convertArray(values, track.values.constructor);
        tracks.push(track);
      }

      clip.tracks = tracks;
      var minStartTime = Infinity;

      for (var i = 0; i < clip.tracks.length; ++i) {
        if (minStartTime > clip.tracks[i].times[0]) {
          minStartTime = clip.tracks[i].times[0];
        }
      }

      for (var i = 0; i < clip.tracks.length; ++i) {
        clip.tracks[i].shift(-1 * minStartTime);
      }

      clip.resetDuration();
      return clip;
    }
  };

  function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
  }

  Object.assign(Interpolant.prototype, {
    evaluate: function evaluate(t) {
      var pp = this.parameterPositions,
          i1 = this._cachedIndex,
          t1 = pp[i1],
          t0 = pp[i1 - 1];

      validate_interval: {
        seek: {
          var right;

          linear_scan: {
            forward_scan: if (!(t < t1)) {
              for (var giveUpAt = i1 + 2;;) {
                if (t1 === undefined) {
                  if (t < t0) break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t, t0);
                }

                if (i1 === giveUpAt) break;
                t0 = t1;
                t1 = pp[++i1];

                if (t < t1) {
                  break seek;
                }
              }

              right = pp.length;
              break linear_scan;
            }

            if (!(t >= t0)) {
              var t1global = pp[1];

              if (t < t1global) {
                i1 = 2;
                t0 = t1global;
              }

              for (var giveUpAt = i1 - 2;;) {
                if (t0 === undefined) {
                  this._cachedIndex = 0;
                  return this.beforeStart_(0, t, t1);
                }

                if (i1 === giveUpAt) break;
                t1 = t0;
                t0 = pp[--i1 - 1];

                if (t >= t0) {
                  break seek;
                }
              }

              right = i1;
              i1 = 0;
              break linear_scan;
            }

            break validate_interval;
          }

          while (i1 < right) {
            var mid = i1 + right >>> 1;

            if (t < pp[mid]) {
              right = mid;
            } else {
              i1 = mid + 1;
            }
          }

          t1 = pp[i1];
          t0 = pp[i1 - 1];

          if (t0 === undefined) {
            this._cachedIndex = 0;
            return this.beforeStart_(0, t, t1);
          }

          if (t1 === undefined) {
            i1 = pp.length;
            this._cachedIndex = i1;
            return this.afterEnd_(i1 - 1, t0, t);
          }
        }

        this._cachedIndex = i1;
        this.intervalChanged_(i1, t0, t1);
      }

      return this.interpolate_(i1, t0, t, t1);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function getSettings_() {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function copySampleValue_(index) {
      var result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset = index * stride;

      for (var i = 0; i !== stride; ++i) {
        result[i] = values[offset + i];
      }

      return result;
    },
    interpolate_: function interpolate_() {
      throw new Error('call to abstract method');
    },
    intervalChanged_: function intervalChanged_() {}
  });
  Object.assign(Interpolant.prototype, {
    beforeStart_: Interpolant.prototype.copySampleValue_,
    afterEnd_: Interpolant.prototype.copySampleValue_
  });

  function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
  }

  CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: CubicInterpolant,
    DefaultSettings_: {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    },
    intervalChanged_: function intervalChanged_(i1, t0, t1) {
      var pp = this.parameterPositions,
          iPrev = i1 - 2,
          iNext = i1 + 1,
          tPrev = pp[iPrev],
          tNext = pp[iNext];

      if (tPrev === undefined) {
        switch (this.getSettings_().endingStart) {
          case ZeroSlopeEnding:
            iPrev = i1;
            tPrev = 2 * t0 - t1;
            break;

          case WrapAroundEnding:
            iPrev = pp.length - 2;
            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
            break;

          default:
            iPrev = i1;
            tPrev = t1;
        }
      }

      if (tNext === undefined) {
        switch (this.getSettings_().endingEnd) {
          case ZeroSlopeEnding:
            iNext = i1;
            tNext = 2 * t1 - t0;
            break;

          case WrapAroundEnding:
            iNext = 1;
            tNext = t1 + pp[1] - pp[0];
            break;

          default:
            iNext = i1 - 1;
            tNext = t0;
        }
      }

      var halfDt = (t1 - t0) * 0.5,
          stride = this.valueSize;
      this._weightPrev = halfDt / (t0 - tPrev);
      this._weightNext = halfDt / (tNext - t1);
      this._offsetPrev = iPrev * stride;
      this._offsetNext = iNext * stride;
    },
    interpolate_: function interpolate_(i1, t0, t, t1) {
      var result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          o1 = i1 * stride,
          o0 = o1 - stride,
          oP = this._offsetPrev,
          oN = this._offsetNext,
          wP = this._weightPrev,
          wN = this._weightNext,
          p = (t - t0) / (t1 - t0),
          pp = p * p,
          ppp = pp * p;
      var sP = -wP * ppp + 2 * wP * pp - wP * p;
      var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
      var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
      var sN = wN * ppp - wN * pp;

      for (var i = 0; i !== stride; ++i) {
        result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
      }

      return result;
    }
  });

  function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: LinearInterpolant,
    interpolate_: function interpolate_(i1, t0, t, t1) {
      var result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset1 = i1 * stride,
          offset0 = offset1 - stride,
          weight1 = (t - t0) / (t1 - t0),
          weight0 = 1 - weight1;

      for (var i = 0; i !== stride; ++i) {
        result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
      }

      return result;
    }
  });

  function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: DiscreteInterpolant,
    interpolate_: function interpolate_(i1) {
      return this.copySampleValue_(i1 - 1);
    }
  });

  function KeyframeTrack(name, times, values, interpolation) {
    if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }

  Object.assign(KeyframeTrack, {
    toJSON: function toJSON(track) {
      var trackType = track.constructor;
      var json;

      if (trackType.toJSON !== undefined) {
        json = trackType.toJSON(track);
      } else {
        json = {
          'name': track.name,
          'times': AnimationUtils.convertArray(track.times, Array),
          'values': AnimationUtils.convertArray(track.values, Array)
        };
        var interpolation = track.getInterpolation();

        if (interpolation !== track.DefaultInterpolation) {
          json.interpolation = interpolation;
        }
      }

      json.type = track.ValueTypeName;
      return json;
    }
  });
  Object.assign(KeyframeTrack.prototype, {
    constructor: KeyframeTrack,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function InterpolantFactoryMethodDiscrete(result) {
      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodLinear: function InterpolantFactoryMethodLinear(result) {
      return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: function InterpolantFactoryMethodSmooth(result) {
      return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    setInterpolation: function setInterpolation(interpolation) {
      var factoryMethod;

      switch (interpolation) {
        case InterpolateDiscrete:
          factoryMethod = this.InterpolantFactoryMethodDiscrete;
          break;

        case InterpolateLinear:
          factoryMethod = this.InterpolantFactoryMethodLinear;
          break;

        case InterpolateSmooth:
          factoryMethod = this.InterpolantFactoryMethodSmooth;
          break;
      }

      if (factoryMethod === undefined) {
        var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;

        if (this.createInterpolant === undefined) {
          if (interpolation !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
          } else {
            throw new Error(message);
          }
        }

        console.warn('THREE.KeyframeTrack:', message);
        return this;
      }

      this.createInterpolant = factoryMethod;
      return this;
    },
    getInterpolation: function getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return InterpolateDiscrete;

        case this.InterpolantFactoryMethodLinear:
          return InterpolateLinear;

        case this.InterpolantFactoryMethodSmooth:
          return InterpolateSmooth;
      }
    },
    getValueSize: function getValueSize() {
      return this.values.length / this.times.length;
    },
    shift: function shift(timeOffset) {
      if (timeOffset !== 0.0) {
        var times = this.times;

        for (var i = 0, n = times.length; i !== n; ++i) {
          times[i] += timeOffset;
        }
      }

      return this;
    },
    scale: function scale(timeScale) {
      if (timeScale !== 1.0) {
        var times = this.times;

        for (var i = 0, n = times.length; i !== n; ++i) {
          times[i] *= timeScale;
        }
      }

      return this;
    },
    trim: function trim(startTime, endTime) {
      var times = this.times,
          nKeys = times.length,
          from = 0,
          to = nKeys - 1;

      while (from !== nKeys && times[from] < startTime) {
        ++from;
      }

      while (to !== -1 && times[to] > endTime) {
        --to;
      }

      ++to;

      if (from !== 0 || to !== nKeys) {
        if (from >= to) to = Math.max(to, 1), from = to - 1;
        var stride = this.getValueSize();
        this.times = AnimationUtils.arraySlice(times, from, to);
        this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
      }

      return this;
    },
    validate: function validate() {
      var valid = true;
      var valueSize = this.getValueSize();

      if (valueSize - Math.floor(valueSize) !== 0) {
        console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
        valid = false;
      }

      var times = this.times,
          values = this.values,
          nKeys = times.length;

      if (nKeys === 0) {
        console.error('THREE.KeyframeTrack: Track is empty.', this);
        valid = false;
      }

      var prevTime = null;

      for (var i = 0; i !== nKeys; i++) {
        var currTime = times[i];

        if (typeof currTime === 'number' && isNaN(currTime)) {
          console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
          valid = false;
          break;
        }

        if (prevTime !== null && prevTime > currTime) {
          console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
          valid = false;
          break;
        }

        prevTime = currTime;
      }

      if (values !== undefined) {
        if (AnimationUtils.isTypedArray(values)) {
          for (var i = 0, n = values.length; i !== n; ++i) {
            var value = values[i];

            if (isNaN(value)) {
              console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
              valid = false;
              break;
            }
          }
        }
      }

      return valid;
    },
    optimize: function optimize() {
      var times = AnimationUtils.arraySlice(this.times),
          values = AnimationUtils.arraySlice(this.values),
          stride = this.getValueSize(),
          smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
          writeIndex = 1,
          lastIndex = times.length - 1;

      for (var i = 1; i < lastIndex; ++i) {
        var keep = false;
        var time = times[i];
        var timeNext = times[i + 1];

        if (time !== timeNext && (i !== 1 || time !== time[0])) {
          if (!smoothInterpolation) {
            var offset = i * stride,
                offsetP = offset - stride,
                offsetN = offset + stride;

            for (var j = 0; j !== stride; ++j) {
              var value = values[offset + j];

              if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                keep = true;
                break;
              }
            }
          } else {
            keep = true;
          }
        }

        if (keep) {
          if (i !== writeIndex) {
            times[writeIndex] = times[i];
            var readOffset = i * stride,
                writeOffset = writeIndex * stride;

            for (var j = 0; j !== stride; ++j) {
              values[writeOffset + j] = values[readOffset + j];
            }
          }

          ++writeIndex;
        }
      }

      if (lastIndex > 0) {
        times[writeIndex] = times[lastIndex];

        for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
          values[writeOffset + j] = values[readOffset + j];
        }

        ++writeIndex;
      }

      if (writeIndex !== times.length) {
        this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
        this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
      } else {
        this.times = times;
        this.values = values;
      }

      return this;
    },
    clone: function clone() {
      var times = AnimationUtils.arraySlice(this.times, 0);
      var values = AnimationUtils.arraySlice(this.values, 0);
      var TypedKeyframeTrack = this.constructor;
      var track = new TypedKeyframeTrack(this.name, times, values);
      track.createInterpolant = this.createInterpolant;
      return track;
    }
  });

  function BooleanKeyframeTrack(name, times, values) {
    KeyframeTrack.call(this, name, times, values);
  }

  BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: BooleanKeyframeTrack,
    ValueTypeName: 'bool',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
  });

  function ColorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }

  ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: ColorKeyframeTrack,
    ValueTypeName: 'color'
  });

  function NumberKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }

  NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: NumberKeyframeTrack,
    ValueTypeName: 'number'
  });

  function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: QuaternionLinearInterpolant,
    interpolate_: function interpolate_(i1, t0, t, t1) {
      var result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset = i1 * stride,
          alpha = (t - t0) / (t1 - t0);

      for (var end = offset + stride; offset !== end; offset += 4) {
        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
      }

      return result;
    }
  });

  function QuaternionKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }

  QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: QuaternionKeyframeTrack,
    ValueTypeName: 'quaternion',
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodLinear: function InterpolantFactoryMethodLinear(result) {
      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: undefined
  });

  function StringKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }

  StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: StringKeyframeTrack,
    ValueTypeName: 'string',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
  });

  function VectorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }

  VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: VectorKeyframeTrack,
    ValueTypeName: 'vector'
  });

  function AnimationClip(name, duration, tracks) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration !== undefined ? duration : -1;
    this.uuid = MathUtils.generateUUID();

    if (this.duration < 0) {
      this.resetDuration();
    }
  }

  function getTrackTypeForValueTypeName(typeName) {
    switch (typeName.toLowerCase()) {
      case 'scalar':
      case 'double':
      case 'float':
      case 'number':
      case 'integer':
        return NumberKeyframeTrack;

      case 'vector':
      case 'vector2':
      case 'vector3':
      case 'vector4':
        return VectorKeyframeTrack;

      case 'color':
        return ColorKeyframeTrack;

      case 'quaternion':
        return QuaternionKeyframeTrack;

      case 'bool':
      case 'boolean':
        return BooleanKeyframeTrack;

      case 'string':
        return StringKeyframeTrack;
    }

    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
  }

  function parseKeyframeTrack(json) {
    if (json.type === undefined) {
      throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
    }

    var trackType = getTrackTypeForValueTypeName(json.type);

    if (json.times === undefined) {
      var times = [],
          values = [];
      AnimationUtils.flattenJSON(json.keys, times, values, 'value');
      json.times = times;
      json.values = values;
    }

    if (trackType.parse !== undefined) {
      return trackType.parse(json);
    } else {
      return new trackType(json.name, json.times, json.values, json.interpolation);
    }
  }

  Object.assign(AnimationClip, {
    parse: function parse(json) {
      var tracks = [],
          jsonTracks = json.tracks,
          frameTime = 1.0 / (json.fps || 1.0);

      for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
        tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
      }

      return new AnimationClip(json.name, json.duration, tracks);
    },
    toJSON: function toJSON(clip) {
      var tracks = [],
          clipTracks = clip.tracks;
      var json = {
        'name': clip.name,
        'duration': clip.duration,
        'tracks': tracks,
        'uuid': clip.uuid
      };

      for (var i = 0, n = clipTracks.length; i !== n; ++i) {
        tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
      }

      return json;
    },
    CreateFromMorphTargetSequence: function CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
      var numMorphTargets = morphTargetSequence.length;
      var tracks = [];

      for (var i = 0; i < numMorphTargets; i++) {
        var times = [];
        var values = [];
        times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
        values.push(0, 1, 0);
        var order = AnimationUtils.getKeyframeOrder(times);
        times = AnimationUtils.sortedArray(times, 1, order);
        values = AnimationUtils.sortedArray(values, 1, order);

        if (!noLoop && times[0] === 0) {
          times.push(numMorphTargets);
          values.push(values[0]);
        }

        tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
      }

      return new AnimationClip(name, -1, tracks);
    },
    findByName: function findByName(objectOrClipArray, name) {
      var clipArray = objectOrClipArray;

      if (!Array.isArray(objectOrClipArray)) {
        var o = objectOrClipArray;
        clipArray = o.geometry && o.geometry.animations || o.animations;
      }

      for (var i = 0; i < clipArray.length; i++) {
        if (clipArray[i].name === name) {
          return clipArray[i];
        }
      }

      return null;
    },
    CreateClipsFromMorphTargetSequences: function CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
      var animationToMorphTargets = {};
      var pattern = /^([\w-]*?)([\d]+)$/;

      for (var i = 0, il = morphTargets.length; i < il; i++) {
        var morphTarget = morphTargets[i];
        var parts = morphTarget.name.match(pattern);

        if (parts && parts.length > 1) {
          var name = parts[1];
          var animationMorphTargets = animationToMorphTargets[name];

          if (!animationMorphTargets) {
            animationToMorphTargets[name] = animationMorphTargets = [];
          }

          animationMorphTargets.push(morphTarget);
        }
      }

      var clips = [];

      for (var name in animationToMorphTargets) {
        clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
      }

      return clips;
    },
    parseAnimation: function parseAnimation(animation, bones) {
      if (!animation) {
        console.error('THREE.AnimationClip: No animation in JSONLoader data.');
        return null;
      }

      var addNonemptyTrack = function addNonemptyTrack(trackType, trackName, animationKeys, propertyName, destTracks) {
        if (animationKeys.length !== 0) {
          var times = [];
          var values = [];
          AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);

          if (times.length !== 0) {
            destTracks.push(new trackType(trackName, times, values));
          }
        }
      };

      var tracks = [];
      var clipName = animation.name || 'default';
      var duration = animation.length || -1;
      var fps = animation.fps || 30;
      var hierarchyTracks = animation.hierarchy || [];

      for (var h = 0; h < hierarchyTracks.length; h++) {
        var animationKeys = hierarchyTracks[h].keys;
        if (!animationKeys || animationKeys.length === 0) continue;

        if (animationKeys[0].morphTargets) {
          var morphTargetNames = {};

          for (var k = 0; k < animationKeys.length; k++) {
            if (animationKeys[k].morphTargets) {
              for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
              }
            }
          }

          for (var morphTargetName in morphTargetNames) {
            var times = [];
            var values = [];

            for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
              var animationKey = animationKeys[k];
              times.push(animationKey.time);
              values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
            }

            tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
          }

          duration = morphTargetNames.length * (fps || 1.0);
        } else {
          var boneName = '.bones[' + bones[h].name + ']';
          addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
          addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
          addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
        }
      }

      if (tracks.length === 0) {
        return null;
      }

      var clip = new AnimationClip(clipName, duration, tracks);
      return clip;
    }
  });
  Object.assign(AnimationClip.prototype, {
    resetDuration: function resetDuration() {
      var tracks = this.tracks,
          duration = 0;

      for (var i = 0, n = tracks.length; i !== n; ++i) {
        var track = this.tracks[i];
        duration = Math.max(duration, track.times[track.times.length - 1]);
      }

      this.duration = duration;
      return this;
    },
    trim: function trim() {
      for (var i = 0; i < this.tracks.length; i++) {
        this.tracks[i].trim(0, this.duration);
      }

      return this;
    },
    validate: function validate() {
      var valid = true;

      for (var i = 0; i < this.tracks.length; i++) {
        valid = valid && this.tracks[i].validate();
      }

      return valid;
    },
    optimize: function optimize() {
      for (var i = 0; i < this.tracks.length; i++) {
        this.tracks[i].optimize();
      }

      return this;
    },
    clone: function clone() {
      var tracks = [];

      for (var i = 0; i < this.tracks.length; i++) {
        tracks.push(this.tracks[i].clone());
      }

      return new AnimationClip(this.name, this.duration, tracks);
    }
  });
  var Cache = {
    enabled: false,
    files: {},
    add: function add(key, file) {
      if (this.enabled === false) return;
      this.files[key] = file;
    },
    get: function get(key) {
      if (this.enabled === false) return;
      return this.files[key];
    },
    remove: function remove(key) {
      delete this.files[key];
    },
    clear: function clear() {
      this.files = {};
    }
  };

  function LoadingManager(onLoad, onProgress, onError) {
    var scope = this;
    var isLoading = false;
    var itemsLoaded = 0;
    var itemsTotal = 0;
    var urlModifier = undefined;
    var handlers = [];
    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;

    this.itemStart = function (url) {
      itemsTotal++;

      if (isLoading === false) {
        if (scope.onStart !== undefined) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }

      isLoading = true;
    };

    this.itemEnd = function (url) {
      itemsLoaded++;

      if (scope.onProgress !== undefined) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }

      if (itemsLoaded === itemsTotal) {
        isLoading = false;

        if (scope.onLoad !== undefined) {
          scope.onLoad();
        }
      }
    };

    this.itemError = function (url) {
      if (scope.onError !== undefined) {
        scope.onError(url);
      }
    };

    this.resolveURL = function (url) {
      if (urlModifier) {
        return urlModifier(url);
      }

      return url;
    };

    this.setURLModifier = function (transform) {
      urlModifier = transform;
      return this;
    };

    this.addHandler = function (regex, loader) {
      handlers.push(regex, loader);
      return this;
    };

    this.removeHandler = function (regex) {
      var index = handlers.indexOf(regex);

      if (index !== -1) {
        handlers.splice(index, 2);
      }

      return this;
    };

    this.getHandler = function (file) {
      for (var i = 0, l = handlers.length; i < l; i += 2) {
        var regex = handlers[i];
        var loader = handlers[i + 1];
        if (regex.global) regex.lastIndex = 0;

        if (regex.test(file)) {
          return loader;
        }
      }

      return null;
    };
  }

  var DefaultLoadingManager = new LoadingManager();

  function Loader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.crossOrigin = 'anonymous';
    this.path = '';
    this.resourcePath = '';
  }

  Object.assign(Loader.prototype, {
    load: function load() {},
    parse: function parse() {},
    setCrossOrigin: function setCrossOrigin(crossOrigin) {
      this.crossOrigin = crossOrigin;
      return this;
    },
    setPath: function setPath(path) {
      this.path = path;
      return this;
    },
    setResourcePath: function setResourcePath(resourcePath) {
      this.resourcePath = resourcePath;
      return this;
    }
  });
  var loading = {};

  function FileLoader(manager) {
    Loader.call(this, manager);
  }

  FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: FileLoader,
    load: function load(url, onLoad, onProgress, onError) {
      if (url === undefined) url = '';
      if (this.path !== undefined) url = this.path + url;
      url = this.manager.resolveURL(url);
      var scope = this;
      var cached = Cache.get(url);

      if (cached !== undefined) {
        scope.manager.itemStart(url);
        setTimeout(function () {
          if (onLoad) onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }

      if (loading[url] !== undefined) {
        loading[url].push({
          onLoad: onLoad,
          onProgress: onProgress,
          onError: onError
        });
        return;
      }

      var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
      var dataUriRegexResult = url.match(dataUriRegex);

      if (dataUriRegexResult) {
        var mimeType = dataUriRegexResult[1];
        var isBase64 = !!dataUriRegexResult[2];
        var data = dataUriRegexResult[3];
        data = decodeURIComponent(data);
        if (isBase64) data = atob(data);

        try {
          var response;
          var responseType = (this.responseType || '').toLowerCase();

          switch (responseType) {
            case 'arraybuffer':
            case 'blob':
              var view = new Uint8Array(data.length);

              for (var i = 0; i < data.length; i++) {
                view[i] = data.charCodeAt(i);
              }

              if (responseType === 'blob') {
                response = new Blob([view.buffer], {
                  type: mimeType
                });
              } else {
                response = view.buffer;
              }

              break;

            case 'document':
              var parser = new DOMParser();
              response = parser.parseFromString(data, mimeType);
              break;

            case 'json':
              response = JSON.parse(data);
              break;

            default:
              response = data;
              break;
          }

          setTimeout(function () {
            if (onLoad) onLoad(response);
            scope.manager.itemEnd(url);
          }, 0);
        } catch (error) {
          setTimeout(function () {
            if (onError) onError(error);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }, 0);
        }
      } else {
        loading[url] = [];
        loading[url].push({
          onLoad: onLoad,
          onProgress: onProgress,
          onError: onError
        });
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.addEventListener('load', function (event) {
          var response = this.response;
          var callbacks = loading[url];
          delete loading[url];

          if (this.status === 200 || this.status === 0) {
            if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');
            Cache.add(url, response);

            for (var i = 0, il = callbacks.length; i < il; i++) {
              var callback = callbacks[i];
              if (callback.onLoad) callback.onLoad(response);
            }

            scope.manager.itemEnd(url);
          } else {
            for (var i = 0, il = callbacks.length; i < il; i++) {
              var callback = callbacks[i];
              if (callback.onError) callback.onError(event);
            }

            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }
        }, false);
        request.addEventListener('progress', function (event) {
          var callbacks = loading[url];

          for (var i = 0, il = callbacks.length; i < il; i++) {
            var callback = callbacks[i];
            if (callback.onProgress) callback.onProgress(event);
          }
        }, false);
        request.addEventListener('error', function (event) {
          var callbacks = loading[url];
          delete loading[url];

          for (var i = 0, il = callbacks.length; i < il; i++) {
            var callback = callbacks[i];
            if (callback.onError) callback.onError(event);
          }

          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, false);
        request.addEventListener('abort', function (event) {
          var callbacks = loading[url];
          delete loading[url];

          for (var i = 0, il = callbacks.length; i < il; i++) {
            var callback = callbacks[i];
            if (callback.onError) callback.onError(event);
          }

          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, false);
        if (this.responseType !== undefined) request.responseType = this.responseType;
        if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
        if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

        for (var header in this.requestHeader) {
          request.setRequestHeader(header, this.requestHeader[header]);
        }

        request.send(null);
      }

      scope.manager.itemStart(url);
      return request;
    },
    setResponseType: function setResponseType(value) {
      this.responseType = value;
      return this;
    },
    setWithCredentials: function setWithCredentials(value) {
      this.withCredentials = value;
      return this;
    },
    setMimeType: function setMimeType(value) {
      this.mimeType = value;
      return this;
    },
    setRequestHeader: function setRequestHeader(value) {
      this.requestHeader = value;
      return this;
    }
  });

  function AnimationLoader(manager) {
    Loader.call(this, manager);
  }

  AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: AnimationLoader,
    load: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.load(url, function (text) {
        onLoad(scope.parse(JSON.parse(text)));
      }, onProgress, onError);
    },
    parse: function parse(json) {
      var animations = [];

      for (var i = 0; i < json.length; i++) {
        var clip = AnimationClip.parse(json[i]);
        animations.push(clip);
      }

      return animations;
    }
  });

  function CompressedTextureLoader(manager) {
    Loader.call(this, manager);
  }

  CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: CompressedTextureLoader,
    load: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var images = [];
      var texture = new CompressedTexture();
      texture.image = images;
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType('arraybuffer');

      function loadTexture(i) {
        loader.load(url[i], function (buffer) {
          var texDatas = scope.parse(buffer, true);
          images[i] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps
          };
          loaded += 1;

          if (loaded === 6) {
            if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
          }
        }, onProgress, onError);
      }

      if (Array.isArray(url)) {
        var loaded = 0;

        for (var i = 0, il = url.length; i < il; ++i) {
          loadTexture(i);
        }
      } else {
        loader.load(url, function (buffer) {
          var texDatas = scope.parse(buffer, true);

          if (texDatas.isCubemap) {
            var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

            for (var f = 0; f < faces; f++) {
              images[f] = {
                mipmaps: []
              };

              for (var i = 0; i < texDatas.mipmapCount; i++) {
                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                images[f].format = texDatas.format;
                images[f].width = texDatas.width;
                images[f].height = texDatas.height;
              }
            }
          } else {
            texture.image.width = texDatas.width;
            texture.image.height = texDatas.height;
            texture.mipmaps = texDatas.mipmaps;
          }

          if (texDatas.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }

          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }, onProgress, onError);
      }

      return texture;
    }
  });

  function DataTextureLoader(manager) {
    Loader.call(this, manager);
  }

  DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: DataTextureLoader,
    load: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var texture = new DataTexture();
      var loader = new FileLoader(this.manager);
      loader.setResponseType('arraybuffer');
      loader.setPath(this.path);
      loader.load(url, function (buffer) {
        var texData = scope.parse(buffer);
        if (!texData) return;

        if (texData.image !== undefined) {
          texture.image = texData.image;
        } else if (texData.data !== undefined) {
          texture.image.width = texData.width;
          texture.image.height = texData.height;
          texture.image.data = texData.data;
        }

        texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
        texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
        texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
        texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
        texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

        if (texData.format !== undefined) {
          texture.format = texData.format;
        }

        if (texData.type !== undefined) {
          texture.type = texData.type;
        }

        if (texData.mipmaps !== undefined) {
          texture.mipmaps = texData.mipmaps;
          texture.minFilter = LinearMipmapLinearFilter;
        }

        if (texData.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }

        texture.needsUpdate = true;
        if (onLoad) onLoad(texture, texData);
      }, onProgress, onError);
      return texture;
    }
  });

  function ImageLoader(manager) {
    Loader.call(this, manager);
  }

  ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ImageLoader,
    load: function load(url, onLoad, onProgress, onError) {
      if (this.path !== undefined) url = this.path + url;
      url = this.manager.resolveURL(url);
      var scope = this;
      var cached = Cache.get(url);

      if (cached !== undefined) {
        scope.manager.itemStart(url);
        setTimeout(function () {
          if (onLoad) onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }

      var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

      function onImageLoad() {
        image.removeEventListener('load', onImageLoad, false);
        image.removeEventListener('error', onImageError, false);
        Cache.add(url, this);
        if (onLoad) onLoad(this);
        scope.manager.itemEnd(url);
      }

      function onImageError(event) {
        image.removeEventListener('load', onImageLoad, false);
        image.removeEventListener('error', onImageError, false);
        if (onError) onError(event);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }

      image.addEventListener('load', onImageLoad, false);
      image.addEventListener('error', onImageError, false);

      if (url.substr(0, 5) !== 'data:') {
        if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
      }

      scope.manager.itemStart(url);
      image.src = url;
      return image;
    }
  });

  function CubeTextureLoader(manager) {
    Loader.call(this, manager);
  }

  CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: CubeTextureLoader,
    load: function load(urls, onLoad, onProgress, onError) {
      var texture = new CubeTexture();
      var loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      var loaded = 0;

      function loadTexture(i) {
        loader.load(urls[i], function (image) {
          texture.images[i] = image;
          loaded++;

          if (loaded === 6) {
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
          }
        }, undefined, onError);
      }

      for (var i = 0; i < urls.length; ++i) {
        loadTexture(i);
      }

      return texture;
    }
  });

  function TextureLoader(manager) {
    Loader.call(this, manager);
  }

  TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: TextureLoader,
    load: function load(url, onLoad, onProgress, onError) {
      var texture = new Texture();
      var loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      loader.load(url, function (image) {
        texture.image = image;
        var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
        texture.format = isJPEG ? RGBFormat : RGBAFormat;
        texture.needsUpdate = true;

        if (onLoad !== undefined) {
          onLoad(texture);
        }
      }, onProgress, onError);
      return texture;
    }
  });

  function Curve() {
    this.type = 'Curve';
    this.arcLengthDivisions = 200;
  }

  Object.assign(Curve.prototype, {
    getPoint: function getPoint() {
      console.warn('THREE.Curve: .getPoint() not implemented.');
      return null;
    },
    getPointAt: function getPointAt(u, optionalTarget) {
      var t = this.getUtoTmapping(u);
      return this.getPoint(t, optionalTarget);
    },
    getPoints: function getPoints(divisions) {
      if (divisions === undefined) divisions = 5;
      var points = [];

      for (var d = 0; d <= divisions; d++) {
        points.push(this.getPoint(d / divisions));
      }

      return points;
    },
    getSpacedPoints: function getSpacedPoints(divisions) {
      if (divisions === undefined) divisions = 5;
      var points = [];

      for (var d = 0; d <= divisions; d++) {
        points.push(this.getPointAt(d / divisions));
      }

      return points;
    },
    getLength: function getLength() {
      var lengths = this.getLengths();
      return lengths[lengths.length - 1];
    },
    getLengths: function getLengths(divisions) {
      if (divisions === undefined) divisions = this.arcLengthDivisions;

      if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
        return this.cacheArcLengths;
      }

      this.needsUpdate = false;
      var cache = [];
      var current,
          last = this.getPoint(0);
      var p,
          sum = 0;
      cache.push(0);

      for (p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        sum += current.distanceTo(last);
        cache.push(sum);
        last = current;
      }

      this.cacheArcLengths = cache;
      return cache;
    },
    updateArcLengths: function updateArcLengths() {
      this.needsUpdate = true;
      this.getLengths();
    },
    getUtoTmapping: function getUtoTmapping(u, distance) {
      var arcLengths = this.getLengths();
      var i = 0,
          il = arcLengths.length;
      var targetArcLength;

      if (distance) {
        targetArcLength = distance;
      } else {
        targetArcLength = u * arcLengths[il - 1];
      }

      var low = 0,
          high = il - 1,
          comparison;

      while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;

        if (comparison < 0) {
          low = i + 1;
        } else if (comparison > 0) {
          high = i - 1;
        } else {
          high = i;
          break;
        }
      }

      i = high;

      if (arcLengths[i] === targetArcLength) {
        return i / (il - 1);
      }

      var lengthBefore = arcLengths[i];
      var lengthAfter = arcLengths[i + 1];
      var segmentLength = lengthAfter - lengthBefore;
      var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      var t = (i + segmentFraction) / (il - 1);
      return t;
    },
    getTangent: function getTangent(t) {
      var delta = 0.0001;
      var t1 = t - delta;
      var t2 = t + delta;
      if (t1 < 0) t1 = 0;
      if (t2 > 1) t2 = 1;
      var pt1 = this.getPoint(t1);
      var pt2 = this.getPoint(t2);
      var vec = pt2.clone().sub(pt1);
      return vec.normalize();
    },
    getTangentAt: function getTangentAt(u) {
      var t = this.getUtoTmapping(u);
      return this.getTangent(t);
    },
    computeFrenetFrames: function computeFrenetFrames(segments, closed) {
      var normal = new Vector3();
      var tangents = [];
      var normals = [];
      var binormals = [];
      var vec = new Vector3();
      var mat = new Matrix4();
      var i, u, theta;

      for (i = 0; i <= segments; i++) {
        u = i / segments;
        tangents[i] = this.getTangentAt(u);
        tangents[i].normalize();
      }

      normals[0] = new Vector3();
      binormals[0] = new Vector3();
      var min = Number.MAX_VALUE;
      var tx = Math.abs(tangents[0].x);
      var ty = Math.abs(tangents[0].y);
      var tz = Math.abs(tangents[0].z);

      if (tx <= min) {
        min = tx;
        normal.set(1, 0, 0);
      }

      if (ty <= min) {
        min = ty;
        normal.set(0, 1, 0);
      }

      if (tz <= min) {
        normal.set(0, 0, 1);
      }

      vec.crossVectors(tangents[0], normal).normalize();
      normals[0].crossVectors(tangents[0], vec);
      binormals[0].crossVectors(tangents[0], normals[0]);

      for (i = 1; i <= segments; i++) {
        normals[i] = normals[i - 1].clone();
        binormals[i] = binormals[i - 1].clone();
        vec.crossVectors(tangents[i - 1], tangents[i]);

        if (vec.length() > Number.EPSILON) {
          vec.normalize();
          theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
          normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }

        binormals[i].crossVectors(tangents[i], normals[i]);
      }

      if (closed === true) {
        theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
        theta /= segments;

        if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
          theta = -theta;
        }

        for (i = 1; i <= segments; i++) {
          normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
          binormals[i].crossVectors(tangents[i], normals[i]);
        }
      }

      return {
        tangents: tangents,
        normals: normals,
        binormals: binormals
      };
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(source) {
      this.arcLengthDivisions = source.arcLengthDivisions;
      return this;
    },
    toJSON: function toJSON() {
      var data = {
        metadata: {
          version: 4.5,
          type: 'Curve',
          generator: 'Curve.toJSON'
        }
      };
      data.arcLengthDivisions = this.arcLengthDivisions;
      data.type = this.type;
      return data;
    },
    fromJSON: function fromJSON(json) {
      this.arcLengthDivisions = json.arcLengthDivisions;
      return this;
    }
  });

  function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    Curve.call(this);
    this.type = 'EllipseCurve';
    this.aX = aX || 0;
    this.aY = aY || 0;
    this.xRadius = xRadius || 1;
    this.yRadius = yRadius || 1;
    this.aStartAngle = aStartAngle || 0;
    this.aEndAngle = aEndAngle || 2 * Math.PI;
    this.aClockwise = aClockwise || false;
    this.aRotation = aRotation || 0;
  }

  EllipseCurve.prototype = Object.create(Curve.prototype);
  EllipseCurve.prototype.constructor = EllipseCurve;
  EllipseCurve.prototype.isEllipseCurve = true;

  EllipseCurve.prototype.getPoint = function (t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var twoPi = Math.PI * 2;
    var deltaAngle = this.aEndAngle - this.aStartAngle;
    var samePoints = Math.abs(deltaAngle) < Number.EPSILON;

    while (deltaAngle < 0) {
      deltaAngle += twoPi;
    }

    while (deltaAngle > twoPi) {
      deltaAngle -= twoPi;
    }

    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }

    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }

    var angle = this.aStartAngle + t * deltaAngle;
    var x = this.aX + this.xRadius * Math.cos(angle);
    var y = this.aY + this.yRadius * Math.sin(angle);

    if (this.aRotation !== 0) {
      var cos = Math.cos(this.aRotation);
      var sin = Math.sin(this.aRotation);
      var tx = x - this.aX;
      var ty = y - this.aY;
      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }

    return point.set(x, y);
  };

  EllipseCurve.prototype.copy = function (source) {
    Curve.prototype.copy.call(this, source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  };

  EllipseCurve.prototype.toJSON = function () {
    var data = Curve.prototype.toJSON.call(this);
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  };

  EllipseCurve.prototype.fromJSON = function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  };

  function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = 'ArcCurve';
  }

  ArcCurve.prototype = Object.create(EllipseCurve.prototype);
  ArcCurve.prototype.constructor = ArcCurve;
  ArcCurve.prototype.isArcCurve = true;

  function CubicPoly() {
    var c0 = 0,
        c1 = 0,
        c2 = 0,
        c3 = 0;

    function init(x0, x1, t0, t1) {
      c0 = x0;
      c1 = t0;
      c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
      c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }

    return {
      initCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {
        init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
      },
      initNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
        var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1;
        t2 *= dt1;
        init(x1, x2, t1, t2);
      },
      calc: function calc(t) {
        var t2 = t * t;
        var t3 = t2 * t;
        return c0 + c1 * t + c2 * t2 + c3 * t3;
      }
    };
  }

  var tmp = new Vector3();
  var px = new CubicPoly(),
      py = new CubicPoly(),
      pz = new CubicPoly();

  function CatmullRomCurve3(points, closed, curveType, tension) {
    Curve.call(this);
    this.type = 'CatmullRomCurve3';
    this.points = points || [];
    this.closed = closed || false;
    this.curveType = curveType || 'centripetal';
    this.tension = tension || 0.5;
  }

  CatmullRomCurve3.prototype = Object.create(Curve.prototype);
  CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
  CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

  CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {
    var point = optionalTarget || new Vector3();
    var points = this.points;
    var l = points.length;
    var p = (l - (this.closed ? 0 : 1)) * t;
    var intPoint = Math.floor(p);
    var weight = p - intPoint;

    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }

    var p0, p1, p2, p3;

    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }

    p1 = points[intPoint % l];
    p2 = points[(intPoint + 1) % l];

    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }

    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
      var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
      var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
      var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
      if (dt1 < 1e-4) dt1 = 1.0;
      if (dt0 < 1e-4) dt0 = dt1;
      if (dt2 < 1e-4) dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === 'catmullrom') {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }

    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  };

  CatmullRomCurve3.prototype.copy = function (source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];

    for (var i = 0, l = source.points.length; i < l; i++) {
      var point = source.points[i];
      this.points.push(point.clone());
    }

    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  };

  CatmullRomCurve3.prototype.toJSON = function () {
    var data = Curve.prototype.toJSON.call(this);
    data.points = [];

    for (var i = 0, l = this.points.length; i < l; i++) {
      var point = this.points[i];
      data.points.push(point.toArray());
    }

    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  };

  CatmullRomCurve3.prototype.fromJSON = function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];

    for (var i = 0, l = json.points.length; i < l; i++) {
      var point = json.points[i];
      this.points.push(new Vector3().fromArray(point));
    }

    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  };

  function CatmullRom(t, p0, p1, p2, p3) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
  }

  function QuadraticBezierP0(t, p) {
    var k = 1 - t;
    return k * k * p;
  }

  function QuadraticBezierP1(t, p) {
    return 2 * (1 - t) * t * p;
  }

  function QuadraticBezierP2(t, p) {
    return t * t * p;
  }

  function QuadraticBezier(t, p0, p1, p2) {
    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
  }

  function CubicBezierP0(t, p) {
    var k = 1 - t;
    return k * k * k * p;
  }

  function CubicBezierP1(t, p) {
    var k = 1 - t;
    return 3 * k * k * t * p;
  }

  function CubicBezierP2(t, p) {
    return 3 * (1 - t) * t * t * p;
  }

  function CubicBezierP3(t, p) {
    return t * t * t * p;
  }

  function CubicBezier(t, p0, p1, p2, p3) {
    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
  }

  function CubicBezierCurve(v0, v1, v2, v3) {
    Curve.call(this);
    this.type = 'CubicBezierCurve';
    this.v0 = v0 || new Vector2();
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
    this.v3 = v3 || new Vector2();
  }

  CubicBezierCurve.prototype = Object.create(Curve.prototype);
  CubicBezierCurve.prototype.constructor = CubicBezierCurve;
  CubicBezierCurve.prototype.isCubicBezierCurve = true;

  CubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2,
        v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    return point;
  };

  CubicBezierCurve.prototype.copy = function (source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  };

  CubicBezierCurve.prototype.toJSON = function () {
    var data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  };

  CubicBezierCurve.prototype.fromJSON = function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  };

  function CubicBezierCurve3(v0, v1, v2, v3) {
    Curve.call(this);
    this.type = 'CubicBezierCurve3';
    this.v0 = v0 || new Vector3();
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
    this.v3 = v3 || new Vector3();
  }

  CubicBezierCurve3.prototype = Object.create(Curve.prototype);
  CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
  CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

  CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
    var point = optionalTarget || new Vector3();
    var v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2,
        v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
    return point;
  };

  CubicBezierCurve3.prototype.copy = function (source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  };

  CubicBezierCurve3.prototype.toJSON = function () {
    var data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  };

  CubicBezierCurve3.prototype.fromJSON = function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  };

  function LineCurve(v1, v2) {
    Curve.call(this);
    this.type = 'LineCurve';
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
  }

  LineCurve.prototype = Object.create(Curve.prototype);
  LineCurve.prototype.constructor = LineCurve;
  LineCurve.prototype.isLineCurve = true;

  LineCurve.prototype.getPoint = function (t, optionalTarget) {
    var point = optionalTarget || new Vector2();

    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }

    return point;
  };

  LineCurve.prototype.getPointAt = function (u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  };

  LineCurve.prototype.getTangent = function () {
    var tangent = this.v2.clone().sub(this.v1);
    return tangent.normalize();
  };

  LineCurve.prototype.copy = function (source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  };

  LineCurve.prototype.toJSON = function () {
    var data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  };

  LineCurve.prototype.fromJSON = function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  };

  function LineCurve3(v1, v2) {
    Curve.call(this);
    this.type = 'LineCurve3';
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
  }

  LineCurve3.prototype = Object.create(Curve.prototype);
  LineCurve3.prototype.constructor = LineCurve3;
  LineCurve3.prototype.isLineCurve3 = true;

  LineCurve3.prototype.getPoint = function (t, optionalTarget) {
    var point = optionalTarget || new Vector3();

    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }

    return point;
  };

  LineCurve3.prototype.getPointAt = function (u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  };

  LineCurve3.prototype.copy = function (source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  };

  LineCurve3.prototype.toJSON = function () {
    var data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  };

  LineCurve3.prototype.fromJSON = function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  };

  function QuadraticBezierCurve(v0, v1, v2) {
    Curve.call(this);
    this.type = 'QuadraticBezierCurve';
    this.v0 = v0 || new Vector2();
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
  }

  QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
  QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
  QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

  QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    return point;
  };

  QuadraticBezierCurve.prototype.copy = function (source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  };

  QuadraticBezierCurve.prototype.toJSON = function () {
    var data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  };

  QuadraticBezierCurve.prototype.fromJSON = function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  };

  function QuadraticBezierCurve3(v0, v1, v2) {
    Curve.call(this);
    this.type = 'QuadraticBezierCurve3';
    this.v0 = v0 || new Vector3();
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
  }

  QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
  QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
  QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

  QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
    var point = optionalTarget || new Vector3();
    var v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    return point;
  };

  QuadraticBezierCurve3.prototype.copy = function (source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  };

  QuadraticBezierCurve3.prototype.toJSON = function () {
    var data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  };

  QuadraticBezierCurve3.prototype.fromJSON = function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  };

  function SplineCurve(points) {
    Curve.call(this);
    this.type = 'SplineCurve';
    this.points = points || [];
  }

  SplineCurve.prototype = Object.create(Curve.prototype);
  SplineCurve.prototype.constructor = SplineCurve;
  SplineCurve.prototype.isSplineCurve = true;

  SplineCurve.prototype.getPoint = function (t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var points = this.points;
    var p = (points.length - 1) * t;
    var intPoint = Math.floor(p);
    var weight = p - intPoint;
    var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    var p1 = points[intPoint];
    var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
    return point;
  };

  SplineCurve.prototype.copy = function (source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];

    for (var i = 0, l = source.points.length; i < l; i++) {
      var point = source.points[i];
      this.points.push(point.clone());
    }

    return this;
  };

  SplineCurve.prototype.toJSON = function () {
    var data = Curve.prototype.toJSON.call(this);
    data.points = [];

    for (var i = 0, l = this.points.length; i < l; i++) {
      var point = this.points[i];
      data.points.push(point.toArray());
    }

    return data;
  };

  SplineCurve.prototype.fromJSON = function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];

    for (var i = 0, l = json.points.length; i < l; i++) {
      var point = json.points[i];
      this.points.push(new Vector2().fromArray(point));
    }

    return this;
  };

  var Curves = Object.freeze({
    __proto__: null,
    ArcCurve: ArcCurve,
    CatmullRomCurve3: CatmullRomCurve3,
    CubicBezierCurve: CubicBezierCurve,
    CubicBezierCurve3: CubicBezierCurve3,
    EllipseCurve: EllipseCurve,
    LineCurve: LineCurve,
    LineCurve3: LineCurve3,
    QuadraticBezierCurve: QuadraticBezierCurve,
    QuadraticBezierCurve3: QuadraticBezierCurve3,
    SplineCurve: SplineCurve
  });

  function CurvePath() {
    Curve.call(this);
    this.type = 'CurvePath';
    this.curves = [];
    this.autoClose = false;
  }

  CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
    constructor: CurvePath,
    add: function add(curve) {
      this.curves.push(curve);
    },
    closePath: function closePath() {
      var startPoint = this.curves[0].getPoint(0);
      var endPoint = this.curves[this.curves.length - 1].getPoint(1);

      if (!startPoint.equals(endPoint)) {
        this.curves.push(new LineCurve(endPoint, startPoint));
      }
    },
    getPoint: function getPoint(t) {
      var d = t * this.getLength();
      var curveLengths = this.getCurveLengths();
      var i = 0;

      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          var diff = curveLengths[i] - d;
          var curve = this.curves[i];
          var segmentLength = curve.getLength();
          var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
          return curve.getPointAt(u);
        }

        i++;
      }

      return null;
    },
    getLength: function getLength() {
      var lens = this.getCurveLengths();
      return lens[lens.length - 1];
    },
    updateArcLengths: function updateArcLengths() {
      this.needsUpdate = true;
      this.cacheLengths = null;
      this.getCurveLengths();
    },
    getCurveLengths: function getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
        return this.cacheLengths;
      }

      var lengths = [],
          sums = 0;

      for (var i = 0, l = this.curves.length; i < l; i++) {
        sums += this.curves[i].getLength();
        lengths.push(sums);
      }

      this.cacheLengths = lengths;
      return lengths;
    },
    getSpacedPoints: function getSpacedPoints(divisions) {
      if (divisions === undefined) divisions = 40;
      var points = [];

      for (var i = 0; i <= divisions; i++) {
        points.push(this.getPoint(i / divisions));
      }

      if (this.autoClose) {
        points.push(points[0]);
      }

      return points;
    },
    getPoints: function getPoints(divisions) {
      divisions = divisions || 12;
      var points = [],
          last;

      for (var i = 0, curves = this.curves; i < curves.length; i++) {
        var curve = curves[i];
        var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
        var pts = curve.getPoints(resolution);

        for (var j = 0; j < pts.length; j++) {
          var point = pts[j];
          if (last && last.equals(point)) continue;
          points.push(point);
          last = point;
        }
      }

      if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
        points.push(points[0]);
      }

      return points;
    },
    copy: function copy(source) {
      Curve.prototype.copy.call(this, source);
      this.curves = [];

      for (var i = 0, l = source.curves.length; i < l; i++) {
        var curve = source.curves[i];
        this.curves.push(curve.clone());
      }

      this.autoClose = source.autoClose;
      return this;
    },
    toJSON: function toJSON() {
      var data = Curve.prototype.toJSON.call(this);
      data.autoClose = this.autoClose;
      data.curves = [];

      for (var i = 0, l = this.curves.length; i < l; i++) {
        var curve = this.curves[i];
        data.curves.push(curve.toJSON());
      }

      return data;
    },
    fromJSON: function fromJSON(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.autoClose = json.autoClose;
      this.curves = [];

      for (var i = 0, l = json.curves.length; i < l; i++) {
        var curve = json.curves[i];
        this.curves.push(new Curves[curve.type]().fromJSON(curve));
      }

      return this;
    }
  });

  function Path(points) {
    CurvePath.call(this);
    this.type = 'Path';
    this.currentPoint = new Vector2();

    if (points) {
      this.setFromPoints(points);
    }
  }

  Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
    constructor: Path,
    setFromPoints: function setFromPoints(points) {
      this.moveTo(points[0].x, points[0].y);

      for (var i = 1, l = points.length; i < l; i++) {
        this.lineTo(points[i].x, points[i].y);
      }

      return this;
    },
    moveTo: function moveTo(x, y) {
      this.currentPoint.set(x, y);
      return this;
    },
    lineTo: function lineTo(x, y) {
      var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
      this.curves.push(curve);
      this.currentPoint.set(x, y);
      return this;
    },
    quadraticCurveTo: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
      var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    },
    bezierCurveTo: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    },
    splineThru: function splineThru(pts) {
      var npts = [this.currentPoint.clone()].concat(pts);
      var curve = new SplineCurve(npts);
      this.curves.push(curve);
      this.currentPoint.copy(pts[pts.length - 1]);
      return this;
    },
    arc: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      var x0 = this.currentPoint.x;
      var y0 = this.currentPoint.y;
      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    },
    absarc: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    },
    ellipse: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      var x0 = this.currentPoint.x;
      var y0 = this.currentPoint.y;
      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      return this;
    },
    absellipse: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

      if (this.curves.length > 0) {
        var firstPoint = curve.getPoint(0);

        if (!firstPoint.equals(this.currentPoint)) {
          this.lineTo(firstPoint.x, firstPoint.y);
        }
      }

      this.curves.push(curve);
      var lastPoint = curve.getPoint(1);
      this.currentPoint.copy(lastPoint);
      return this;
    },
    copy: function copy(source) {
      CurvePath.prototype.copy.call(this, source);
      this.currentPoint.copy(source.currentPoint);
      return this;
    },
    toJSON: function toJSON() {
      var data = CurvePath.prototype.toJSON.call(this);
      data.currentPoint = this.currentPoint.toArray();
      return data;
    },
    fromJSON: function fromJSON(json) {
      CurvePath.prototype.fromJSON.call(this, json);
      this.currentPoint.fromArray(json.currentPoint);
      return this;
    }
  });

  function Shape(points) {
    Path.call(this, points);
    this.uuid = MathUtils.generateUUID();
    this.type = 'Shape';
    this.holes = [];
  }

  Shape.prototype = Object.assign(Object.create(Path.prototype), {
    constructor: Shape,
    getPointsHoles: function getPointsHoles(divisions) {
      var holesPts = [];

      for (var i = 0, l = this.holes.length; i < l; i++) {
        holesPts[i] = this.holes[i].getPoints(divisions);
      }

      return holesPts;
    },
    extractPoints: function extractPoints(divisions) {
      return {
        shape: this.getPoints(divisions),
        holes: this.getPointsHoles(divisions)
      };
    },
    copy: function copy(source) {
      Path.prototype.copy.call(this, source);
      this.holes = [];

      for (var i = 0, l = source.holes.length; i < l; i++) {
        var hole = source.holes[i];
        this.holes.push(hole.clone());
      }

      return this;
    },
    toJSON: function toJSON() {
      var data = Path.prototype.toJSON.call(this);
      data.uuid = this.uuid;
      data.holes = [];

      for (var i = 0, l = this.holes.length; i < l; i++) {
        var hole = this.holes[i];
        data.holes.push(hole.toJSON());
      }

      return data;
    },
    fromJSON: function fromJSON(json) {
      Path.prototype.fromJSON.call(this, json);
      this.uuid = json.uuid;
      this.holes = [];

      for (var i = 0, l = json.holes.length; i < l; i++) {
        var hole = json.holes[i];
        this.holes.push(new Path().fromJSON(hole));
      }

      return this;
    }
  });

  function Light(color, intensity) {
    Object3D.call(this);
    this.type = 'Light';
    this.color = new Color(color);
    this.intensity = intensity !== undefined ? intensity : 1;
    this.receiveShadow = undefined;
  }

  Light.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Light,
    isLight: true,
    copy: function copy(source) {
      Object3D.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.intensity = source.intensity;
      return this;
    },
    toJSON: function toJSON(meta) {
      var data = Object3D.prototype.toJSON.call(this, meta);
      data.object.color = this.color.getHex();
      data.object.intensity = this.intensity;
      if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
      if (this.distance !== undefined) data.object.distance = this.distance;
      if (this.angle !== undefined) data.object.angle = this.angle;
      if (this.decay !== undefined) data.object.decay = this.decay;
      if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
      if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
      return data;
    }
  });

  function HemisphereLight(skyColor, groundColor, intensity) {
    Light.call(this, skyColor, intensity);
    this.type = 'HemisphereLight';
    this.castShadow = undefined;
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }

  HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: HemisphereLight,
    isHemisphereLight: true,
    copy: function copy(source) {
      Light.prototype.copy.call(this, source);
      this.groundColor.copy(source.groundColor);
      return this;
    }
  });

  function LightShadow(camera) {
    this.camera = camera;
    this.bias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [new Vector4(0, 0, 1, 1)];
  }

  Object.assign(LightShadow.prototype, {
    _projScreenMatrix: new Matrix4(),
    _lightPositionWorld: new Vector3(),
    _lookTarget: new Vector3(),
    getViewportCount: function getViewportCount() {
      return this._viewportCount;
    },
    getFrustum: function getFrustum() {
      return this._frustum;
    },
    updateMatrices: function updateMatrices(light) {
      var shadowCamera = this.camera,
          shadowMatrix = this.matrix,
          projScreenMatrix = this._projScreenMatrix,
          lookTarget = this._lookTarget,
          lightPositionWorld = this._lightPositionWorld;
      lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      shadowCamera.position.copy(lightPositionWorld);
      lookTarget.setFromMatrixPosition(light.target.matrixWorld);
      shadowCamera.lookAt(lookTarget);
      shadowCamera.updateMatrixWorld();
      projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

      this._frustum.setFromProjectionMatrix(projScreenMatrix);

      shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
      shadowMatrix.multiply(shadowCamera.projectionMatrix);
      shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    },
    getViewport: function getViewport(viewportIndex) {
      return this._viewports[viewportIndex];
    },
    getFrameExtents: function getFrameExtents() {
      return this._frameExtents;
    },
    copy: function copy(source) {
      this.camera = source.camera.clone();
      this.bias = source.bias;
      this.radius = source.radius;
      this.mapSize.copy(source.mapSize);
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    toJSON: function toJSON() {
      var object = {};
      if (this.bias !== 0) object.bias = this.bias;
      if (this.radius !== 1) object.radius = this.radius;
      if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
      object.camera = this.camera.toJSON(false).object;
      delete object.camera.matrix;
      return object;
    }
  });

  function SpotLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
  }

  SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: SpotLightShadow,
    isSpotLightShadow: true,
    updateMatrices: function updateMatrices(light) {
      var camera = this.camera;
      var fov = MathUtils.RAD2DEG * 2 * light.angle;
      var aspect = this.mapSize.width / this.mapSize.height;
      var far = light.distance || camera.far;

      if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
        camera.fov = fov;
        camera.aspect = aspect;
        camera.far = far;
        camera.updateProjectionMatrix();
      }

      LightShadow.prototype.updateMatrices.call(this, light);
    }
  });

  function SpotLight(color, intensity, distance, angle, penumbra, decay) {
    Light.call(this, color, intensity);
    this.type = 'SpotLight';
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    Object.defineProperty(this, 'power', {
      get: function get() {
        return this.intensity * Math.PI;
      },
      set: function set(power) {
        this.intensity = power / Math.PI;
      }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.angle = angle !== undefined ? angle : Math.PI / 3;
    this.penumbra = penumbra !== undefined ? penumbra : 0;
    this.decay = decay !== undefined ? decay : 1;
    this.shadow = new SpotLightShadow();
  }

  SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: SpotLight,
    isSpotLight: true,
    copy: function copy(source) {
      Light.prototype.copy.call(this, source);
      this.distance = source.distance;
      this.angle = source.angle;
      this.penumbra = source.penumbra;
      this.decay = source.decay;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  });

  function PointLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)];
    this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
    this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
  }

  PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: PointLightShadow,
    isPointLightShadow: true,
    updateMatrices: function updateMatrices(light, viewportIndex) {
      if (viewportIndex === undefined) viewportIndex = 0;
      var camera = this.camera,
          shadowMatrix = this.matrix,
          lightPositionWorld = this._lightPositionWorld,
          lookTarget = this._lookTarget,
          projScreenMatrix = this._projScreenMatrix;
      lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      camera.position.copy(lightPositionWorld);
      lookTarget.copy(camera.position);
      lookTarget.add(this._cubeDirections[viewportIndex]);
      camera.up.copy(this._cubeUps[viewportIndex]);
      camera.lookAt(lookTarget);
      camera.updateMatrixWorld();
      shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
      projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

      this._frustum.setFromProjectionMatrix(projScreenMatrix);
    }
  });

  function PointLight(color, intensity, distance, decay) {
    Light.call(this, color, intensity);
    this.type = 'PointLight';
    Object.defineProperty(this, 'power', {
      get: function get() {
        return this.intensity * 4 * Math.PI;
      },
      set: function set(power) {
        this.intensity = power / (4 * Math.PI);
      }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.decay = decay !== undefined ? decay : 1;
    this.shadow = new PointLightShadow();
  }

  PointLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: PointLight,
    isPointLight: true,
    copy: function copy(source) {
      Light.prototype.copy.call(this, source);
      this.distance = source.distance;
      this.decay = source.decay;
      this.shadow = source.shadow.clone();
      return this;
    }
  });

  function OrthographicCamera(left, right, top, bottom, near, far) {
    Camera.call(this);
    this.type = 'OrthographicCamera';
    this.zoom = 1;
    this.view = null;
    this.left = left !== undefined ? left : -1;
    this.right = right !== undefined ? right : 1;
    this.top = top !== undefined ? top : 1;
    this.bottom = bottom !== undefined ? bottom : -1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.updateProjectionMatrix();
  }

  OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: OrthographicCamera,
    isOrthographicCamera: true,
    copy: function copy(source, recursive) {
      Camera.prototype.copy.call(this, source, recursive);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      return this;
    },
    setViewOffset: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }

      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    },
    clearViewOffset: function clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }

      this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function updateProjectionMatrix() {
      var dx = (this.right - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.right + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      var left = cx - dx;
      var right = cx + dx;
      var top = cy + dy;
      var bottom = cy - dy;

      if (this.view !== null && this.view.enabled) {
        var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }

      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
      this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function toJSON(meta) {
      var data = Object3D.prototype.toJSON.call(this, meta);
      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      if (this.view !== null) data.object.view = Object.assign({}, this.view);
      return data;
    }
  });

  function DirectionalLightShadow() {
    LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }

  DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: DirectionalLightShadow,
    isDirectionalLightShadow: true,
    updateMatrices: function updateMatrices(light) {
      LightShadow.prototype.updateMatrices.call(this, light);
    }
  });

  function DirectionalLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = 'DirectionalLight';
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }

  DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: DirectionalLight,
    isDirectionalLight: true,
    copy: function copy(source) {
      Light.prototype.copy.call(this, source);
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  });

  function AmbientLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = 'AmbientLight';
    this.castShadow = undefined;
  }

  AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: AmbientLight,
    isAmbientLight: true
  });

  function RectAreaLight(color, intensity, width, height) {
    Light.call(this, color, intensity);
    this.type = 'RectAreaLight';
    this.width = width !== undefined ? width : 10;
    this.height = height !== undefined ? height : 10;
  }

  RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: RectAreaLight,
    isRectAreaLight: true,
    copy: function copy(source) {
      Light.prototype.copy.call(this, source);
      this.width = source.width;
      this.height = source.height;
      return this;
    },
    toJSON: function toJSON(meta) {
      var data = Light.prototype.toJSON.call(this, meta);
      data.object.width = this.width;
      data.object.height = this.height;
      return data;
    }
  });

  function MaterialLoader(manager) {
    Loader.call(this, manager);
    this.textures = {};
  }

  MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: MaterialLoader,
    load: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.load(url, function (text) {
        onLoad(scope.parse(JSON.parse(text)));
      }, onProgress, onError);
    },
    parse: function parse(json) {
      var textures = this.textures;

      function getTexture(name) {
        if (textures[name] === undefined) {
          console.warn('THREE.MaterialLoader: Undefined texture', name);
        }

        return textures[name];
      }

      var material = new Materials[json.type]();
      if (json.uuid !== undefined) material.uuid = json.uuid;
      if (json.name !== undefined) material.name = json.name;
      if (json.color !== undefined) material.color.setHex(json.color);
      if (json.roughness !== undefined) material.roughness = json.roughness;
      if (json.metalness !== undefined) material.metalness = json.metalness;
      if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
      if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
      if (json.specular !== undefined) material.specular.setHex(json.specular);
      if (json.shininess !== undefined) material.shininess = json.shininess;
      if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
      if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
      if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;
      if (json.fog !== undefined) material.fog = json.fog;
      if (json.flatShading !== undefined) material.flatShading = json.flatShading;
      if (json.blending !== undefined) material.blending = json.blending;
      if (json.combine !== undefined) material.combine = json.combine;
      if (json.side !== undefined) material.side = json.side;
      if (json.opacity !== undefined) material.opacity = json.opacity;
      if (json.transparent !== undefined) material.transparent = json.transparent;
      if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
      if (json.depthTest !== undefined) material.depthTest = json.depthTest;
      if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
      if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
      if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
      if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
      if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
      if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
      if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
      if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
      if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
      if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
      if (json.wireframe !== undefined) material.wireframe = json.wireframe;
      if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
      if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
      if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
      if (json.rotation !== undefined) material.rotation = json.rotation;
      if (json.linewidth !== 1) material.linewidth = json.linewidth;
      if (json.dashSize !== undefined) material.dashSize = json.dashSize;
      if (json.gapSize !== undefined) material.gapSize = json.gapSize;
      if (json.scale !== undefined) material.scale = json.scale;
      if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
      if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
      if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
      if (json.skinning !== undefined) material.skinning = json.skinning;
      if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
      if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
      if (json.dithering !== undefined) material.dithering = json.dithering;
      if (json.visible !== undefined) material.visible = json.visible;
      if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
      if (json.userData !== undefined) material.userData = json.userData;

      if (json.uniforms !== undefined) {
        for (var name in json.uniforms) {
          var uniform = json.uniforms[name];
          material.uniforms[name] = {};

          switch (uniform.type) {
            case 't':
              material.uniforms[name].value = getTexture(uniform.value);
              break;

            case 'c':
              material.uniforms[name].value = new Color().setHex(uniform.value);
              break;

            case 'v2':
              material.uniforms[name].value = new Vector2().fromArray(uniform.value);
              break;

            case 'v3':
              material.uniforms[name].value = new Vector3().fromArray(uniform.value);
              break;

            case 'v4':
              material.uniforms[name].value = new Vector4().fromArray(uniform.value);
              break;

            case 'm3':
              material.uniforms[name].value = new Matrix3().fromArray(uniform.value);

            case 'm4':
              material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
              break;

            default:
              material.uniforms[name].value = uniform.value;
          }
        }
      }

      if (json.defines !== undefined) material.defines = json.defines;
      if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
      if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

      if (json.extensions !== undefined) {
        for (var key in json.extensions) {
          material.extensions[key] = json.extensions[key];
        }
      }

      if (json.shading !== undefined) material.flatShading = json.shading === 1;
      if (json.size !== undefined) material.size = json.size;
      if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
      if (json.map !== undefined) material.map = getTexture(json.map);
      if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);

      if (json.alphaMap !== undefined) {
        material.alphaMap = getTexture(json.alphaMap);
        material.transparent = true;
      }

      if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
      if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
      if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
      if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

      if (json.normalScale !== undefined) {
        var normalScale = json.normalScale;

        if (Array.isArray(normalScale) === false) {
          normalScale = [normalScale, normalScale];
        }

        material.normalScale = new Vector2().fromArray(normalScale);
      }

      if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
      if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
      if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
      if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
      if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
      if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
      if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
      if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
      if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
      if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
      if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
      if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
      if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
      if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
      if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
      if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
      if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
      if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
      if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
      return material;
    },
    setTextures: function setTextures(value) {
      this.textures = value;
      return this;
    }
  });
  var LoaderUtils = {
    decodeText: function decodeText(array) {
      if (typeof TextDecoder !== 'undefined') {
        return new TextDecoder().decode(array);
      }

      var s = '';

      for (var i = 0, il = array.length; i < il; i++) {
        s += String.fromCharCode(array[i]);
      }

      try {
        return decodeURIComponent(escape(s));
      } catch (e) {
        return s;
      }
    },
    extractUrlBase: function extractUrlBase(url) {
      var index = url.lastIndexOf('/');
      if (index === -1) return './';
      return url.substr(0, index + 1);
    }
  };

  function InstancedBufferGeometry() {
    BufferGeometry.call(this);
    this.type = 'InstancedBufferGeometry';
    this.maxInstancedCount = undefined;
  }

  InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
    constructor: InstancedBufferGeometry,
    isInstancedBufferGeometry: true,
    copy: function copy(source) {
      BufferGeometry.prototype.copy.call(this, source);
      this.maxInstancedCount = source.maxInstancedCount;
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    toJSON: function toJSON() {
      var data = BufferGeometry.prototype.toJSON.call(this);
      data.maxInstancedCount = this.maxInstancedCount;
      data.isInstancedBufferGeometry = true;
      return data;
    }
  });

  function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
    if (typeof normalized === 'number') {
      meshPerAttribute = normalized;
      normalized = false;
      console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
    }

    BufferAttribute.call(this, array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute || 1;
  }

  InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
    constructor: InstancedBufferAttribute,
    isInstancedBufferAttribute: true,
    copy: function copy(source) {
      BufferAttribute.prototype.copy.call(this, source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    },
    toJSON: function toJSON() {
      var data = BufferAttribute.prototype.toJSON.call(this);
      data.meshPerAttribute = this.meshPerAttribute;
      data.isInstancedBufferAttribute = true;
      return data;
    }
  });

  function BufferGeometryLoader(manager) {
    Loader.call(this, manager);
  }

  BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: BufferGeometryLoader,
    load: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.load(url, function (text) {
        onLoad(scope.parse(JSON.parse(text)));
      }, onProgress, onError);
    },
    parse: function parse(json) {
      var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
      var index = json.data.index;

      if (index !== undefined) {
        var typedArray = new TYPED_ARRAYS[index.type](index.array);
        geometry.setIndex(new BufferAttribute(typedArray, 1));
      }

      var attributes = json.data.attributes;

      for (var key in attributes) {
        var attribute = attributes[key];
        var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
        var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        var bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
        if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
        geometry.setAttribute(key, bufferAttribute);
      }

      var morphAttributes = json.data.morphAttributes;

      if (morphAttributes) {
        for (var key in morphAttributes) {
          var attributeArray = morphAttributes[key];
          var array = [];

          for (var i = 0, il = attributeArray.length; i < il; i++) {
            var attribute = attributeArray[i];
            var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
            var bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
            if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
            array.push(bufferAttribute);
          }

          geometry.morphAttributes[key] = array;
        }
      }

      var morphTargetsRelative = json.data.morphTargetsRelative;

      if (morphTargetsRelative) {
        geometry.morphTargetsRelative = true;
      }

      var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

      if (groups !== undefined) {
        for (var i = 0, n = groups.length; i !== n; ++i) {
          var group = groups[i];
          geometry.addGroup(group.start, group.count, group.materialIndex);
        }
      }

      var boundingSphere = json.data.boundingSphere;

      if (boundingSphere !== undefined) {
        var center = new Vector3();

        if (boundingSphere.center !== undefined) {
          center.fromArray(boundingSphere.center);
        }

        geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
      }

      if (json.name) geometry.name = json.name;
      if (json.userData) geometry.userData = json.userData;
      return geometry;
    }
  });
  var TYPED_ARRAYS = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
  };

  function ObjectLoader(manager) {
    Loader.call(this, manager);
  }

  ObjectLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ObjectLoader,
    load: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
      this.resourcePath = this.resourcePath || path;
      var loader = new FileLoader(scope.manager);
      loader.setPath(this.path);
      loader.load(url, function (text) {
        var json = null;

        try {
          json = JSON.parse(text);
        } catch (error) {
          if (onError !== undefined) onError(error);
          console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
          return;
        }

        var metadata = json.metadata;

        if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
          console.error('THREE.ObjectLoader: Can\'t load ' + url);
          return;
        }

        scope.parse(json, onLoad);
      }, onProgress, onError);
    },
    parse: function parse(json, onLoad) {
      var shapes = this.parseShape(json.shapes);
      var geometries = this.parseGeometries(json.geometries, shapes);
      var images = this.parseImages(json.images, function () {
        if (onLoad !== undefined) onLoad(object);
      });
      var textures = this.parseTextures(json.textures, images);
      var materials = this.parseMaterials(json.materials, textures);
      var object = this.parseObject(json.object, geometries, materials);

      if (json.animations) {
        object.animations = this.parseAnimations(json.animations);
      }

      if (json.images === undefined || json.images.length === 0) {
        if (onLoad !== undefined) onLoad(object);
      }

      return object;
    },
    parseShape: function parseShape(json) {
      var shapes = {};

      if (json !== undefined) {
        for (var i = 0, l = json.length; i < l; i++) {
          var shape = new Shape().fromJSON(json[i]);
          shapes[shape.uuid] = shape;
        }
      }

      return shapes;
    },
    parseGeometries: function parseGeometries(json, shapes) {
      var geometries = {};

      if (json !== undefined) {
        var bufferGeometryLoader = new BufferGeometryLoader();

        for (var i = 0, l = json.length; i < l; i++) {
          var geometry;
          var data = json[i];

          switch (data.type) {
            case 'PlaneGeometry':
            case 'PlaneBufferGeometry':
              geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
              break;

            case 'BoxGeometry':
            case 'BoxBufferGeometry':
            case 'CubeGeometry':
              geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
              break;

            case 'CircleGeometry':
            case 'CircleBufferGeometry':
              geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
              break;

            case 'CylinderGeometry':
            case 'CylinderBufferGeometry':
              geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
              break;

            case 'ConeGeometry':
            case 'ConeBufferGeometry':
              geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
              break;

            case 'SphereGeometry':
            case 'SphereBufferGeometry':
              geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
              break;

            case 'DodecahedronGeometry':
            case 'DodecahedronBufferGeometry':
            case 'IcosahedronGeometry':
            case 'IcosahedronBufferGeometry':
            case 'OctahedronGeometry':
            case 'OctahedronBufferGeometry':
            case 'TetrahedronGeometry':
            case 'TetrahedronBufferGeometry':
              geometry = new Geometries[data.type](data.radius, data.detail);
              break;

            case 'RingGeometry':
            case 'RingBufferGeometry':
              geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
              break;

            case 'TorusGeometry':
            case 'TorusBufferGeometry':
              geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
              break;

            case 'TorusKnotGeometry':
            case 'TorusKnotBufferGeometry':
              geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
              break;

            case 'TubeGeometry':
            case 'TubeBufferGeometry':
              geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
              break;

            case 'LatheGeometry':
            case 'LatheBufferGeometry':
              geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
              break;

            case 'PolyhedronGeometry':
            case 'PolyhedronBufferGeometry':
              geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
              break;

            case 'ShapeGeometry':
            case 'ShapeBufferGeometry':
              var geometryShapes = [];

              for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                var shape = shapes[data.shapes[j]];
                geometryShapes.push(shape);
              }

              geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
              break;

            case 'ExtrudeGeometry':
            case 'ExtrudeBufferGeometry':
              var geometryShapes = [];

              for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                var shape = shapes[data.shapes[j]];
                geometryShapes.push(shape);
              }

              var extrudePath = data.options.extrudePath;

              if (extrudePath !== undefined) {
                data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
              }

              geometry = new Geometries[data.type](geometryShapes, data.options);
              break;

            case 'BufferGeometry':
            case 'InstancedBufferGeometry':
              geometry = bufferGeometryLoader.parse(data);
              break;

            case 'Geometry':
              if ('THREE' in window && 'LegacyJSONLoader' in THREE) {
                var geometryLoader = new THREE.LegacyJSONLoader();
                geometry = geometryLoader.parse(data, this.resourcePath).geometry;
              } else {
                console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
              }

              break;

            default:
              console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
              continue;
          }

          geometry.uuid = data.uuid;
          if (data.name !== undefined) geometry.name = data.name;
          if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
          geometries[data.uuid] = geometry;
        }
      }

      return geometries;
    },
    parseMaterials: function parseMaterials(json, textures) {
      var cache = {};
      var materials = {};

      if (json !== undefined) {
        var loader = new MaterialLoader();
        loader.setTextures(textures);

        for (var i = 0, l = json.length; i < l; i++) {
          var data = json[i];

          if (data.type === 'MultiMaterial') {
            var array = [];

            for (var j = 0; j < data.materials.length; j++) {
              var material = data.materials[j];

              if (cache[material.uuid] === undefined) {
                cache[material.uuid] = loader.parse(material);
              }

              array.push(cache[material.uuid]);
            }

            materials[data.uuid] = array;
          } else {
            if (cache[data.uuid] === undefined) {
              cache[data.uuid] = loader.parse(data);
            }

            materials[data.uuid] = cache[data.uuid];
          }
        }
      }

      return materials;
    },
    parseAnimations: function parseAnimations(json) {
      var animations = [];

      for (var i = 0; i < json.length; i++) {
        var data = json[i];
        var clip = AnimationClip.parse(data);
        if (data.uuid !== undefined) clip.uuid = data.uuid;
        animations.push(clip);
      }

      return animations;
    },
    parseImages: function parseImages(json, onLoad) {
      var scope = this;
      var images = {};

      function loadImage(url) {
        scope.manager.itemStart(url);
        return loader.load(url, function () {
          scope.manager.itemEnd(url);
        }, undefined, function () {
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        });
      }

      if (json !== undefined && json.length > 0) {
        var manager = new LoadingManager(onLoad);
        var loader = new ImageLoader(manager);
        loader.setCrossOrigin(this.crossOrigin);

        for (var i = 0, il = json.length; i < il; i++) {
          var image = json[i];
          var url = image.url;

          if (Array.isArray(url)) {
            images[image.uuid] = [];

            for (var j = 0, jl = url.length; j < jl; j++) {
              var currentUrl = url[j];
              var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
              images[image.uuid].push(loadImage(path));
            }
          } else {
            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;
            images[image.uuid] = loadImage(path);
          }
        }
      }

      return images;
    },
    parseTextures: function parseTextures(json, images) {
      function parseConstant(value, type) {
        if (typeof value === 'number') return value;
        console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
        return type[value];
      }

      var textures = {};

      if (json !== undefined) {
        for (var i = 0, l = json.length; i < l; i++) {
          var data = json[i];

          if (data.image === undefined) {
            console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
          }

          if (images[data.image] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined image', data.image);
          }

          var texture;

          if (Array.isArray(images[data.image])) {
            texture = new CubeTexture(images[data.image]);
          } else {
            texture = new Texture(images[data.image]);
          }

          texture.needsUpdate = true;
          texture.uuid = data.uuid;
          if (data.name !== undefined) texture.name = data.name;
          if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
          if (data.offset !== undefined) texture.offset.fromArray(data.offset);
          if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
          if (data.center !== undefined) texture.center.fromArray(data.center);
          if (data.rotation !== undefined) texture.rotation = data.rotation;

          if (data.wrap !== undefined) {
            texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
            texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
          }

          if (data.format !== undefined) texture.format = data.format;
          if (data.type !== undefined) texture.type = data.type;
          if (data.encoding !== undefined) texture.encoding = data.encoding;
          if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
          if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
          if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
          if (data.flipY !== undefined) texture.flipY = data.flipY;
          if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
          if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
          textures[data.uuid] = texture;
        }
      }

      return textures;
    },
    parseObject: function parseObject(data, geometries, materials) {
      var object;

      function getGeometry(name) {
        if (geometries[name] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined geometry', name);
        }

        return geometries[name];
      }

      function getMaterial(name) {
        if (name === undefined) return undefined;

        if (Array.isArray(name)) {
          var array = [];

          for (var i = 0, l = name.length; i < l; i++) {
            var uuid = name[i];

            if (materials[uuid] === undefined) {
              console.warn('THREE.ObjectLoader: Undefined material', uuid);
            }

            array.push(materials[uuid]);
          }

          return array;
        }

        if (materials[name] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined material', name);
        }

        return materials[name];
      }

      switch (data.type) {
        case 'Scene':
          object = new Scene();

          if (data.background !== undefined) {
            if (Number.isInteger(data.background)) {
              object.background = new Color(data.background);
            }
          }

          if (data.fog !== undefined) {
            if (data.fog.type === 'Fog') {
              object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
            } else if (data.fog.type === 'FogExp2') {
              object.fog = new FogExp2(data.fog.color, data.fog.density);
            }
          }

          break;

        case 'PerspectiveCamera':
          object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
          if (data.focus !== undefined) object.focus = data.focus;
          if (data.zoom !== undefined) object.zoom = data.zoom;
          if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
          if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
          if (data.view !== undefined) object.view = Object.assign({}, data.view);
          break;

        case 'OrthographicCamera':
          object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
          if (data.zoom !== undefined) object.zoom = data.zoom;
          if (data.view !== undefined) object.view = Object.assign({}, data.view);
          break;

        case 'AmbientLight':
          object = new AmbientLight(data.color, data.intensity);
          break;

        case 'DirectionalLight':
          object = new DirectionalLight(data.color, data.intensity);
          break;

        case 'PointLight':
          object = new PointLight(data.color, data.intensity, data.distance, data.decay);
          break;

        case 'RectAreaLight':
          object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
          break;

        case 'SpotLight':
          object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
          break;

        case 'HemisphereLight':
          object = new HemisphereLight(data.color, data.groundColor, data.intensity);
          break;

        case 'SkinnedMesh':
          console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');

        case 'Mesh':
          var geometry = getGeometry(data.geometry);
          var material = getMaterial(data.material);

          if (geometry.bones && geometry.bones.length > 0) {
            object = new SkinnedMesh(geometry, material);
          } else {
            object = new Mesh(geometry, material);
          }

          break;

        case 'InstancedMesh':
          var geometry = getGeometry(data.geometry);
          var material = getMaterial(data.material);
          var count = data.count;
          var instanceMatrix = data.instanceMatrix;
          object = new InstancedMesh(geometry, material, count);
          object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
          break;

        case 'LOD':
          object = new LOD();
          break;

        case 'Line':
          object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
          break;

        case 'LineLoop':
          object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
          break;

        case 'LineSegments':
          object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
          break;

        case 'PointCloud':
        case 'Points':
          object = new Points(getGeometry(data.geometry), getMaterial(data.material));
          break;

        case 'Sprite':
          object = new Sprite(getMaterial(data.material));
          break;

        case 'Group':
          object = new Group();
          break;

        default:
          object = new Object3D();
      }

      object.uuid = data.uuid;
      if (data.name !== undefined) object.name = data.name;

      if (data.matrix !== undefined) {
        object.matrix.fromArray(data.matrix);
        if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
        if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
      } else {
        if (data.position !== undefined) object.position.fromArray(data.position);
        if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
        if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
        if (data.scale !== undefined) object.scale.fromArray(data.scale);
      }

      if (data.castShadow !== undefined) object.castShadow = data.castShadow;
      if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

      if (data.shadow) {
        if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
        if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
        if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
        if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
      }

      if (data.visible !== undefined) object.visible = data.visible;
      if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
      if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
      if (data.userData !== undefined) object.userData = data.userData;
      if (data.layers !== undefined) object.layers.mask = data.layers;

      if (data.children !== undefined) {
        var children = data.children;

        for (var i = 0; i < children.length; i++) {
          object.add(this.parseObject(children[i], geometries, materials));
        }
      }

      if (data.type === 'LOD') {
        if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
        var levels = data.levels;

        for (var l = 0; l < levels.length; l++) {
          var level = levels[l];
          var child = object.getObjectByProperty('uuid', level.object);

          if (child !== undefined) {
            object.addLevel(child, level.distance);
          }
        }
      }

      return object;
    }
  });
  var TEXTURE_MAPPING = {
    UVMapping: UVMapping,
    CubeReflectionMapping: CubeReflectionMapping,
    CubeRefractionMapping: CubeRefractionMapping,
    EquirectangularReflectionMapping: EquirectangularReflectionMapping,
    EquirectangularRefractionMapping: EquirectangularRefractionMapping,
    SphericalReflectionMapping: SphericalReflectionMapping,
    CubeUVReflectionMapping: CubeUVReflectionMapping,
    CubeUVRefractionMapping: CubeUVRefractionMapping
  };
  var TEXTURE_WRAPPING = {
    RepeatWrapping: RepeatWrapping,
    ClampToEdgeWrapping: ClampToEdgeWrapping,
    MirroredRepeatWrapping: MirroredRepeatWrapping
  };
  var TEXTURE_FILTER = {
    NearestFilter: NearestFilter,
    NearestMipmapNearestFilter: NearestMipmapNearestFilter,
    NearestMipmapLinearFilter: NearestMipmapLinearFilter,
    LinearFilter: LinearFilter,
    LinearMipmapNearestFilter: LinearMipmapNearestFilter,
    LinearMipmapLinearFilter: LinearMipmapLinearFilter
  };

  function ImageBitmapLoader(manager) {
    if (typeof createImageBitmap === 'undefined') {
      console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
    }

    if (typeof fetch === 'undefined') {
      console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
    }

    Loader.call(this, manager);
    this.options = undefined;
  }

  ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ImageBitmapLoader,
    setOptions: function setOptions(options) {
      this.options = options;
      return this;
    },
    load: function load(url, onLoad, onProgress, onError) {
      if (url === undefined) url = '';
      if (this.path !== undefined) url = this.path + url;
      url = this.manager.resolveURL(url);
      var scope = this;
      var cached = Cache.get(url);

      if (cached !== undefined) {
        scope.manager.itemStart(url);
        setTimeout(function () {
          if (onLoad) onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }

      fetch(url).then(function (res) {
        return res.blob();
      }).then(function (blob) {
        if (scope.options === undefined) {
          return createImageBitmap(blob);
        } else {
          return createImageBitmap(blob, scope.options);
        }
      }).then(function (imageBitmap) {
        Cache.add(url, imageBitmap);
        if (onLoad) onLoad(imageBitmap);
        scope.manager.itemEnd(url);
      })["catch"](function (e) {
        if (onError) onError(e);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
      scope.manager.itemStart(url);
    }
  });

  function ShapePath() {
    this.type = 'ShapePath';
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }

  Object.assign(ShapePath.prototype, {
    moveTo: function moveTo(x, y) {
      this.currentPath = new Path();
      this.subPaths.push(this.currentPath);
      this.currentPath.moveTo(x, y);
      return this;
    },
    lineTo: function lineTo(x, y) {
      this.currentPath.lineTo(x, y);
      return this;
    },
    quadraticCurveTo: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
      this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
      return this;
    },
    bezierCurveTo: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
      return this;
    },
    splineThru: function splineThru(pts) {
      this.currentPath.splineThru(pts);
      return this;
    },
    toShapes: function toShapes(isCCW, noHoles) {
      function toShapesNoHoles(inSubpaths) {
        var shapes = [];

        for (var i = 0, l = inSubpaths.length; i < l; i++) {
          var tmpPath = inSubpaths[i];
          var tmpShape = new Shape();
          tmpShape.curves = tmpPath.curves;
          shapes.push(tmpShape);
        }

        return shapes;
      }

      function isPointInsidePolygon(inPt, inPolygon) {
        var polyLen = inPolygon.length;
        var inside = false;

        for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
          var edgeLowPt = inPolygon[p];
          var edgeHighPt = inPolygon[q];
          var edgeDx = edgeHighPt.x - edgeLowPt.x;
          var edgeDy = edgeHighPt.y - edgeLowPt.y;

          if (Math.abs(edgeDy) > Number.EPSILON) {
            if (edgeDy < 0) {
              edgeLowPt = inPolygon[q];
              edgeDx = -edgeDx;
              edgeHighPt = inPolygon[p];
              edgeDy = -edgeDy;
            }

            if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

            if (inPt.y === edgeLowPt.y) {
              if (inPt.x === edgeLowPt.x) return true;
            } else {
              var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
              if (perpEdge === 0) return true;
              if (perpEdge < 0) continue;
              inside = !inside;
            }
          } else {
            if (inPt.y !== edgeLowPt.y) continue;
            if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true;
          }
        }

        return inside;
      }

      var isClockWise = ShapeUtils.isClockWise;
      var subPaths = this.subPaths;
      if (subPaths.length === 0) return [];
      if (noHoles === true) return toShapesNoHoles(subPaths);
      var solid,
          tmpPath,
          tmpShape,
          shapes = [];

      if (subPaths.length === 1) {
        tmpPath = subPaths[0];
        tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        return shapes;
      }

      var holesFirst = !isClockWise(subPaths[0].getPoints());
      holesFirst = isCCW ? !holesFirst : holesFirst;
      var betterShapeHoles = [];
      var newShapes = [];
      var newShapeHoles = [];
      var mainIdx = 0;
      var tmpPoints;
      newShapes[mainIdx] = undefined;
      newShapeHoles[mainIdx] = [];

      for (var i = 0, l = subPaths.length; i < l; i++) {
        tmpPath = subPaths[i];
        tmpPoints = tmpPath.getPoints();
        solid = isClockWise(tmpPoints);
        solid = isCCW ? !solid : solid;

        if (solid) {
          if (!holesFirst && newShapes[mainIdx]) mainIdx++;
          newShapes[mainIdx] = {
            s: new Shape(),
            p: tmpPoints
          };
          newShapes[mainIdx].s.curves = tmpPath.curves;
          if (holesFirst) mainIdx++;
          newShapeHoles[mainIdx] = [];
        } else {
          newShapeHoles[mainIdx].push({
            h: tmpPath,
            p: tmpPoints[0]
          });
        }
      }

      if (!newShapes[0]) return toShapesNoHoles(subPaths);

      if (newShapes.length > 1) {
        var ambiguous = false;
        var toChange = [];

        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
          betterShapeHoles[sIdx] = [];
        }

        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
          var sho = newShapeHoles[sIdx];

          for (var hIdx = 0; hIdx < sho.length; hIdx++) {
            var ho = sho[hIdx];
            var hole_unassigned = true;

            for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
              if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                if (sIdx !== s2Idx) toChange.push({
                  froms: sIdx,
                  tos: s2Idx,
                  hole: hIdx
                });

                if (hole_unassigned) {
                  hole_unassigned = false;
                  betterShapeHoles[s2Idx].push(ho);
                } else {
                  ambiguous = true;
                }
              }
            }

            if (hole_unassigned) {
              betterShapeHoles[sIdx].push(ho);
            }
          }
        }

        if (toChange.length > 0) {
          if (!ambiguous) newShapeHoles = betterShapeHoles;
        }
      }

      var tmpHoles;

      for (var i = 0, il = newShapes.length; i < il; i++) {
        tmpShape = newShapes[i].s;
        shapes.push(tmpShape);
        tmpHoles = newShapeHoles[i];

        for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
          tmpShape.holes.push(tmpHoles[j].h);
        }
      }

      return shapes;
    }
  });

  function Font(data) {
    this.type = 'Font';
    this.data = data;
  }

  Object.assign(Font.prototype, {
    isFont: true,
    generateShapes: function generateShapes(text, size) {
      if (size === undefined) size = 100;
      var shapes = [];
      var paths = createPaths(text, size, this.data);

      for (var p = 0, pl = paths.length; p < pl; p++) {
        Array.prototype.push.apply(shapes, paths[p].toShapes());
      }

      return shapes;
    }
  });

  function createPaths(text, size, data) {
    var chars = Array.from ? Array.from(text) : String(text).split('');
    var scale = size / data.resolution;
    var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
    var paths = [];
    var offsetX = 0,
        offsetY = 0;

    for (var i = 0; i < chars.length; i++) {
      var _char = chars[i];

      if (_char === '\n') {
        offsetX = 0;
        offsetY -= line_height;
      } else {
        var ret = createPath(_char, scale, offsetX, offsetY, data);
        offsetX += ret.offsetX;
        paths.push(ret.path);
      }
    }

    return paths;
  }

  function createPath(_char2, scale, offsetX, offsetY, data) {
    var glyph = data.glyphs[_char2] || data.glyphs['?'];

    if (!glyph) {
      console.error('THREE.Font: character "' + _char2 + '" does not exists in font family ' + data.familyName + '.');
      return;
    }

    var path = new ShapePath();
    var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

    if (glyph.o) {
      var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

      for (var i = 0, l = outline.length; i < l;) {
        var action = outline[i++];

        switch (action) {
          case 'm':
            x = outline[i++] * scale + offsetX;
            y = outline[i++] * scale + offsetY;
            path.moveTo(x, y);
            break;

          case 'l':
            x = outline[i++] * scale + offsetX;
            y = outline[i++] * scale + offsetY;
            path.lineTo(x, y);
            break;

          case 'q':
            cpx = outline[i++] * scale + offsetX;
            cpy = outline[i++] * scale + offsetY;
            cpx1 = outline[i++] * scale + offsetX;
            cpy1 = outline[i++] * scale + offsetY;
            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
            break;

          case 'b':
            cpx = outline[i++] * scale + offsetX;
            cpy = outline[i++] * scale + offsetY;
            cpx1 = outline[i++] * scale + offsetX;
            cpy1 = outline[i++] * scale + offsetY;
            cpx2 = outline[i++] * scale + offsetX;
            cpy2 = outline[i++] * scale + offsetY;
            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
            break;
        }
      }
    }

    return {
      offsetX: glyph.ha * scale,
      path: path
    };
  }

  function FontLoader(manager) {
    Loader.call(this, manager);
  }

  FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: FontLoader,
    load: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.load(url, function (text) {
        var json;

        try {
          json = JSON.parse(text);
        } catch (e) {
          console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
          json = JSON.parse(text.substring(65, text.length - 2));
        }

        var font = scope.parse(json);
        if (onLoad) onLoad(font);
      }, onProgress, onError);
    },
    parse: function parse(json) {
      return new Font(json);
    }
  });

  var _context;

  var AudioContext = {
    getContext: function getContext() {
      if (_context === undefined) {
        _context = new (window.AudioContext || window.webkitAudioContext)();
      }

      return _context;
    },
    setContext: function setContext(value) {
      _context = value;
    }
  };

  function AudioLoader(manager) {
    Loader.call(this, manager);
  }

  AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: AudioLoader,
    load: function load(url, onLoad, onProgress, onError) {
      var loader = new FileLoader(this.manager);
      loader.setResponseType('arraybuffer');
      loader.setPath(this.path);
      loader.load(url, function (buffer) {
        var bufferCopy = buffer.slice(0);
        var context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function (audioBuffer) {
          onLoad(audioBuffer);
        });
      }, onProgress, onError);
    }
  });

  function SphericalHarmonics3() {
    this.coefficients = [];

    for (var i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3());
    }
  }

  Object.assign(SphericalHarmonics3.prototype, {
    isSphericalHarmonics3: true,
    set: function set(coefficients) {
      for (var i = 0; i < 9; i++) {
        this.coefficients[i].copy(coefficients[i]);
      }

      return this;
    },
    zero: function zero() {
      for (var i = 0; i < 9; i++) {
        this.coefficients[i].set(0, 0, 0);
      }

      return this;
    },
    getAt: function getAt(normal, target) {
      var x = normal.x,
          y = normal.y,
          z = normal.z;
      var coeff = this.coefficients;
      target.copy(coeff[0]).multiplyScalar(0.282095);
      target.addScale(coeff[1], 0.488603 * y);
      target.addScale(coeff[2], 0.488603 * z);
      target.addScale(coeff[3], 0.488603 * x);
      target.addScale(coeff[4], 1.092548 * (x * y));
      target.addScale(coeff[5], 1.092548 * (y * z));
      target.addScale(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
      target.addScale(coeff[7], 1.092548 * (x * z));
      target.addScale(coeff[8], 0.546274 * (x * x - y * y));
      return target;
    },
    getIrradianceAt: function getIrradianceAt(normal, target) {
      var x = normal.x,
          y = normal.y,
          z = normal.z;
      var coeff = this.coefficients;
      target.copy(coeff[0]).multiplyScalar(0.886227);
      target.addScale(coeff[1], 2.0 * 0.511664 * y);
      target.addScale(coeff[2], 2.0 * 0.511664 * z);
      target.addScale(coeff[3], 2.0 * 0.511664 * x);
      target.addScale(coeff[4], 2.0 * 0.429043 * x * y);
      target.addScale(coeff[5], 2.0 * 0.429043 * y * z);
      target.addScale(coeff[6], 0.743125 * z * z - 0.247708);
      target.addScale(coeff[7], 2.0 * 0.429043 * x * z);
      target.addScale(coeff[8], 0.429043 * (x * x - y * y));
      return target;
    },
    add: function add(sh) {
      for (var i = 0; i < 9; i++) {
        this.coefficients[i].add(sh.coefficients[i]);
      }

      return this;
    },
    scale: function scale(s) {
      for (var i = 0; i < 9; i++) {
        this.coefficients[i].multiplyScalar(s);
      }

      return this;
    },
    lerp: function lerp(sh, alpha) {
      for (var i = 0; i < 9; i++) {
        this.coefficients[i].lerp(sh.coefficients[i], alpha);
      }

      return this;
    },
    equals: function equals(sh) {
      for (var i = 0; i < 9; i++) {
        if (!this.coefficients[i].equals(sh.coefficients[i])) {
          return false;
        }
      }

      return true;
    },
    copy: function copy(sh) {
      return this.set(sh.coefficients);
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    fromArray: function fromArray(array, offset) {
      if (offset === undefined) offset = 0;
      var coefficients = this.coefficients;

      for (var i = 0; i < 9; i++) {
        coefficients[i].fromArray(array, offset + i * 3);
      }

      return this;
    },
    toArray: function toArray(array, offset) {
      if (array === undefined) array = [];
      if (offset === undefined) offset = 0;
      var coefficients = this.coefficients;

      for (var i = 0; i < 9; i++) {
        coefficients[i].toArray(array, offset + i * 3);
      }

      return array;
    }
  });
  Object.assign(SphericalHarmonics3, {
    getBasisAt: function getBasisAt(normal, shBasis) {
      var x = normal.x,
          y = normal.y,
          z = normal.z;
      shBasis[0] = 0.282095;
      shBasis[1] = 0.488603 * y;
      shBasis[2] = 0.488603 * z;
      shBasis[3] = 0.488603 * x;
      shBasis[4] = 1.092548 * x * y;
      shBasis[5] = 1.092548 * y * z;
      shBasis[6] = 0.315392 * (3 * z * z - 1);
      shBasis[7] = 1.092548 * x * z;
      shBasis[8] = 0.546274 * (x * x - y * y);
    }
  });

  function LightProbe(sh, intensity) {
    Light.call(this, undefined, intensity);
    this.sh = sh !== undefined ? sh : new SphericalHarmonics3();
  }

  LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: LightProbe,
    isLightProbe: true,
    copy: function copy(source) {
      Light.prototype.copy.call(this, source);
      this.sh.copy(source.sh);
      this.intensity = source.intensity;
      return this;
    },
    toJSON: function toJSON(meta) {
      var data = Light.prototype.toJSON.call(this, meta);
      return data;
    }
  });

  function HemisphereLightProbe(skyColor, groundColor, intensity) {
    LightProbe.call(this, undefined, intensity);
    var color1 = new Color().set(skyColor);
    var color2 = new Color().set(groundColor);
    var sky = new Vector3(color1.r, color1.g, color1.b);
    var ground = new Vector3(color2.r, color2.g, color2.b);
    var c0 = Math.sqrt(Math.PI);
    var c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }

  HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
    constructor: HemisphereLightProbe,
    isHemisphereLightProbe: true,
    copy: function copy(source) {
      LightProbe.prototype.copy.call(this, source);
      return this;
    },
    toJSON: function toJSON(meta) {
      var data = LightProbe.prototype.toJSON.call(this, meta);
      return data;
    }
  });

  function AmbientLightProbe(color, intensity) {
    LightProbe.call(this, undefined, intensity);
    var color1 = new Color().set(color);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }

  AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
    constructor: AmbientLightProbe,
    isAmbientLightProbe: true,
    copy: function copy(source) {
      LightProbe.prototype.copy.call(this, source);
      return this;
    },
    toJSON: function toJSON(meta) {
      var data = LightProbe.prototype.toJSON.call(this, meta);
      return data;
    }
  });

  var _eyeRight = new Matrix4();

  var _eyeLeft = new Matrix4();

  function StereoCamera() {
    this.type = 'StereoCamera';
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }

  Object.assign(StereoCamera.prototype, {
    update: function update(camera) {
      var cache = this._cache;
      var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

      if (needsUpdate) {
        cache.focus = camera.focus;
        cache.fov = camera.fov;
        cache.aspect = camera.aspect * this.aspect;
        cache.near = camera.near;
        cache.far = camera.far;
        cache.zoom = camera.zoom;
        cache.eyeSep = this.eyeSep;
        var projectionMatrix = camera.projectionMatrix.clone();
        var eyeSepHalf = cache.eyeSep / 2;
        var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
        var ymax = cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5) / cache.zoom;
        var xmin, xmax;
        _eyeLeft.elements[12] = -eyeSepHalf;
        _eyeRight.elements[12] = eyeSepHalf;
        xmin = -ymax * cache.aspect + eyeSepOnProjection;
        xmax = ymax * cache.aspect + eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraL.projectionMatrix.copy(projectionMatrix);
        xmin = -ymax * cache.aspect - eyeSepOnProjection;
        xmax = ymax * cache.aspect - eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraR.projectionMatrix.copy(projectionMatrix);
      }

      this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
      this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
    }
  });

  function Clock(autoStart) {
    this.autoStart = autoStart !== undefined ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }

  Object.assign(Clock.prototype, {
    start: function start() {
      this.startTime = (typeof performance === 'undefined' ? Date : performance).now();
      this.oldTime = this.startTime;
      this.elapsedTime = 0;
      this.running = true;
    },
    stop: function stop() {
      this.getElapsedTime();
      this.running = false;
      this.autoStart = false;
    },
    getElapsedTime: function getElapsedTime() {
      this.getDelta();
      return this.elapsedTime;
    },
    getDelta: function getDelta() {
      var diff = 0;

      if (this.autoStart && !this.running) {
        this.start();
        return 0;
      }

      if (this.running) {
        var newTime = (typeof performance === 'undefined' ? Date : performance).now();
        diff = (newTime - this.oldTime) / 1000;
        this.oldTime = newTime;
        this.elapsedTime += diff;
      }

      return diff;
    }
  });

  var _position$2 = new Vector3();

  var _quaternion$3 = new Quaternion();

  var _scale$1 = new Vector3();

  var _orientation = new Vector3();

  function AudioListener() {
    Object3D.call(this);
    this.type = 'AudioListener';
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    this._clock = new Clock();
  }

  AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: AudioListener,
    getInput: function getInput() {
      return this.gain;
    },
    removeFilter: function removeFilter() {
      if (this.filter !== null) {
        this.gain.disconnect(this.filter);
        this.filter.disconnect(this.context.destination);
        this.gain.connect(this.context.destination);
        this.filter = null;
      }

      return this;
    },
    getFilter: function getFilter() {
      return this.filter;
    },
    setFilter: function setFilter(value) {
      if (this.filter !== null) {
        this.gain.disconnect(this.filter);
        this.filter.disconnect(this.context.destination);
      } else {
        this.gain.disconnect(this.context.destination);
      }

      this.filter = value;
      this.gain.connect(this.filter);
      this.filter.connect(this.context.destination);
      return this;
    },
    getMasterVolume: function getMasterVolume() {
      return this.gain.gain.value;
    },
    setMasterVolume: function setMasterVolume(value) {
      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
      return this;
    },
    updateMatrixWorld: function updateMatrixWorld(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      var listener = this.context.listener;
      var up = this.up;
      this.timeDelta = this._clock.getDelta();
      this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);

      _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);

      if (listener.positionX) {
        var endTime = this.context.currentTime + this.timeDelta;
        listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
        listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
        listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
        listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
        listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
        listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
        listener.upX.linearRampToValueAtTime(up.x, endTime);
        listener.upY.linearRampToValueAtTime(up.y, endTime);
        listener.upZ.linearRampToValueAtTime(up.z, endTime);
      } else {
        listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
        listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
      }
    }
  });

  function Audio(listener) {
    Object3D.call(this);
    this.type = 'Audio';
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = undefined;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.sourceType = 'empty';
    this._startedAt = 0;
    this._pausedAt = 0;
    this.filters = [];
  }

  Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Audio,
    getOutput: function getOutput() {
      return this.gain;
    },
    setNodeSource: function setNodeSource(audioNode) {
      this.hasPlaybackControl = false;
      this.sourceType = 'audioNode';
      this.source = audioNode;
      this.connect();
      return this;
    },
    setMediaElementSource: function setMediaElementSource(mediaElement) {
      this.hasPlaybackControl = false;
      this.sourceType = 'mediaNode';
      this.source = this.context.createMediaElementSource(mediaElement);
      this.connect();
      return this;
    },
    setMediaStreamSource: function setMediaStreamSource(mediaStream) {
      this.hasPlaybackControl = false;
      this.sourceType = 'mediaStreamNode';
      this.source = this.context.createMediaStreamSource(mediaStream);
      this.connect();
      return this;
    },
    setBuffer: function setBuffer(audioBuffer) {
      this.buffer = audioBuffer;
      this.sourceType = 'buffer';
      if (this.autoplay) this.play();
      return this;
    },
    play: function play(delay) {
      if (delay === undefined) delay = 0;

      if (this.isPlaying === true) {
        console.warn('THREE.Audio: Audio is already playing.');
        return;
      }

      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }

      this._startedAt = this.context.currentTime + delay;
      var source = this.context.createBufferSource();
      source.buffer = this.buffer;
      source.loop = this.loop;
      source.loopStart = this.loopStart;
      source.loopEnd = this.loopEnd;
      source.onended = this.onEnded.bind(this);
      source.start(this._startedAt, this._pausedAt + this.offset, this.duration);
      this.isPlaying = true;
      this.source = source;
      this.setDetune(this.detune);
      this.setPlaybackRate(this.playbackRate);
      return this.connect();
    },
    pause: function pause() {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }

      if (this.isPlaying === true) {
        this._pausedAt = (this.context.currentTime - this._startedAt) * this.playbackRate;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
      }

      return this;
    },
    stop: function stop() {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }

      this._pausedAt = 0;
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
      return this;
    },
    connect: function connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);

        for (var i = 1, l = this.filters.length; i < l; i++) {
          this.filters[i - 1].connect(this.filters[i]);
        }

        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else {
        this.source.connect(this.getOutput());
      }

      return this;
    },
    disconnect: function disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);

        for (var i = 1, l = this.filters.length; i < l; i++) {
          this.filters[i - 1].disconnect(this.filters[i]);
        }

        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else {
        this.source.disconnect(this.getOutput());
      }

      return this;
    },
    getFilters: function getFilters() {
      return this.filters;
    },
    setFilters: function setFilters(value) {
      if (!value) value = [];

      if (this.isPlaying === true) {
        this.disconnect();
        this.filters = value;
        this.connect();
      } else {
        this.filters = value;
      }

      return this;
    },
    setDetune: function setDetune(value) {
      this.detune = value;
      if (this.source.detune === undefined) return;

      if (this.isPlaying === true) {
        this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
      }

      return this;
    },
    getDetune: function getDetune() {
      return this.detune;
    },
    getFilter: function getFilter() {
      return this.getFilters()[0];
    },
    setFilter: function setFilter(filter) {
      return this.setFilters(filter ? [filter] : []);
    },
    setPlaybackRate: function setPlaybackRate(value) {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }

      this.playbackRate = value;

      if (this.isPlaying === true) {
        this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
      }

      return this;
    },
    getPlaybackRate: function getPlaybackRate() {
      return this.playbackRate;
    },
    onEnded: function onEnded() {
      this.isPlaying = false;
    },
    getLoop: function getLoop() {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return false;
      }

      return this.loop;
    },
    setLoop: function setLoop(value) {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }

      this.loop = value;

      if (this.isPlaying === true) {
        this.source.loop = this.loop;
      }

      return this;
    },
    setLoopStart: function setLoopStart(value) {
      this.loopStart = value;
      return this;
    },
    setLoopEnd: function setLoopEnd(value) {
      this.loopEnd = value;
      return this;
    },
    getVolume: function getVolume() {
      return this.gain.gain.value;
    },
    setVolume: function setVolume(value) {
      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
      return this;
    }
  });

  var _position$3 = new Vector3();

  var _quaternion$4 = new Quaternion();

  var _scale$2 = new Vector3();

  var _orientation$1 = new Vector3();

  function PositionalAudio(listener) {
    Audio.call(this, listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = 'HRTF';
    this.panner.connect(this.gain);
  }

  PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
    constructor: PositionalAudio,
    getOutput: function getOutput() {
      return this.panner;
    },
    getRefDistance: function getRefDistance() {
      return this.panner.refDistance;
    },
    setRefDistance: function setRefDistance(value) {
      this.panner.refDistance = value;
      return this;
    },
    getRolloffFactor: function getRolloffFactor() {
      return this.panner.rolloffFactor;
    },
    setRolloffFactor: function setRolloffFactor(value) {
      this.panner.rolloffFactor = value;
      return this;
    },
    getDistanceModel: function getDistanceModel() {
      return this.panner.distanceModel;
    },
    setDistanceModel: function setDistanceModel(value) {
      this.panner.distanceModel = value;
      return this;
    },
    getMaxDistance: function getMaxDistance() {
      return this.panner.maxDistance;
    },
    setMaxDistance: function setMaxDistance(value) {
      this.panner.maxDistance = value;
      return this;
    },
    setDirectionalCone: function setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
      this.panner.coneInnerAngle = coneInnerAngle;
      this.panner.coneOuterAngle = coneOuterAngle;
      this.panner.coneOuterGain = coneOuterGain;
      return this;
    },
    updateMatrixWorld: function updateMatrixWorld(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      if (this.hasPlaybackControl === true && this.isPlaying === false) return;
      this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);

      _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);

      var panner = this.panner;

      if (panner.positionX) {
        var endTime = this.context.currentTime + this.listener.timeDelta;
        panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
        panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
        panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
        panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
        panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
        panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
      } else {
        panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
        panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
      }
    }
  });

  function AudioAnalyser(audio, fftSize) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }

  Object.assign(AudioAnalyser.prototype, {
    getFrequencyData: function getFrequencyData() {
      this.analyser.getByteFrequencyData(this.data);
      return this.data;
    },
    getAverageFrequency: function getAverageFrequency() {
      var value = 0,
          data = this.getFrequencyData();

      for (var i = 0; i < data.length; i++) {
        value += data[i];
      }

      return value / data.length;
    }
  });

  function PropertyMixer(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    var bufferType = Float64Array,
        mixFunction;

    switch (typeName) {
      case 'quaternion':
        mixFunction = this._slerp;
        break;

      case 'string':
      case 'bool':
        bufferType = Array;
        mixFunction = this._select;
        break;

      default:
        mixFunction = this._lerp;
    }

    this.buffer = new bufferType(valueSize * 4);
    this._mixBufferRegion = mixFunction;
    this.cumulativeWeight = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }

  Object.assign(PropertyMixer.prototype, {
    accumulate: function accumulate(accuIndex, weight) {
      var buffer = this.buffer,
          stride = this.valueSize,
          offset = accuIndex * stride + stride,
          currentWeight = this.cumulativeWeight;

      if (currentWeight === 0) {
        for (var i = 0; i !== stride; ++i) {
          buffer[offset + i] = buffer[i];
        }

        currentWeight = weight;
      } else {
        currentWeight += weight;
        var mix = weight / currentWeight;

        this._mixBufferRegion(buffer, offset, 0, mix, stride);
      }

      this.cumulativeWeight = currentWeight;
    },
    apply: function apply(accuIndex) {
      var stride = this.valueSize,
          buffer = this.buffer,
          offset = accuIndex * stride + stride,
          weight = this.cumulativeWeight,
          binding = this.binding;
      this.cumulativeWeight = 0;

      if (weight < 1) {
        var originalValueOffset = stride * 3;

        this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
      }

      for (var i = stride, e = stride + stride; i !== e; ++i) {
        if (buffer[i] !== buffer[i + stride]) {
          binding.setValue(buffer, offset);
          break;
        }
      }
    },
    saveOriginalState: function saveOriginalState() {
      var binding = this.binding;
      var buffer = this.buffer,
          stride = this.valueSize,
          originalValueOffset = stride * 3;
      binding.getValue(buffer, originalValueOffset);

      for (var i = stride, e = originalValueOffset; i !== e; ++i) {
        buffer[i] = buffer[originalValueOffset + i % stride];
      }

      this.cumulativeWeight = 0;
    },
    restoreOriginalState: function restoreOriginalState() {
      var originalValueOffset = this.valueSize * 3;
      this.binding.setValue(this.buffer, originalValueOffset);
    },
    _select: function _select(buffer, dstOffset, srcOffset, t, stride) {
      if (t >= 0.5) {
        for (var i = 0; i !== stride; ++i) {
          buffer[dstOffset + i] = buffer[srcOffset + i];
        }
      }
    },
    _slerp: function _slerp(buffer, dstOffset, srcOffset, t) {
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    },
    _lerp: function _lerp(buffer, dstOffset, srcOffset, t, stride) {
      var s = 1 - t;

      for (var i = 0; i !== stride; ++i) {
        var j = dstOffset + i;
        buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
      }
    }
  });
  var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

  var _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');

  var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';

  var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';

  var _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);

  var _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);

  var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);

  var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

  var _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');

  var _supportedObjectNames = ['material', 'materials', 'bones'];

  function Composite(targetGroup, path, optionalParsedPath) {
    var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }

  Object.assign(Composite.prototype, {
    getValue: function getValue(array, offset) {
      this.bind();
      var firstValidIndex = this._targetGroup.nCachedObjects_,
          binding = this._bindings[firstValidIndex];
      if (binding !== undefined) binding.getValue(array, offset);
    },
    setValue: function setValue(array, offset) {
      var bindings = this._bindings;

      for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].setValue(array, offset);
      }
    },
    bind: function bind() {
      var bindings = this._bindings;

      for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].bind();
      }
    },
    unbind: function unbind() {
      var bindings = this._bindings;

      for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].unbind();
      }
    }
  });

  function PropertyBinding(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
  }

  Object.assign(PropertyBinding, {
    Composite: Composite,
    create: function create(root, path, parsedPath) {
      if (!(root && root.isAnimationObjectGroup)) {
        return new PropertyBinding(root, path, parsedPath);
      } else {
        return new PropertyBinding.Composite(root, path, parsedPath);
      }
    },
    sanitizeNodeName: function sanitizeNodeName(name) {
      return name.replace(/\s/g, '_').replace(_reservedRe, '');
    },
    parseTrackName: function parseTrackName(trackName) {
      var matches = _trackRe.exec(trackName);

      if (!matches) {
        throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
      }

      var results = {
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        propertyIndex: matches[6]
      };
      var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

      if (lastDot !== undefined && lastDot !== -1) {
        var objectName = results.nodeName.substring(lastDot + 1);

        if (_supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }

      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
      }

      return results;
    },
    findNode: function findNode(root, nodeName) {
      if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      }

      if (root.skeleton) {
        var bone = root.skeleton.getBoneByName(nodeName);

        if (bone !== undefined) {
          return bone;
        }
      }

      if (root.children) {
        var searchNodeSubtree = function searchNodeSubtree(children) {
          for (var i = 0; i < children.length; i++) {
            var childNode = children[i];

            if (childNode.name === nodeName || childNode.uuid === nodeName) {
              return childNode;
            }

            var result = searchNodeSubtree(childNode.children);
            if (result) return result;
          }

          return null;
        };

        var subTreeNode = searchNodeSubtree(root.children);

        if (subTreeNode) {
          return subTreeNode;
        }
      }

      return null;
    }
  });
  Object.assign(PropertyBinding.prototype, {
    _getValue_unavailable: function _getValue_unavailable() {},
    _setValue_unavailable: function _setValue_unavailable() {},
    BindingType: {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    },
    Versioning: {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [function getValue_direct(buffer, offset) {
      buffer[offset] = this.node[this.propertyName];
    }, function getValue_array(buffer, offset) {
      var source = this.resolvedProperty;

      for (var i = 0, n = source.length; i !== n; ++i) {
        buffer[offset++] = source[i];
      }
    }, function getValue_arrayElement(buffer, offset) {
      buffer[offset] = this.resolvedProperty[this.propertyIndex];
    }, function getValue_toArray(buffer, offset) {
      this.resolvedProperty.toArray(buffer, offset);
    }],
    SetterByBindingTypeAndVersioning: [[function setValue_direct(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
    }, function setValue_direct_setNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }], [function setValue_array(buffer, offset) {
      var dest = this.resolvedProperty;

      for (var i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
    }, function setValue_array_setNeedsUpdate(buffer, offset) {
      var dest = this.resolvedProperty;

      for (var i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }

      this.targetObject.needsUpdate = true;
    }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
      var dest = this.resolvedProperty;

      for (var i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }

      this.targetObject.matrixWorldNeedsUpdate = true;
    }], [function setValue_arrayElement(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
    }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }], [function setValue_fromArray(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
    }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.needsUpdate = true;
    }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.matrixWorldNeedsUpdate = true;
    }]],
    getValue: function getValue_unbound(targetArray, offset) {
      this.bind();
      this.getValue(targetArray, offset);
    },
    setValue: function getValue_unbound(sourceArray, offset) {
      this.bind();
      this.setValue(sourceArray, offset);
    },
    bind: function bind() {
      var targetObject = this.node,
          parsedPath = this.parsedPath,
          objectName = parsedPath.objectName,
          propertyName = parsedPath.propertyName,
          propertyIndex = parsedPath.propertyIndex;

      if (!targetObject) {
        targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
        this.node = targetObject;
      }

      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable;

      if (!targetObject) {
        console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
        return;
      }

      if (objectName) {
        var objectIndex = parsedPath.objectIndex;

        switch (objectName) {
          case 'materials':
            if (!targetObject.material) {
              console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
              return;
            }

            if (!targetObject.material.materials) {
              console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
              return;
            }

            targetObject = targetObject.material.materials;
            break;

          case 'bones':
            if (!targetObject.skeleton) {
              console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
              return;
            }

            targetObject = targetObject.skeleton.bones;

            for (var i = 0; i < targetObject.length; i++) {
              if (targetObject[i].name === objectIndex) {
                objectIndex = i;
                break;
              }
            }

            break;

          default:
            if (targetObject[objectName] === undefined) {
              console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
              return;
            }

            targetObject = targetObject[objectName];
        }

        if (objectIndex !== undefined) {
          if (targetObject[objectIndex] === undefined) {
            console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
            return;
          }

          targetObject = targetObject[objectIndex];
        }
      }

      var nodeProperty = targetObject[propertyName];

      if (nodeProperty === undefined) {
        var nodeName = parsedPath.nodeName;
        console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
        return;
      }

      var versioning = this.Versioning.None;
      this.targetObject = targetObject;

      if (targetObject.needsUpdate !== undefined) {
        versioning = this.Versioning.NeedsUpdate;
      } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
        versioning = this.Versioning.MatrixWorldNeedsUpdate;
      }

      var bindingType = this.BindingType.Direct;

      if (propertyIndex !== undefined) {
        if (propertyName === "morphTargetInfluences") {
          if (!targetObject.geometry) {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
            return;
          }

          if (targetObject.geometry.isBufferGeometry) {
            if (!targetObject.geometry.morphAttributes) {
              console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
              return;
            }

            for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
              if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
                propertyIndex = i;
                break;
              }
            }
          } else {
            if (!targetObject.geometry.morphTargets) {
              console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this);
              return;
            }

            for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
              if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                propertyIndex = i;
                break;
              }
            }
          }
        }

        bindingType = this.BindingType.ArrayElement;
        this.resolvedProperty = nodeProperty;
        this.propertyIndex = propertyIndex;
      } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
        bindingType = this.BindingType.HasFromToArray;
        this.resolvedProperty = nodeProperty;
      } else if (Array.isArray(nodeProperty)) {
        bindingType = this.BindingType.EntireArray;
        this.resolvedProperty = nodeProperty;
      } else {
        this.propertyName = propertyName;
      }

      this.getValue = this.GetterByBindingType[bindingType];
      this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    },
    unbind: function unbind() {
      this.node = null;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
  });
  Object.assign(PropertyBinding.prototype, {
    _getValue_unbound: PropertyBinding.prototype.getValue,
    _setValue_unbound: PropertyBinding.prototype.setValue
  });

  function AnimationObjectGroup() {
    this.uuid = MathUtils.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    var indices = {};
    this._indicesByUUID = indices;

    for (var i = 0, n = arguments.length; i !== n; ++i) {
      indices[arguments[i].uuid] = i;
    }

    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    var scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },

        get inUse() {
          return this.total - scope.nCachedObjects_;
        }

      },

      get bindingsPerObject() {
        return scope._bindings.length;
      }

    };
  }

  Object.assign(AnimationObjectGroup.prototype, {
    isAnimationObjectGroup: true,
    add: function add() {
      var objects = this._objects,
          nObjects = objects.length,
          nCachedObjects = this.nCachedObjects_,
          indicesByUUID = this._indicesByUUID,
          paths = this._paths,
          parsedPaths = this._parsedPaths,
          bindings = this._bindings,
          nBindings = bindings.length,
          knownObject = undefined;

      for (var i = 0, n = arguments.length; i !== n; ++i) {
        var object = arguments[i],
            uuid = object.uuid,
            index = indicesByUUID[uuid];

        if (index === undefined) {
          index = nObjects++;
          indicesByUUID[uuid] = index;
          objects.push(object);

          for (var j = 0, m = nBindings; j !== m; ++j) {
            bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
          }
        } else if (index < nCachedObjects) {
          knownObject = objects[index];
          var firstActiveIndex = --nCachedObjects,
              lastCachedObject = objects[firstActiveIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[uuid] = firstActiveIndex;
          objects[firstActiveIndex] = object;

          for (var j = 0, m = nBindings; j !== m; ++j) {
            var bindingsForPath = bindings[j],
                lastCached = bindingsForPath[firstActiveIndex],
                binding = bindingsForPath[index];
            bindingsForPath[index] = lastCached;

            if (binding === undefined) {
              binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
            }

            bindingsForPath[firstActiveIndex] = binding;
          }
        } else if (objects[index] !== knownObject) {
          console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
        }
      }

      this.nCachedObjects_ = nCachedObjects;
    },
    remove: function remove() {
      var objects = this._objects,
          nCachedObjects = this.nCachedObjects_,
          indicesByUUID = this._indicesByUUID,
          bindings = this._bindings,
          nBindings = bindings.length;

      for (var i = 0, n = arguments.length; i !== n; ++i) {
        var object = arguments[i],
            uuid = object.uuid,
            index = indicesByUUID[uuid];

        if (index !== undefined && index >= nCachedObjects) {
          var lastCachedIndex = nCachedObjects++,
              firstActiveObject = objects[lastCachedIndex];
          indicesByUUID[firstActiveObject.uuid] = index;
          objects[index] = firstActiveObject;
          indicesByUUID[uuid] = lastCachedIndex;
          objects[lastCachedIndex] = object;

          for (var j = 0, m = nBindings; j !== m; ++j) {
            var bindingsForPath = bindings[j],
                firstActive = bindingsForPath[lastCachedIndex],
                binding = bindingsForPath[index];
            bindingsForPath[index] = firstActive;
            bindingsForPath[lastCachedIndex] = binding;
          }
        }
      }

      this.nCachedObjects_ = nCachedObjects;
    },
    uncache: function uncache() {
      var objects = this._objects,
          nObjects = objects.length,
          nCachedObjects = this.nCachedObjects_,
          indicesByUUID = this._indicesByUUID,
          bindings = this._bindings,
          nBindings = bindings.length;

      for (var i = 0, n = arguments.length; i !== n; ++i) {
        var object = arguments[i],
            uuid = object.uuid,
            index = indicesByUUID[uuid];

        if (index !== undefined) {
          delete indicesByUUID[uuid];

          if (index < nCachedObjects) {
            var firstActiveIndex = --nCachedObjects,
                lastCachedObject = objects[firstActiveIndex],
                lastIndex = --nObjects,
                lastObject = objects[lastIndex];
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;
            indicesByUUID[lastObject.uuid] = firstActiveIndex;
            objects[firstActiveIndex] = lastObject;
            objects.pop();

            for (var j = 0, m = nBindings; j !== m; ++j) {
              var bindingsForPath = bindings[j],
                  lastCached = bindingsForPath[firstActiveIndex],
                  last = bindingsForPath[lastIndex];
              bindingsForPath[index] = lastCached;
              bindingsForPath[firstActiveIndex] = last;
              bindingsForPath.pop();
            }
          } else {
            var lastIndex = --nObjects,
                lastObject = objects[lastIndex];
            indicesByUUID[lastObject.uuid] = index;
            objects[index] = lastObject;
            objects.pop();

            for (var j = 0, m = nBindings; j !== m; ++j) {
              var bindingsForPath = bindings[j];
              bindingsForPath[index] = bindingsForPath[lastIndex];
              bindingsForPath.pop();
            }
          }
        }
      }

      this.nCachedObjects_ = nCachedObjects;
    },
    subscribe_: function subscribe_(path, parsedPath) {
      var indicesByPath = this._bindingsIndicesByPath,
          index = indicesByPath[path],
          bindings = this._bindings;
      if (index !== undefined) return bindings[index];
      var paths = this._paths,
          parsedPaths = this._parsedPaths,
          objects = this._objects,
          nObjects = objects.length,
          nCachedObjects = this.nCachedObjects_,
          bindingsForPath = new Array(nObjects);
      index = bindings.length;
      indicesByPath[path] = index;
      paths.push(path);
      parsedPaths.push(parsedPath);
      bindings.push(bindingsForPath);

      for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
        var object = objects[i];
        bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
      }

      return bindingsForPath;
    },
    unsubscribe_: function unsubscribe_(path) {
      var indicesByPath = this._bindingsIndicesByPath,
          index = indicesByPath[path];

      if (index !== undefined) {
        var paths = this._paths,
            parsedPaths = this._parsedPaths,
            bindings = this._bindings,
            lastBindingsIndex = bindings.length - 1,
            lastBindings = bindings[lastBindingsIndex],
            lastBindingsPath = path[lastBindingsIndex];
        indicesByPath[lastBindingsPath] = index;
        bindings[index] = lastBindings;
        bindings.pop();
        parsedPaths[index] = parsedPaths[lastBindingsIndex];
        parsedPaths.pop();
        paths[index] = paths[lastBindingsIndex];
        paths.pop();
      }
    }
  });

  function AnimationAction(mixer, clip, localRoot) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot || null;
    var tracks = clip.tracks,
        nTracks = tracks.length,
        interpolants = new Array(nTracks);
    var interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };

    for (var i = 0; i !== nTracks; ++i) {
      var interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }

    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }

  Object.assign(AnimationAction.prototype, {
    play: function play() {
      this._mixer._activateAction(this);

      return this;
    },
    stop: function stop() {
      this._mixer._deactivateAction(this);

      return this.reset();
    },
    reset: function reset() {
      this.paused = false;
      this.enabled = true;
      this.time = 0;
      this._loopCount = -1;
      this._startTime = null;
      return this.stopFading().stopWarping();
    },
    isRunning: function isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    },
    isScheduled: function isScheduled() {
      return this._mixer._isActiveAction(this);
    },
    startAt: function startAt(time) {
      this._startTime = time;
      return this;
    },
    setLoop: function setLoop(mode, repetitions) {
      this.loop = mode;
      this.repetitions = repetitions;
      return this;
    },
    setEffectiveWeight: function setEffectiveWeight(weight) {
      this.weight = weight;
      this._effectiveWeight = this.enabled ? weight : 0;
      return this.stopFading();
    },
    getEffectiveWeight: function getEffectiveWeight() {
      return this._effectiveWeight;
    },
    fadeIn: function fadeIn(duration) {
      return this._scheduleFading(duration, 0, 1);
    },
    fadeOut: function fadeOut(duration) {
      return this._scheduleFading(duration, 1, 0);
    },
    crossFadeFrom: function crossFadeFrom(fadeOutAction, duration, warp) {
      fadeOutAction.fadeOut(duration);
      this.fadeIn(duration);

      if (warp) {
        var fadeInDuration = this._clip.duration,
            fadeOutDuration = fadeOutAction._clip.duration,
            startEndRatio = fadeOutDuration / fadeInDuration,
            endStartRatio = fadeInDuration / fadeOutDuration;
        fadeOutAction.warp(1.0, startEndRatio, duration);
        this.warp(endStartRatio, 1.0, duration);
      }

      return this;
    },
    crossFadeTo: function crossFadeTo(fadeInAction, duration, warp) {
      return fadeInAction.crossFadeFrom(this, duration, warp);
    },
    stopFading: function stopFading() {
      var weightInterpolant = this._weightInterpolant;

      if (weightInterpolant !== null) {
        this._weightInterpolant = null;

        this._mixer._takeBackControlInterpolant(weightInterpolant);
      }

      return this;
    },
    setEffectiveTimeScale: function setEffectiveTimeScale(timeScale) {
      this.timeScale = timeScale;
      this._effectiveTimeScale = this.paused ? 0 : timeScale;
      return this.stopWarping();
    },
    getEffectiveTimeScale: function getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    },
    setDuration: function setDuration(duration) {
      this.timeScale = this._clip.duration / duration;
      return this.stopWarping();
    },
    syncWith: function syncWith(action) {
      this.time = action.time;
      this.timeScale = action.timeScale;
      return this.stopWarping();
    },
    halt: function halt(duration) {
      return this.warp(this._effectiveTimeScale, 0, duration);
    },
    warp: function warp(startTimeScale, endTimeScale, duration) {
      var mixer = this._mixer,
          now = mixer.time,
          interpolant = this._timeScaleInterpolant,
          timeScale = this.timeScale;

      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._timeScaleInterpolant = interpolant;
      }

      var times = interpolant.parameterPositions,
          values = interpolant.sampleValues;
      times[0] = now;
      times[1] = now + duration;
      values[0] = startTimeScale / timeScale;
      values[1] = endTimeScale / timeScale;
      return this;
    },
    stopWarping: function stopWarping() {
      var timeScaleInterpolant = this._timeScaleInterpolant;

      if (timeScaleInterpolant !== null) {
        this._timeScaleInterpolant = null;

        this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
      }

      return this;
    },
    getMixer: function getMixer() {
      return this._mixer;
    },
    getClip: function getClip() {
      return this._clip;
    },
    getRoot: function getRoot() {
      return this._localRoot || this._mixer._root;
    },
    _update: function _update(time, deltaTime, timeDirection, accuIndex) {
      if (!this.enabled) {
        this._updateWeight(time);

        return;
      }

      var startTime = this._startTime;

      if (startTime !== null) {
        var timeRunning = (time - startTime) * timeDirection;

        if (timeRunning < 0 || timeDirection === 0) {
          return;
        }

        this._startTime = null;
        deltaTime = timeDirection * timeRunning;
      }

      deltaTime *= this._updateTimeScale(time);

      var clipTime = this._updateTime(deltaTime);

      var weight = this._updateWeight(time);

      if (weight > 0) {
        var interpolants = this._interpolants;
        var propertyMixers = this._propertyBindings;

        for (var j = 0, m = interpolants.length; j !== m; ++j) {
          interpolants[j].evaluate(clipTime);
          propertyMixers[j].accumulate(accuIndex, weight);
        }
      }
    },
    _updateWeight: function _updateWeight(time) {
      var weight = 0;

      if (this.enabled) {
        weight = this.weight;
        var interpolant = this._weightInterpolant;

        if (interpolant !== null) {
          var interpolantValue = interpolant.evaluate(time)[0];
          weight *= interpolantValue;

          if (time > interpolant.parameterPositions[1]) {
            this.stopFading();

            if (interpolantValue === 0) {
              this.enabled = false;
            }
          }
        }
      }

      this._effectiveWeight = weight;
      return weight;
    },
    _updateTimeScale: function _updateTimeScale(time) {
      var timeScale = 0;

      if (!this.paused) {
        timeScale = this.timeScale;
        var interpolant = this._timeScaleInterpolant;

        if (interpolant !== null) {
          var interpolantValue = interpolant.evaluate(time)[0];
          timeScale *= interpolantValue;

          if (time > interpolant.parameterPositions[1]) {
            this.stopWarping();

            if (timeScale === 0) {
              this.paused = true;
            } else {
              this.timeScale = timeScale;
            }
          }
        }
      }

      this._effectiveTimeScale = timeScale;
      return timeScale;
    },
    _updateTime: function _updateTime(deltaTime) {
      var time = this.time + deltaTime;
      var duration = this._clip.duration;
      var loop = this.loop;
      var loopCount = this._loopCount;
      var pingPong = loop === LoopPingPong;

      if (deltaTime === 0) {
        if (loopCount === -1) return time;
        return pingPong && (loopCount & 1) === 1 ? duration - time : time;
      }

      if (loop === LoopOnce) {
        if (loopCount === -1) {
          this._loopCount = 0;

          this._setEndings(true, true, false);
        }

        handle_stop: {
          if (time >= duration) {
            time = duration;
          } else if (time < 0) {
            time = 0;
          } else {
            this.time = time;
            break handle_stop;
          }

          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
          this.time = time;

          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: deltaTime < 0 ? -1 : 1
          });
        }
      } else {
        if (loopCount === -1) {
          if (deltaTime >= 0) {
            loopCount = 0;

            this._setEndings(true, this.repetitions === 0, pingPong);
          } else {
            this._setEndings(this.repetitions === 0, true, pingPong);
          }
        }

        if (time >= duration || time < 0) {
          var loopDelta = Math.floor(time / duration);
          time -= duration * loopDelta;
          loopCount += Math.abs(loopDelta);
          var pending = this.repetitions - loopCount;

          if (pending <= 0) {
            if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
            time = deltaTime > 0 ? duration : 0;
            this.time = time;

            this._mixer.dispatchEvent({
              type: 'finished',
              action: this,
              direction: deltaTime > 0 ? 1 : -1
            });
          } else {
            if (pending === 1) {
              var atStart = deltaTime < 0;

              this._setEndings(atStart, !atStart, pingPong);
            } else {
              this._setEndings(false, false, pingPong);
            }

            this._loopCount = loopCount;
            this.time = time;

            this._mixer.dispatchEvent({
              type: 'loop',
              action: this,
              loopDelta: loopDelta
            });
          }
        } else {
          this.time = time;
        }

        if (pingPong && (loopCount & 1) === 1) {
          return duration - time;
        }
      }

      return time;
    },
    _setEndings: function _setEndings(atStart, atEnd, pingPong) {
      var settings = this._interpolantSettings;

      if (pingPong) {
        settings.endingStart = ZeroSlopeEnding;
        settings.endingEnd = ZeroSlopeEnding;
      } else {
        if (atStart) {
          settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingStart = WrapAroundEnding;
        }

        if (atEnd) {
          settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingEnd = WrapAroundEnding;
        }
      }
    },
    _scheduleFading: function _scheduleFading(duration, weightNow, weightThen) {
      var mixer = this._mixer,
          now = mixer.time,
          interpolant = this._weightInterpolant;

      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._weightInterpolant = interpolant;
      }

      var times = interpolant.parameterPositions,
          values = interpolant.sampleValues;
      times[0] = now;
      values[0] = weightNow;
      times[1] = now + duration;
      values[1] = weightThen;
      return this;
    }
  });

  function AnimationMixer(root) {
    this._root = root;

    this._initMemoryManager();

    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1.0;
  }

  AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: AnimationMixer,
    _bindAction: function _bindAction(action, prototypeAction) {
      var root = action._localRoot || this._root,
          tracks = action._clip.tracks,
          nTracks = tracks.length,
          bindings = action._propertyBindings,
          interpolants = action._interpolants,
          rootUuid = root.uuid,
          bindingsByRoot = this._bindingsByRootAndName,
          bindingsByName = bindingsByRoot[rootUuid];

      if (bindingsByName === undefined) {
        bindingsByName = {};
        bindingsByRoot[rootUuid] = bindingsByName;
      }

      for (var i = 0; i !== nTracks; ++i) {
        var track = tracks[i],
            trackName = track.name,
            binding = bindingsByName[trackName];

        if (binding !== undefined) {
          bindings[i] = binding;
        } else {
          binding = bindings[i];

          if (binding !== undefined) {
            if (binding._cacheIndex === null) {
              ++binding.referenceCount;

              this._addInactiveBinding(binding, rootUuid, trackName);
            }

            continue;
          }

          var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
          binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
          ++binding.referenceCount;

          this._addInactiveBinding(binding, rootUuid, trackName);

          bindings[i] = binding;
        }

        interpolants[i].resultBuffer = binding.buffer;
      }
    },
    _activateAction: function _activateAction(action) {
      if (!this._isActiveAction(action)) {
        if (action._cacheIndex === null) {
          var rootUuid = (action._localRoot || this._root).uuid,
              clipUuid = action._clip.uuid,
              actionsForClip = this._actionsByClip[clipUuid];

          this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

          this._addInactiveAction(action, clipUuid, rootUuid);
        }

        var bindings = action._propertyBindings;

        for (var i = 0, n = bindings.length; i !== n; ++i) {
          var binding = bindings[i];

          if (binding.useCount++ === 0) {
            this._lendBinding(binding);

            binding.saveOriginalState();
          }
        }

        this._lendAction(action);
      }
    },
    _deactivateAction: function _deactivateAction(action) {
      if (this._isActiveAction(action)) {
        var bindings = action._propertyBindings;

        for (var i = 0, n = bindings.length; i !== n; ++i) {
          var binding = bindings[i];

          if (--binding.useCount === 0) {
            binding.restoreOriginalState();

            this._takeBackBinding(binding);
          }
        }

        this._takeBackAction(action);
      }
    },
    _initMemoryManager: function _initMemoryManager() {
      this._actions = [];
      this._nActiveActions = 0;
      this._actionsByClip = {};
      this._bindings = [];
      this._nActiveBindings = 0;
      this._bindingsByRootAndName = {};
      this._controlInterpolants = [];
      this._nActiveControlInterpolants = 0;
      var scope = this;
      this.stats = {
        actions: {
          get total() {
            return scope._actions.length;
          },

          get inUse() {
            return scope._nActiveActions;
          }

        },
        bindings: {
          get total() {
            return scope._bindings.length;
          },

          get inUse() {
            return scope._nActiveBindings;
          }

        },
        controlInterpolants: {
          get total() {
            return scope._controlInterpolants.length;
          },

          get inUse() {
            return scope._nActiveControlInterpolants;
          }

        }
      };
    },
    _isActiveAction: function _isActiveAction(action) {
      var index = action._cacheIndex;
      return index !== null && index < this._nActiveActions;
    },
    _addInactiveAction: function _addInactiveAction(action, clipUuid, rootUuid) {
      var actions = this._actions,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid];

      if (actionsForClip === undefined) {
        actionsForClip = {
          knownActions: [action],
          actionByRoot: {}
        };
        action._byClipCacheIndex = 0;
        actionsByClip[clipUuid] = actionsForClip;
      } else {
        var knownActions = actionsForClip.knownActions;
        action._byClipCacheIndex = knownActions.length;
        knownActions.push(action);
      }

      action._cacheIndex = actions.length;
      actions.push(action);
      actionsForClip.actionByRoot[rootUuid] = action;
    },
    _removeInactiveAction: function _removeInactiveAction(action) {
      var actions = this._actions,
          lastInactiveAction = actions[actions.length - 1],
          cacheIndex = action._cacheIndex;
      lastInactiveAction._cacheIndex = cacheIndex;
      actions[cacheIndex] = lastInactiveAction;
      actions.pop();
      action._cacheIndex = null;
      var clipUuid = action._clip.uuid,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid],
          knownActionsForClip = actionsForClip.knownActions,
          lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
          byClipCacheIndex = action._byClipCacheIndex;
      lastKnownAction._byClipCacheIndex = byClipCacheIndex;
      knownActionsForClip[byClipCacheIndex] = lastKnownAction;
      knownActionsForClip.pop();
      action._byClipCacheIndex = null;
      var actionByRoot = actionsForClip.actionByRoot,
          rootUuid = (action._localRoot || this._root).uuid;
      delete actionByRoot[rootUuid];

      if (knownActionsForClip.length === 0) {
        delete actionsByClip[clipUuid];
      }

      this._removeInactiveBindingsForAction(action);
    },
    _removeInactiveBindingsForAction: function _removeInactiveBindingsForAction(action) {
      var bindings = action._propertyBindings;

      for (var i = 0, n = bindings.length; i !== n; ++i) {
        var binding = bindings[i];

        if (--binding.referenceCount === 0) {
          this._removeInactiveBinding(binding);
        }
      }
    },
    _lendAction: function _lendAction(action) {
      var actions = this._actions,
          prevIndex = action._cacheIndex,
          lastActiveIndex = this._nActiveActions++,
          firstInactiveAction = actions[lastActiveIndex];
      action._cacheIndex = lastActiveIndex;
      actions[lastActiveIndex] = action;
      firstInactiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = firstInactiveAction;
    },
    _takeBackAction: function _takeBackAction(action) {
      var actions = this._actions,
          prevIndex = action._cacheIndex,
          firstInactiveIndex = --this._nActiveActions,
          lastActiveAction = actions[firstInactiveIndex];
      action._cacheIndex = firstInactiveIndex;
      actions[firstInactiveIndex] = action;
      lastActiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = lastActiveAction;
    },
    _addInactiveBinding: function _addInactiveBinding(binding, rootUuid, trackName) {
      var bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid],
          bindings = this._bindings;

      if (bindingByName === undefined) {
        bindingByName = {};
        bindingsByRoot[rootUuid] = bindingByName;
      }

      bindingByName[trackName] = binding;
      binding._cacheIndex = bindings.length;
      bindings.push(binding);
    },
    _removeInactiveBinding: function _removeInactiveBinding(binding) {
      var bindings = this._bindings,
          propBinding = binding.binding,
          rootUuid = propBinding.rootNode.uuid,
          trackName = propBinding.path,
          bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid],
          lastInactiveBinding = bindings[bindings.length - 1],
          cacheIndex = binding._cacheIndex;
      lastInactiveBinding._cacheIndex = cacheIndex;
      bindings[cacheIndex] = lastInactiveBinding;
      bindings.pop();
      delete bindingByName[trackName];

      if (Object.keys(bindingByName).length === 0) {
        delete bindingsByRoot[rootUuid];
      }
    },
    _lendBinding: function _lendBinding(binding) {
      var bindings = this._bindings,
          prevIndex = binding._cacheIndex,
          lastActiveIndex = this._nActiveBindings++,
          firstInactiveBinding = bindings[lastActiveIndex];
      binding._cacheIndex = lastActiveIndex;
      bindings[lastActiveIndex] = binding;
      firstInactiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = firstInactiveBinding;
    },
    _takeBackBinding: function _takeBackBinding(binding) {
      var bindings = this._bindings,
          prevIndex = binding._cacheIndex,
          firstInactiveIndex = --this._nActiveBindings,
          lastActiveBinding = bindings[firstInactiveIndex];
      binding._cacheIndex = firstInactiveIndex;
      bindings[firstInactiveIndex] = binding;
      lastActiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = lastActiveBinding;
    },
    _lendControlInterpolant: function _lendControlInterpolant() {
      var interpolants = this._controlInterpolants,
          lastActiveIndex = this._nActiveControlInterpolants++,
          interpolant = interpolants[lastActiveIndex];

      if (interpolant === undefined) {
        interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
        interpolant.__cacheIndex = lastActiveIndex;
        interpolants[lastActiveIndex] = interpolant;
      }

      return interpolant;
    },
    _takeBackControlInterpolant: function _takeBackControlInterpolant(interpolant) {
      var interpolants = this._controlInterpolants,
          prevIndex = interpolant.__cacheIndex,
          firstInactiveIndex = --this._nActiveControlInterpolants,
          lastActiveInterpolant = interpolants[firstInactiveIndex];
      interpolant.__cacheIndex = firstInactiveIndex;
      interpolants[firstInactiveIndex] = interpolant;
      lastActiveInterpolant.__cacheIndex = prevIndex;
      interpolants[prevIndex] = lastActiveInterpolant;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    clipAction: function clipAction(clip, optionalRoot) {
      var root = optionalRoot || this._root,
          rootUuid = root.uuid,
          clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
          clipUuid = clipObject !== null ? clipObject.uuid : clip,
          actionsForClip = this._actionsByClip[clipUuid],
          prototypeAction = null;

      if (actionsForClip !== undefined) {
        var existingAction = actionsForClip.actionByRoot[rootUuid];

        if (existingAction !== undefined) {
          return existingAction;
        }

        prototypeAction = actionsForClip.knownActions[0];
        if (clipObject === null) clipObject = prototypeAction._clip;
      }

      if (clipObject === null) return null;
      var newAction = new AnimationAction(this, clipObject, optionalRoot);

      this._bindAction(newAction, prototypeAction);

      this._addInactiveAction(newAction, clipUuid, rootUuid);

      return newAction;
    },
    existingAction: function existingAction(clip, optionalRoot) {
      var root = optionalRoot || this._root,
          rootUuid = root.uuid,
          clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
          clipUuid = clipObject ? clipObject.uuid : clip,
          actionsForClip = this._actionsByClip[clipUuid];

      if (actionsForClip !== undefined) {
        return actionsForClip.actionByRoot[rootUuid] || null;
      }

      return null;
    },
    stopAllAction: function stopAllAction() {
      var actions = this._actions,
          nActions = this._nActiveActions,
          bindings = this._bindings,
          nBindings = this._nActiveBindings;
      this._nActiveActions = 0;
      this._nActiveBindings = 0;

      for (var i = 0; i !== nActions; ++i) {
        actions[i].reset();
      }

      for (var i = 0; i !== nBindings; ++i) {
        bindings[i].useCount = 0;
      }

      return this;
    },
    update: function update(deltaTime) {
      deltaTime *= this.timeScale;
      var actions = this._actions,
          nActions = this._nActiveActions,
          time = this.time += deltaTime,
          timeDirection = Math.sign(deltaTime),
          accuIndex = this._accuIndex ^= 1;

      for (var i = 0; i !== nActions; ++i) {
        var action = actions[i];

        action._update(time, deltaTime, timeDirection, accuIndex);
      }

      var bindings = this._bindings,
          nBindings = this._nActiveBindings;

      for (var i = 0; i !== nBindings; ++i) {
        bindings[i].apply(accuIndex);
      }

      return this;
    },
    setTime: function setTime(timeInSeconds) {
      this.time = 0;

      for (var i = 0; i < this._actions.length; i++) {
        this._actions[i].time = 0;
      }

      return this.update(timeInSeconds);
    },
    getRoot: function getRoot() {
      return this._root;
    },
    uncacheClip: function uncacheClip(clip) {
      var actions = this._actions,
          clipUuid = clip.uuid,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid];

      if (actionsForClip !== undefined) {
        var actionsToRemove = actionsForClip.knownActions;

        for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
          var action = actionsToRemove[i];

          this._deactivateAction(action);

          var cacheIndex = action._cacheIndex,
              lastInactiveAction = actions[actions.length - 1];
          action._cacheIndex = null;
          action._byClipCacheIndex = null;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();

          this._removeInactiveBindingsForAction(action);
        }

        delete actionsByClip[clipUuid];
      }
    },
    uncacheRoot: function uncacheRoot(root) {
      var rootUuid = root.uuid,
          actionsByClip = this._actionsByClip;

      for (var clipUuid in actionsByClip) {
        var actionByRoot = actionsByClip[clipUuid].actionByRoot,
            action = actionByRoot[rootUuid];

        if (action !== undefined) {
          this._deactivateAction(action);

          this._removeInactiveAction(action);
        }
      }

      var bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid];

      if (bindingByName !== undefined) {
        for (var trackName in bindingByName) {
          var binding = bindingByName[trackName];
          binding.restoreOriginalState();

          this._removeInactiveBinding(binding);
        }
      }
    },
    uncacheAction: function uncacheAction(clip, optionalRoot) {
      var action = this.existingAction(clip, optionalRoot);

      if (action !== null) {
        this._deactivateAction(action);

        this._removeInactiveAction(action);
      }
    }
  });

  function Uniform(value) {
    if (typeof value === 'string') {
      console.warn('THREE.Uniform: Type parameter is no longer needed.');
      value = arguments[1];
    }

    this.value = value;
  }

  Uniform.prototype.clone = function () {
    return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
  };

  function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
    InterleavedBuffer.call(this, array, stride);
    this.meshPerAttribute = meshPerAttribute || 1;
  }

  InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
    constructor: InstancedInterleavedBuffer,
    isInstancedInterleavedBuffer: true,
    copy: function copy(source) {
      InterleavedBuffer.prototype.copy.call(this, source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    }
  });

  function Raycaster(origin, direction, near, far) {
    this.ray = new Ray(origin, direction);
    this.near = near || 0;
    this.far = far || Infinity;
    this.camera = null;
    this.params = {
      Mesh: {},
      Line: {},
      LOD: {},
      Points: {
        threshold: 1
      },
      Sprite: {}
    };
    Object.defineProperties(this.params, {
      PointCloud: {
        get: function get() {
          console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
          return this.Points;
        }
      }
    });
  }

  function ascSort(a, b) {
    return a.distance - b.distance;
  }

  function _intersectObject(object, raycaster, intersects, recursive) {
    if (object.visible === false) return;
    object.raycast(raycaster, intersects);

    if (recursive === true) {
      var children = object.children;

      for (var i = 0, l = children.length; i < l; i++) {
        _intersectObject(children[i], raycaster, intersects, true);
      }
    }
  }

  Object.assign(Raycaster.prototype, {
    linePrecision: 1,
    set: function set(origin, direction) {
      this.ray.set(origin, direction);
    },
    setFromCamera: function setFromCamera(coords, camera) {
      if (camera && camera.isPerspectiveCamera) {
        this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
        this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
        this.camera = camera;
      } else if (camera && camera.isOrthographicCamera) {
        this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
        this.camera = camera;
      } else {
        console.error('THREE.Raycaster: Unsupported camera type.');
      }
    },
    intersectObject: function intersectObject(object, recursive, optionalTarget) {
      var intersects = optionalTarget || [];

      _intersectObject(object, this, intersects, recursive);

      intersects.sort(ascSort);
      return intersects;
    },
    intersectObjects: function intersectObjects(objects, recursive, optionalTarget) {
      var intersects = optionalTarget || [];

      if (Array.isArray(objects) === false) {
        console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
        return intersects;
      }

      for (var i = 0, l = objects.length; i < l; i++) {
        _intersectObject(objects[i], this, intersects, recursive);
      }

      intersects.sort(ascSort);
      return intersects;
    }
  });

  function Spherical(radius, phi, theta) {
    this.radius = radius !== undefined ? radius : 1.0;
    this.phi = phi !== undefined ? phi : 0;
    this.theta = theta !== undefined ? theta : 0;
    return this;
  }

  Object.assign(Spherical.prototype, {
    set: function set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this;
    },
    makeSafe: function makeSafe() {
      var EPS = 0.000001;
      this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
      return this;
    },
    setFromVector3: function setFromVector3(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    },
    setFromCartesianCoords: function setFromCartesianCoords(x, y, z) {
      this.radius = Math.sqrt(x * x + y * y + z * z);

      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(x, z);
        this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
      }

      return this;
    }
  });

  function Cylindrical(radius, theta, y) {
    this.radius = radius !== undefined ? radius : 1.0;
    this.theta = theta !== undefined ? theta : 0;
    this.y = y !== undefined ? y : 0;
    return this;
  }

  Object.assign(Cylindrical.prototype, {
    set: function set(radius, theta, y) {
      this.radius = radius;
      this.theta = theta;
      this.y = y;
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(other) {
      this.radius = other.radius;
      this.theta = other.theta;
      this.y = other.y;
      return this;
    },
    setFromVector3: function setFromVector3(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    },
    setFromCartesianCoords: function setFromCartesianCoords(x, y, z) {
      this.radius = Math.sqrt(x * x + z * z);
      this.theta = Math.atan2(x, z);
      this.y = y;
      return this;
    }
  });

  var _vector$7 = new Vector2();

  function Box2(min, max) {
    this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
    this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
  }

  Object.assign(Box2.prototype, {
    set: function set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    },
    setFromPoints: function setFromPoints(points) {
      this.makeEmpty();

      for (var i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }

      return this;
    },
    setFromCenterAndSize: function setFromCenterAndSize(center, size) {
      var halfSize = _vector$7.copy(size).multiplyScalar(0.5);

      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    },
    makeEmpty: function makeEmpty() {
      this.min.x = this.min.y = +Infinity;
      this.max.x = this.max.y = -Infinity;
      return this;
    },
    isEmpty: function isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    getCenter: function getCenter(target) {
      if (target === undefined) {
        console.warn('THREE.Box2: .getCenter() target is now required');
        target = new Vector2();
      }

      return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function getSize(target) {
      if (target === undefined) {
        console.warn('THREE.Box2: .getSize() target is now required');
        target = new Vector2();
      }

      return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    },
    expandByPoint: function expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    },
    expandByVector: function expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    },
    expandByScalar: function expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    },
    containsPoint: function containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    },
    containsBox: function containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    },
    getParameter: function getParameter(point, target) {
      if (target === undefined) {
        console.warn('THREE.Box2: .getParameter() target is now required');
        target = new Vector2();
      }

      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    },
    intersectsBox: function intersectsBox(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    },
    clampPoint: function clampPoint(point, target) {
      if (target === undefined) {
        console.warn('THREE.Box2: .clampPoint() target is now required');
        target = new Vector2();
      }

      return target.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function distanceToPoint(point) {
      var clampedPoint = _vector$7.copy(point).clamp(this.min, this.max);

      return clampedPoint.sub(point).length();
    },
    intersect: function intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      return this;
    },
    union: function union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    },
    translate: function translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    },
    equals: function equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  });

  var _startP = new Vector3();

  var _startEnd = new Vector3();

  function Line3(start, end) {
    this.start = start !== undefined ? start : new Vector3();
    this.end = end !== undefined ? end : new Vector3();
  }

  Object.assign(Line3.prototype, {
    set: function set(start, end) {
      this.start.copy(start);
      this.end.copy(end);
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    },
    copy: function copy(line) {
      this.start.copy(line.start);
      this.end.copy(line.end);
      return this;
    },
    getCenter: function getCenter(target) {
      if (target === undefined) {
        console.warn('THREE.Line3: .getCenter() target is now required');
        target = new Vector3();
      }

      return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function delta(target) {
      if (target === undefined) {
        console.warn('THREE.Line3: .delta() target is now required');
        target = new Vector3();
      }

      return target.subVectors(this.end, this.start);
    },
    distanceSq: function distanceSq() {
      return this.start.distanceToSquared(this.end);
    },
    distance: function distance() {
      return this.start.distanceTo(this.end);
    },
    at: function at(t, target) {
      if (target === undefined) {
        console.warn('THREE.Line3: .at() target is now required');
        target = new Vector3();
      }

      return this.delta(target).multiplyScalar(t).add(this.start);
    },
    closestPointToPointParameter: function closestPointToPointParameter(point, clampToLine) {
      _startP.subVectors(point, this.start);

      _startEnd.subVectors(this.end, this.start);

      var startEnd2 = _startEnd.dot(_startEnd);

      var startEnd_startP = _startEnd.dot(_startP);

      var t = startEnd_startP / startEnd2;

      if (clampToLine) {
        t = MathUtils.clamp(t, 0, 1);
      }

      return t;
    },
    closestPointToPoint: function closestPointToPoint(point, clampToLine, target) {
      var t = this.closestPointToPointParameter(point, clampToLine);

      if (target === undefined) {
        console.warn('THREE.Line3: .closestPointToPoint() target is now required');
        target = new Vector3();
      }

      return this.delta(target).multiplyScalar(t).add(this.start);
    },
    applyMatrix4: function applyMatrix4(matrix) {
      this.start.applyMatrix4(matrix);
      this.end.applyMatrix4(matrix);
      return this;
    },
    equals: function equals(line) {
      return line.start.equals(this.start) && line.end.equals(this.end);
    }
  });

  function ImmediateRenderObject(material) {
    Object3D.call(this);
    this.material = material;

    this.render = function () {};
  }

  ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
  ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
  ImmediateRenderObject.prototype.isImmediateRenderObject = true;

  var _vector$8 = new Vector3();

  function SpotLightHelper(light, color) {
    Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    var geometry = new BufferGeometry();
    var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

    for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
      var p1 = i / l * Math.PI * 2;
      var p2 = j / l * Math.PI * 2;
      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }

    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    var material = new LineBasicMaterial({
      fog: false
    });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
  }

  SpotLightHelper.prototype = Object.create(Object3D.prototype);
  SpotLightHelper.prototype.constructor = SpotLightHelper;

  SpotLightHelper.prototype.dispose = function () {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  };

  SpotLightHelper.prototype.update = function () {
    this.light.updateMatrixWorld();
    var coneLength = this.light.distance ? this.light.distance : 1000;
    var coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);

    _vector$8.setFromMatrixPosition(this.light.target.matrixWorld);

    this.cone.lookAt(_vector$8);

    if (this.color !== undefined) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  };

  var _vector$9 = new Vector3();

  var _boneMatrix = new Matrix4();

  var _matrixWorldInv = new Matrix4();

  function getBoneList(object) {
    var boneList = [];

    if (object && object.isBone) {
      boneList.push(object);
    }

    for (var i = 0; i < object.children.length; i++) {
      boneList.push.apply(boneList, getBoneList(object.children[i]));
    }

    return boneList;
  }

  function SkeletonHelper(object) {
    var bones = getBoneList(object);
    var geometry = new BufferGeometry();
    var vertices = [];
    var colors = [];
    var color1 = new Color(0, 0, 1);
    var color2 = new Color(0, 1, 0);

    for (var i = 0; i < bones.length; i++) {
      var bone = bones[i];

      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }

    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: VertexColors,
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    LineSegments.call(this, geometry, material);
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }

  SkeletonHelper.prototype = Object.create(LineSegments.prototype);
  SkeletonHelper.prototype.constructor = SkeletonHelper;

  SkeletonHelper.prototype.updateMatrixWorld = function (force) {
    var bones = this.bones;
    var geometry = this.geometry;
    var position = geometry.getAttribute('position');

    _matrixWorldInv.getInverse(this.root.matrixWorld);

    for (var i = 0, j = 0; i < bones.length; i++) {
      var bone = bones[i];

      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);

        _vector$9.setFromMatrixPosition(_boneMatrix);

        position.setXYZ(j, _vector$9.x, _vector$9.y, _vector$9.z);

        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);

        _vector$9.setFromMatrixPosition(_boneMatrix);

        position.setXYZ(j + 1, _vector$9.x, _vector$9.y, _vector$9.z);
        j += 2;
      }
    }

    geometry.getAttribute('position').needsUpdate = true;
    Object3D.prototype.updateMatrixWorld.call(this, force);
  };

  function PointLightHelper(light, sphereSize, color) {
    this.light = light;
    this.light.updateMatrixWorld();
    this.color = color;
    var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
    var material = new MeshBasicMaterial({
      wireframe: true,
      fog: false
    });
    Mesh.call(this, geometry, material);
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
  }

  PointLightHelper.prototype = Object.create(Mesh.prototype);
  PointLightHelper.prototype.constructor = PointLightHelper;

  PointLightHelper.prototype.dispose = function () {
    this.geometry.dispose();
    this.material.dispose();
  };

  PointLightHelper.prototype.update = function () {
    if (this.color !== undefined) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }
  };

  var _vector$a = new Vector3();

  var _color1 = new Color();

  var _color2 = new Color();

  function HemisphereLightHelper(light, size, color) {
    Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    var geometry = new OctahedronBufferGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({
      wireframe: true,
      fog: false
    });
    if (this.color === undefined) this.material.vertexColors = VertexColors;
    var position = geometry.getAttribute('position');
    var colors = new Float32Array(position.count * 3);
    geometry.setAttribute('color', new BufferAttribute(colors, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
  }

  HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
  HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

  HemisphereLightHelper.prototype.dispose = function () {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  };

  HemisphereLightHelper.prototype.update = function () {
    var mesh = this.children[0];

    if (this.color !== undefined) {
      this.material.color.set(this.color);
    } else {
      var colors = mesh.geometry.getAttribute('color');

      _color1.copy(this.light.color);

      _color2.copy(this.light.groundColor);

      for (var i = 0, l = colors.count; i < l; i++) {
        var color = i < l / 2 ? _color1 : _color2;
        colors.setXYZ(i, color.r, color.g, color.b);
      }

      colors.needsUpdate = true;
    }

    mesh.lookAt(_vector$a.setFromMatrixPosition(this.light.matrixWorld).negate());
  };

  function GridHelper(size, divisions, color1, color2) {
    size = size || 10;
    divisions = divisions || 10;
    color1 = new Color(color1 !== undefined ? color1 : 0x444444);
    color2 = new Color(color2 !== undefined ? color2 : 0x888888);
    var center = divisions / 2;
    var step = size / divisions;
    var halfSize = size / 2;
    var vertices = [],
        colors = [];

    for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      var color = i === center ? color1 : color2;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
    }

    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: VertexColors
    });
    LineSegments.call(this, geometry, material);
  }

  GridHelper.prototype = Object.assign(Object.create(LineSegments.prototype), {
    constructor: GridHelper,
    copy: function copy(source) {
      LineSegments.prototype.copy.call(this, source);
      this.geometry.copy(source.geometry);
      this.material.copy(source.material);
      return this;
    },
    clone: function clone() {
      return new this.constructor().copy(this);
    }
  });

  function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
    radius = radius || 10;
    radials = radials || 16;
    circles = circles || 8;
    divisions = divisions || 64;
    color1 = new Color(color1 !== undefined ? color1 : 0x444444);
    color2 = new Color(color2 !== undefined ? color2 : 0x888888);
    var vertices = [];
    var colors = [];
    var x, z;
    var v, i, j, r, color;

    for (i = 0; i <= radials; i++) {
      v = i / radials * (Math.PI * 2);
      x = Math.sin(v) * radius;
      z = Math.cos(v) * radius;
      vertices.push(0, 0, 0);
      vertices.push(x, 0, z);
      color = i & 1 ? color1 : color2;
      colors.push(color.r, color.g, color.b);
      colors.push(color.r, color.g, color.b);
    }

    for (i = 0; i <= circles; i++) {
      color = i & 1 ? color1 : color2;
      r = radius - radius / circles * i;

      for (j = 0; j < divisions; j++) {
        v = j / divisions * (Math.PI * 2);
        x = Math.sin(v) * r;
        z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color.r, color.g, color.b);
        v = (j + 1) / divisions * (Math.PI * 2);
        x = Math.sin(v) * r;
        z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color.r, color.g, color.b);
      }
    }

    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: VertexColors
    });
    LineSegments.call(this, geometry, material);
  }

  PolarGridHelper.prototype = Object.create(LineSegments.prototype);
  PolarGridHelper.prototype.constructor = PolarGridHelper;

  var _v1$5 = new Vector3();

  var _v2$3 = new Vector3();

  var _v3$1 = new Vector3();

  function DirectionalLightHelper(light, size, color) {
    Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    if (size === undefined) size = 1;
    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
    var material = new LineBasicMaterial({
      fog: false
    });
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  }

  DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
  DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

  DirectionalLightHelper.prototype.dispose = function () {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  };

  DirectionalLightHelper.prototype.update = function () {
    _v1$5.setFromMatrixPosition(this.light.matrixWorld);

    _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);

    _v3$1.subVectors(_v2$3, _v1$5);

    this.lightPlane.lookAt(_v2$3);

    if (this.color !== undefined) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }

    this.targetLine.lookAt(_v2$3);
    this.targetLine.scale.z = _v3$1.length();
  };

  var _vector$b = new Vector3();

  var _camera = new Camera();

  function CameraHelper(camera) {
    var geometry = new BufferGeometry();
    var material = new LineBasicMaterial({
      color: 0xffffff,
      vertexColors: FaceColors
    });
    var vertices = [];
    var colors = [];
    var pointMap = {};
    var colorFrustum = new Color(0xffaa00);
    var colorCone = new Color(0xff0000);
    var colorUp = new Color(0x00aaff);
    var colorTarget = new Color(0xffffff);
    var colorCross = new Color(0x333333);
    addLine('n1', 'n2', colorFrustum);
    addLine('n2', 'n4', colorFrustum);
    addLine('n4', 'n3', colorFrustum);
    addLine('n3', 'n1', colorFrustum);
    addLine('f1', 'f2', colorFrustum);
    addLine('f2', 'f4', colorFrustum);
    addLine('f4', 'f3', colorFrustum);
    addLine('f3', 'f1', colorFrustum);
    addLine('n1', 'f1', colorFrustum);
    addLine('n2', 'f2', colorFrustum);
    addLine('n3', 'f3', colorFrustum);
    addLine('n4', 'f4', colorFrustum);
    addLine('p', 'n1', colorCone);
    addLine('p', 'n2', colorCone);
    addLine('p', 'n3', colorCone);
    addLine('p', 'n4', colorCone);
    addLine('u1', 'u2', colorUp);
    addLine('u2', 'u3', colorUp);
    addLine('u3', 'u1', colorUp);
    addLine('c', 't', colorTarget);
    addLine('p', 'c', colorCross);
    addLine('cn1', 'cn2', colorCross);
    addLine('cn3', 'cn4', colorCross);
    addLine('cf1', 'cf2', colorCross);
    addLine('cf3', 'cf4', colorCross);

    function addLine(a, b, color) {
      addPoint(a, color);
      addPoint(b, color);
    }

    function addPoint(id, color) {
      vertices.push(0, 0, 0);
      colors.push(color.r, color.g, color.b);

      if (pointMap[id] === undefined) {
        pointMap[id] = [];
      }

      pointMap[id].push(vertices.length / 3 - 1);
    }

    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    LineSegments.call(this, geometry, material);
    this.camera = camera;
    if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
  }

  CameraHelper.prototype = Object.create(LineSegments.prototype);
  CameraHelper.prototype.constructor = CameraHelper;

  CameraHelper.prototype.update = function () {
    var geometry = this.geometry;
    var pointMap = this.pointMap;
    var w = 1,
        h = 1;

    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);

    setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
    setPoint('t', pointMap, geometry, _camera, 0, 0, 1);
    setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
    setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
    setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
    setPoint('n4', pointMap, geometry, _camera, w, h, -1);
    setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
    setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
    setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
    setPoint('f4', pointMap, geometry, _camera, w, h, 1);
    setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
    setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
    setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1);
    setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
    setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
    setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
    setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
    setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
    setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
    setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
    setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
    geometry.getAttribute('position').needsUpdate = true;
  };

  function setPoint(point, pointMap, geometry, camera, x, y, z) {
    _vector$b.set(x, y, z).unproject(camera);

    var points = pointMap[point];

    if (points !== undefined) {
      var position = geometry.getAttribute('position');

      for (var i = 0, l = points.length; i < l; i++) {
        position.setXYZ(points[i], _vector$b.x, _vector$b.y, _vector$b.z);
      }
    }
  }

  var _box$3 = new Box3();

  function BoxHelper(object, color) {
    this.object = object;
    if (color === undefined) color = 0xffff00;
    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var positions = new Float32Array(8 * 3);
    var geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new BufferAttribute(positions, 3));
    LineSegments.call(this, geometry, new LineBasicMaterial({
      color: color
    }));
    this.matrixAutoUpdate = false;
    this.update();
  }

  BoxHelper.prototype = Object.create(LineSegments.prototype);
  BoxHelper.prototype.constructor = BoxHelper;

  BoxHelper.prototype.update = function (object) {
    if (object !== undefined) {
      console.warn('THREE.BoxHelper: .update() has no longer arguments.');
    }

    if (this.object !== undefined) {
      _box$3.setFromObject(this.object);
    }

    if (_box$3.isEmpty()) return;
    var min = _box$3.min;
    var max = _box$3.max;
    var position = this.geometry.attributes.position;
    var array = position.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  };

  BoxHelper.prototype.setFromObject = function (object) {
    this.object = object;
    this.update();
    return this;
  };

  BoxHelper.prototype.copy = function (source) {
    LineSegments.prototype.copy.call(this, source);
    this.object = source.object;
    return this;
  };

  BoxHelper.prototype.clone = function () {
    return new this.constructor().copy(this);
  };

  function Box3Helper(box, color) {
    this.type = 'Box3Helper';
    this.box = box;
    color = color || 0xffff00;
    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    var geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    LineSegments.call(this, geometry, new LineBasicMaterial({
      color: color
    }));
    this.geometry.computeBoundingSphere();
  }

  Box3Helper.prototype = Object.create(LineSegments.prototype);
  Box3Helper.prototype.constructor = Box3Helper;

  Box3Helper.prototype.updateMatrixWorld = function (force) {
    var box = this.box;
    if (box.isEmpty()) return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    Object3D.prototype.updateMatrixWorld.call(this, force);
  };

  function PlaneHelper(plane, size, hex) {
    this.type = 'PlaneHelper';
    this.plane = plane;
    this.size = size === undefined ? 1 : size;
    var color = hex !== undefined ? hex : 0xffff00;
    var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    Line.call(this, geometry, new LineBasicMaterial({
      color: color
    }));
    var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
    var geometry2 = new BufferGeometry();
    geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({
      color: color,
      opacity: 0.2,
      transparent: true,
      depthWrite: false
    })));
  }

  PlaneHelper.prototype = Object.create(Line.prototype);
  PlaneHelper.prototype.constructor = PlaneHelper;

  PlaneHelper.prototype.updateMatrixWorld = function (force) {
    var scale = -this.plane.constant;
    if (Math.abs(scale) < 1e-8) scale = 1e-8;
    this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
    this.children[0].material.side = scale < 0 ? BackSide : FrontSide;
    this.lookAt(this.plane.normal);
    Object3D.prototype.updateMatrixWorld.call(this, force);
  };

  var _axis = new Vector3();

  var _lineGeometry, _coneGeometry;

  function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
    Object3D.call(this);
    if (dir === undefined) dir = new Vector3(0, 0, 1);
    if (origin === undefined) origin = new Vector3(0, 0, 0);
    if (length === undefined) length = 1;
    if (color === undefined) color = 0xffff00;
    if (headLength === undefined) headLength = 0.2 * length;
    if (headWidth === undefined) headWidth = 0.2 * headLength;

    if (_lineGeometry === undefined) {
      _lineGeometry = new BufferGeometry();

      _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

      _coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);

      _coneGeometry.translate(0, -0.5, 0);
    }

    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({
      color: color
    }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
      color: color
    }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
  }

  ArrowHelper.prototype = Object.create(Object3D.prototype);
  ArrowHelper.prototype.constructor = ArrowHelper;

  ArrowHelper.prototype.setDirection = function (dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();

      var radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians);
    }
  };

  ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
    if (headLength === undefined) headLength = 0.2 * length;
    if (headWidth === undefined) headWidth = 0.2 * headLength;
    this.line.scale.set(1, Math.max(0.0001, length - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
  };

  ArrowHelper.prototype.setColor = function (color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
  };

  ArrowHelper.prototype.copy = function (source) {
    Object3D.prototype.copy.call(this, source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  };

  ArrowHelper.prototype.clone = function () {
    return new this.constructor().copy(this);
  };

  function AxesHelper(size) {
    size = size || 1;
    var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
    var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: VertexColors
    });
    LineSegments.call(this, geometry, material);
  }

  AxesHelper.prototype = Object.create(LineSegments.prototype);
  AxesHelper.prototype.constructor = AxesHelper;
  var LOD_MIN = 4;
  var LOD_MAX = 8;
  var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
  var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  var MAX_SAMPLES = 20;
  var ENCODINGS = (_ENCODINGS = {}, _defineProperty(_ENCODINGS, LinearEncoding, 0), _defineProperty(_ENCODINGS, sRGBEncoding, 1), _defineProperty(_ENCODINGS, RGBEEncoding, 2), _defineProperty(_ENCODINGS, RGBM7Encoding, 3), _defineProperty(_ENCODINGS, RGBM16Encoding, 4), _defineProperty(_ENCODINGS, RGBDEncoding, 5), _defineProperty(_ENCODINGS, GammaEncoding, 6), _ENCODINGS);

  var _flatCamera = new OrthographicCamera();

  var _blurMaterial = _getBlurShader(MAX_SAMPLES);

  var _createPlanes2 = _createPlanes();

  function _createPlanes() {
    var _lodPlanes = [];
    var _sizeLods = [];
    var _sigmas = [];
    var lod = LOD_MAX;

    for (var i = 0; i < TOTAL_LODS; i++) {
      var sizeLod = Math.pow(2, lod);

      _sizeLods.push(sizeLod);

      var sigma = 1.0 / sizeLod;

      if (i > LOD_MAX - LOD_MIN) {
        sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
      } else if (i == 0) {
        sigma = 0;
      }

      _sigmas.push(sigma);

      var texelSize = 1.0 / (sizeLod - 1);
      var min = -texelSize / 2;
      var max = 1 + texelSize / 2;
      var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
      var cubeFaces = 6;
      var vertices = 6;
      var positionSize = 3;
      var uvSize = 2;
      var faceIndexSize = 1;
      var position = new Float32Array(positionSize * vertices * cubeFaces);
      var uv = new Float32Array(uvSize * vertices * cubeFaces);
      var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

      for (var face = 0; face < cubeFaces; face++) {
        var x = face % 3 * 2 / 3 - 1;
        var y = face > 2 ? 0 : -1;
        var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
        position.set(coordinates, positionSize * vertices * face);
        uv.set(uv1, uvSize * vertices * face);
        var fill = [face, face, face, face, face, face];
        faceIndex.set(fill, faceIndexSize * vertices * face);
      }

      var planes = new BufferGeometry();
      planes.setAttribute('position', new BufferAttribute(position, positionSize));
      planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
      planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));

      _lodPlanes.push(planes);

      if (lod > LOD_MIN) {
        lod--;
      }
    }

    return {
      _lodPlanes: _lodPlanes,
      _sizeLods: _sizeLods,
      _sigmas: _sigmas
    };
  }

  function _getBlurShader(maxSamples) {
    var weights = new Float32Array(maxSamples);
    var poleAxis = new Vector3(0, 1, 0);
    var shaderMaterial = new RawShaderMaterial({
      defines: {
        'n': maxSamples
      },
      uniforms: {
        'envMap': {
          value: null
        },
        'samples': {
          value: 1
        },
        'weights': {
          value: weights
        },
        'latitudinal': {
          value: false
        },
        'dTheta': {
          value: 0
        },
        'mipInt': {
          value: 0
        },
        'poleAxis': {
          value: poleAxis
        },
        'inputEncoding': {
          value: ENCODINGS[LinearEncoding]
        },
        'outputEncoding': {
          value: ENCODINGS[LinearEncoding]
        }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n".concat(_getEncodings(), "\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfor (int dir = -1; dir < 2; dir += 2) {\n\t\t\tif (i == 0 && dir == 1)\n\t\t\t\tcontinue;\n\t\t\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\t\t\tif (all(equal(axis, vec3(0.0))))\n\t\t\t\taxis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);\n\t\t\taxis = normalize(axis);\n\t\t\tfloat theta = dTheta * float(dir * i);\n\t\t\tfloat cosTheta = cos(theta);\n\t\t\t// Rodrigues' axis-angle rotation\n\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t\t\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\tweights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);\n\t\t}\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    shaderMaterial.type = 'SphericalGaussianBlur';
    return shaderMaterial;
  }

  function _getCommonVertexShader() {
    return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t";
  }

  function _getEncodings() {
    return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t";
  }

  Curve.create = function (construct, getPoint) {
    console.log('THREE.Curve.create() has been deprecated');
    construct.prototype = Object.create(Curve.prototype);
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;
    return construct;
  };

  Object.assign(CurvePath.prototype, {
    createPointsGeometry: function createPointsGeometry(divisions) {
      console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
      var pts = this.getPoints(divisions);
      return this.createGeometry(pts);
    },
    createSpacedPointsGeometry: function createSpacedPointsGeometry(divisions) {
      console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
      var pts = this.getSpacedPoints(divisions);
      return this.createGeometry(pts);
    },
    createGeometry: function createGeometry(points) {
      console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
      var geometry = new Geometry();

      for (var i = 0, l = points.length; i < l; i++) {
        var point = points[i];
        geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
      }

      return geometry;
    }
  });
  Object.assign(Path.prototype, {
    fromPoints: function fromPoints(points) {
      console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
      return this.setFromPoints(points);
    }
  });

  function Spline(points) {
    console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
    CatmullRomCurve3.call(this, points);
    this.type = 'catmullrom';
  }

  Spline.prototype = Object.create(CatmullRomCurve3.prototype);
  Object.assign(Spline.prototype, {
    initFromArray: function initFromArray() {
      console.error('THREE.Spline: .initFromArray() has been removed.');
    },
    getControlPointsArray: function getControlPointsArray() {
      console.error('THREE.Spline: .getControlPointsArray() has been removed.');
    },
    reparametrizeByArcLength: function reparametrizeByArcLength() {
      console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
    }
  });

  GridHelper.prototype.setColors = function () {
    console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
  };

  SkeletonHelper.prototype.update = function () {
    console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
  };

  Object.assign(Loader.prototype, {
    extractUrlBase: function extractUrlBase(url) {
      console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
      return LoaderUtils.extractUrlBase(url);
    }
  });
  Loader.Handlers = {
    add: function add() {
      console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
    },
    get: function get() {
      console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
    }
  };
  Object.assign(ObjectLoader.prototype, {
    setTexturePath: function setTexturePath(value) {
      console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
      return this.setResourcePath(value);
    }
  });
  Object.assign(Box2.prototype, {
    center: function center(optionalTarget) {
      console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
      return this.getCenter(optionalTarget);
    },
    empty: function empty() {
      console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
      return this.isEmpty();
    },
    isIntersectionBox: function isIntersectionBox(box) {
      console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
      return this.intersectsBox(box);
    },
    size: function size(optionalTarget) {
      console.warn('THREE.Box2: .size() has been renamed to .getSize().');
      return this.getSize(optionalTarget);
    }
  });
  Object.assign(Box3.prototype, {
    center: function center(optionalTarget) {
      console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
      return this.getCenter(optionalTarget);
    },
    empty: function empty() {
      console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
      return this.isEmpty();
    },
    isIntersectionBox: function isIntersectionBox(box) {
      console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
      return this.intersectsBox(box);
    },
    isIntersectionSphere: function isIntersectionSphere(sphere) {
      console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
      return this.intersectsSphere(sphere);
    },
    size: function size(optionalTarget) {
      console.warn('THREE.Box3: .size() has been renamed to .getSize().');
      return this.getSize(optionalTarget);
    }
  });

  Frustum.prototype.setFromMatrix = function (m) {
    console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
    return this.setFromProjectionMatrix(m);
  };

  Line3.prototype.center = function (optionalTarget) {
    console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
  };

  Object.assign(MathUtils, {
    random16: function random16() {
      console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
      return Math.random();
    },
    nearestPowerOfTwo: function nearestPowerOfTwo(value) {
      console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
      return MathUtils.floorPowerOfTwo(value);
    },
    nextPowerOfTwo: function nextPowerOfTwo(value) {
      console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
      return MathUtils.ceilPowerOfTwo(value);
    }
  });
  Object.assign(Matrix3.prototype, {
    flattenToArrayOffset: function flattenToArrayOffset(array, offset) {
      console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(array, offset);
    },
    multiplyVector3: function multiplyVector3(vector) {
      console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
      return vector.applyMatrix3(this);
    },
    multiplyVector3Array: function multiplyVector3Array() {
      console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
    },
    applyToBufferAttribute: function applyToBufferAttribute(attribute) {
      console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
      return attribute.applyMatrix3(this);
    },
    applyToVector3Array: function applyToVector3Array() {
      console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
    }
  });
  Object.assign(Matrix4.prototype, {
    extractPosition: function extractPosition(m) {
      console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
      return this.copyPosition(m);
    },
    flattenToArrayOffset: function flattenToArrayOffset(array, offset) {
      console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(array, offset);
    },
    getPosition: function getPosition() {
      console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
      return new Vector3().setFromMatrixColumn(this, 3);
    },
    setRotationFromQuaternion: function setRotationFromQuaternion(q) {
      console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
      return this.makeRotationFromQuaternion(q);
    },
    multiplyToArray: function multiplyToArray() {
      console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
    },
    multiplyVector3: function multiplyVector3(vector) {
      console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
      return vector.applyMatrix4(this);
    },
    multiplyVector4: function multiplyVector4(vector) {
      console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
      return vector.applyMatrix4(this);
    },
    multiplyVector3Array: function multiplyVector3Array() {
      console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
    },
    rotateAxis: function rotateAxis(v) {
      console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
      v.transformDirection(this);
    },
    crossVector: function crossVector(vector) {
      console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
      return vector.applyMatrix4(this);
    },
    translate: function translate() {
      console.error('THREE.Matrix4: .translate() has been removed.');
    },
    rotateX: function rotateX() {
      console.error('THREE.Matrix4: .rotateX() has been removed.');
    },
    rotateY: function rotateY() {
      console.error('THREE.Matrix4: .rotateY() has been removed.');
    },
    rotateZ: function rotateZ() {
      console.error('THREE.Matrix4: .rotateZ() has been removed.');
    },
    rotateByAxis: function rotateByAxis() {
      console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
    },
    applyToBufferAttribute: function applyToBufferAttribute(attribute) {
      console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
      return attribute.applyMatrix4(this);
    },
    applyToVector3Array: function applyToVector3Array() {
      console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
    },
    makeFrustum: function makeFrustum(left, right, bottom, top, near, far) {
      console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
      return this.makePerspective(left, right, top, bottom, near, far);
    }
  });

  Plane.prototype.isIntersectionLine = function (line) {
    console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
    return this.intersectsLine(line);
  };

  Quaternion.prototype.multiplyVector3 = function (vector) {
    console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
    return vector.applyQuaternion(this);
  };

  Object.assign(Ray.prototype, {
    isIntersectionBox: function isIntersectionBox(box) {
      console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
      return this.intersectsBox(box);
    },
    isIntersectionPlane: function isIntersectionPlane(plane) {
      console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
      return this.intersectsPlane(plane);
    },
    isIntersectionSphere: function isIntersectionSphere(sphere) {
      console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
      return this.intersectsSphere(sphere);
    }
  });
  Object.assign(Triangle.prototype, {
    area: function area() {
      console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
      return this.getArea();
    },
    barycoordFromPoint: function barycoordFromPoint(point, target) {
      console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
      return this.getBarycoord(point, target);
    },
    midpoint: function midpoint(target) {
      console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
      return this.getMidpoint(target);
    },
    normal: function normal(target) {
      console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
      return this.getNormal(target);
    },
    plane: function plane(target) {
      console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
      return this.getPlane(target);
    }
  });
  Object.assign(Triangle, {
    barycoordFromPoint: function barycoordFromPoint(point, a, b, c, target) {
      console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
      return Triangle.getBarycoord(point, a, b, c, target);
    },
    normal: function normal(a, b, c, target) {
      console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
      return Triangle.getNormal(a, b, c, target);
    }
  });
  Object.assign(Shape.prototype, {
    extractAllPoints: function extractAllPoints(divisions) {
      console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
      return this.extractPoints(divisions);
    },
    extrude: function extrude(options) {
      console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
      return new ExtrudeGeometry(this, options);
    },
    makeGeometry: function makeGeometry(options) {
      console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
      return new ShapeGeometry(this, options);
    }
  });
  Object.assign(Vector2.prototype, {
    fromAttribute: function fromAttribute(attribute, index, offset) {
      console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
      return this.fromBufferAttribute(attribute, index, offset);
    },
    distanceToManhattan: function distanceToManhattan(v) {
      console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
      return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function lengthManhattan() {
      console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
      return this.manhattanLength();
    }
  });
  Object.assign(Vector3.prototype, {
    setEulerFromRotationMatrix: function setEulerFromRotationMatrix() {
      console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
    },
    setEulerFromQuaternion: function setEulerFromQuaternion() {
      console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
    },
    getPositionFromMatrix: function getPositionFromMatrix(m) {
      console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
      return this.setFromMatrixPosition(m);
    },
    getScaleFromMatrix: function getScaleFromMatrix(m) {
      console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
      return this.setFromMatrixScale(m);
    },
    getColumnFromMatrix: function getColumnFromMatrix(index, matrix) {
      console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
      return this.setFromMatrixColumn(matrix, index);
    },
    applyProjection: function applyProjection(m) {
      console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
      return this.applyMatrix4(m);
    },
    fromAttribute: function fromAttribute(attribute, index, offset) {
      console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
      return this.fromBufferAttribute(attribute, index, offset);
    },
    distanceToManhattan: function distanceToManhattan(v) {
      console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
      return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function lengthManhattan() {
      console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
      return this.manhattanLength();
    }
  });
  Object.assign(Vector4.prototype, {
    fromAttribute: function fromAttribute(attribute, index, offset) {
      console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
      return this.fromBufferAttribute(attribute, index, offset);
    },
    lengthManhattan: function lengthManhattan() {
      console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
      return this.manhattanLength();
    }
  });
  Object.assign(Geometry.prototype, {
    computeTangents: function computeTangents() {
      console.error('THREE.Geometry: .computeTangents() has been removed.');
    },
    computeLineDistances: function computeLineDistances() {
      console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');
    },
    applyMatrix: function applyMatrix(matrix) {
      console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');
      return this.applyMatrix4(matrix);
    }
  });
  Object.assign(Object3D.prototype, {
    getChildByName: function getChildByName(name) {
      console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
      return this.getObjectByName(name);
    },
    renderDepth: function renderDepth() {
      console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
    },
    translate: function translate(distance, axis) {
      console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
      return this.translateOnAxis(axis, distance);
    },
    getWorldRotation: function getWorldRotation() {
      console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
    },
    applyMatrix: function applyMatrix(matrix) {
      console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
      return this.applyMatrix4(matrix);
    }
  });
  Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
      get: function get() {
        console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
        return this.rotation.order;
      },
      set: function set(value) {
        console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
        this.rotation.order = value;
      }
    },
    useQuaternion: {
      get: function get() {
        console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
      },
      set: function set() {
        console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
      }
    }
  });
  Object.assign(Mesh.prototype, {
    setDrawMode: function setDrawMode() {
      console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
    }
  });
  Object.defineProperties(Mesh.prototype, {
    drawMode: {
      get: function get() {
        console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
        return TrianglesDrawMode;
      },
      set: function set() {
        console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
      }
    }
  });
  Object.defineProperties(LOD.prototype, {
    objects: {
      get: function get() {
        console.warn('THREE.LOD: .objects has been renamed to .levels.');
        return this.levels;
      }
    }
  });
  Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
    get: function get() {
      console.warn('THREE.Skeleton: useVertexTexture has been removed.');
    },
    set: function set() {
      console.warn('THREE.Skeleton: useVertexTexture has been removed.');
    }
  });

  SkinnedMesh.prototype.initBones = function () {
    console.error('THREE.SkinnedMesh: initBones() has been removed.');
  };

  Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
    get: function get() {
      console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
      return this.arcLengthDivisions;
    },
    set: function set(value) {
      console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
      this.arcLengthDivisions = value;
    }
  });

  PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. " + "Use .setFocalLength and .filmGauge for a photographic setup.");
    if (filmGauge !== undefined) this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
  };

  Object.defineProperties(Light.prototype, {
    onlyShadow: {
      set: function set() {
        console.warn('THREE.Light: .onlyShadow has been removed.');
      }
    },
    shadowCameraFov: {
      set: function set(value) {
        console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
        this.shadow.camera.fov = value;
      }
    },
    shadowCameraLeft: {
      set: function set(value) {
        console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
        this.shadow.camera.left = value;
      }
    },
    shadowCameraRight: {
      set: function set(value) {
        console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
        this.shadow.camera.right = value;
      }
    },
    shadowCameraTop: {
      set: function set(value) {
        console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
        this.shadow.camera.top = value;
      }
    },
    shadowCameraBottom: {
      set: function set(value) {
        console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
        this.shadow.camera.bottom = value;
      }
    },
    shadowCameraNear: {
      set: function set(value) {
        console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
        this.shadow.camera.near = value;
      }
    },
    shadowCameraFar: {
      set: function set(value) {
        console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
        this.shadow.camera.far = value;
      }
    },
    shadowCameraVisible: {
      set: function set() {
        console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
      }
    },
    shadowBias: {
      set: function set(value) {
        console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
        this.shadow.bias = value;
      }
    },
    shadowDarkness: {
      set: function set() {
        console.warn('THREE.Light: .shadowDarkness has been removed.');
      }
    },
    shadowMapWidth: {
      set: function set(value) {
        console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
        this.shadow.mapSize.width = value;
      }
    },
    shadowMapHeight: {
      set: function set(value) {
        console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
        this.shadow.mapSize.height = value;
      }
    }
  });
  Object.defineProperties(BufferAttribute.prototype, {
    length: {
      get: function get() {
        console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
        return this.array.length;
      }
    },
    dynamic: {
      get: function get() {
        console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
        return this.usage === DynamicDrawUsage;
      },
      set: function set() {
        console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
        this.setUsage(DynamicDrawUsage);
      }
    }
  });
  Object.assign(BufferAttribute.prototype, {
    setDynamic: function setDynamic(value) {
      console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
      this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
      return this;
    },
    copyIndicesArray: function copyIndicesArray() {
      console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
    },
    setArray: function setArray() {
      console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
    }
  });
  Object.assign(BufferGeometry.prototype, {
    addIndex: function addIndex(index) {
      console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
      this.setIndex(index);
    },
    addAttribute: function addAttribute(name, attribute) {
      console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');

      if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
        console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
        return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
      }

      if (name === 'index') {
        console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
        this.setIndex(attribute);
        return this;
      }

      return this.setAttribute(name, attribute);
    },
    addDrawCall: function addDrawCall(start, count, indexOffset) {
      if (indexOffset !== undefined) {
        console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
      }

      console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
      this.addGroup(start, count);
    },
    clearDrawCalls: function clearDrawCalls() {
      console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
      this.clearGroups();
    },
    computeTangents: function computeTangents() {
      console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
    },
    computeOffsets: function computeOffsets() {
      console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
    },
    removeAttribute: function removeAttribute(name) {
      console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
      return this.deleteAttribute(name);
    },
    applyMatrix: function applyMatrix(matrix) {
      console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
      return this.applyMatrix4(matrix);
    }
  });
  Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
      get: function get() {
        console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
        return this.groups;
      }
    },
    offsets: {
      get: function get() {
        console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
        return this.groups;
      }
    }
  });
  Object.defineProperties(InterleavedBuffer.prototype, {
    dynamic: {
      get: function get() {
        console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
        return this.usage === DynamicDrawUsage;
      },
      set: function set(value) {
        console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
        this.setUsage(value);
      }
    }
  });
  Object.assign(InterleavedBuffer.prototype, {
    setDynamic: function setDynamic(value) {
      console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
      this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
      return this;
    },
    setArray: function setArray() {
      console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
    }
  });
  Object.assign(ExtrudeBufferGeometry.prototype, {
    getArrays: function getArrays() {
      console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');
    },
    addShapeList: function addShapeList() {
      console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');
    },
    addShape: function addShape() {
      console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');
    }
  });
  Object.defineProperties(Uniform.prototype, {
    dynamic: {
      set: function set() {
        console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
      }
    },
    onUpdate: {
      value: function value() {
        console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
        return this;
      }
    }
  });
  Object.defineProperties(Material.prototype, {
    wrapAround: {
      get: function get() {
        console.warn('THREE.Material: .wrapAround has been removed.');
      },
      set: function set() {
        console.warn('THREE.Material: .wrapAround has been removed.');
      }
    },
    overdraw: {
      get: function get() {
        console.warn('THREE.Material: .overdraw has been removed.');
      },
      set: function set() {
        console.warn('THREE.Material: .overdraw has been removed.');
      }
    },
    wrapRGB: {
      get: function get() {
        console.warn('THREE.Material: .wrapRGB has been removed.');
        return new Color();
      }
    },
    shading: {
      get: function get() {
        console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
      },
      set: function set(value) {
        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        this.flatShading = value === FlatShading;
      }
    },
    stencilMask: {
      get: function get() {
        console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
        return this.stencilFuncMask;
      },
      set: function set(value) {
        console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
        this.stencilFuncMask = value;
      }
    }
  });
  Object.defineProperties(MeshPhongMaterial.prototype, {
    metal: {
      get: function get() {
        console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
        return false;
      },
      set: function set() {
        console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
      }
    }
  });
  Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
      get: function get() {
        console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
        return this.extensions.derivatives;
      },
      set: function set(value) {
        console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
        this.extensions.derivatives = value;
      }
    }
  });
  Object.assign(WebGLRenderer.prototype, {
    clearTarget: function clearTarget(renderTarget, color, depth, stencil) {
      console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
      this.setRenderTarget(renderTarget);
      this.clear(color, depth, stencil);
    },
    animate: function animate(callback) {
      console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
      this.setAnimationLoop(callback);
    },
    getCurrentRenderTarget: function getCurrentRenderTarget() {
      console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
      return this.getRenderTarget();
    },
    getMaxAnisotropy: function getMaxAnisotropy() {
      console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
      return this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function getPrecision() {
      console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
      return this.capabilities.precision;
    },
    resetGLState: function resetGLState() {
      console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
      return this.state.reset();
    },
    supportsFloatTextures: function supportsFloatTextures() {
      console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
      return this.extensions.get('OES_texture_float');
    },
    supportsHalfFloatTextures: function supportsHalfFloatTextures() {
      console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
      return this.extensions.get('OES_texture_half_float');
    },
    supportsStandardDerivatives: function supportsStandardDerivatives() {
      console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
      return this.extensions.get('OES_standard_derivatives');
    },
    supportsCompressedTextureS3TC: function supportsCompressedTextureS3TC() {
      console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
      return this.extensions.get('WEBGL_compressed_texture_s3tc');
    },
    supportsCompressedTexturePVRTC: function supportsCompressedTexturePVRTC() {
      console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
      return this.extensions.get('WEBGL_compressed_texture_pvrtc');
    },
    supportsBlendMinMax: function supportsBlendMinMax() {
      console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
      return this.extensions.get('EXT_blend_minmax');
    },
    supportsVertexTextures: function supportsVertexTextures() {
      console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
      return this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function supportsInstancedArrays() {
      console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
      return this.extensions.get('ANGLE_instanced_arrays');
    },
    enableScissorTest: function enableScissorTest(_boolean2) {
      console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
      this.setScissorTest(_boolean2);
    },
    initMaterial: function initMaterial() {
      console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
    },
    addPrePlugin: function addPrePlugin() {
      console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
    },
    addPostPlugin: function addPostPlugin() {
      console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
    },
    updateShadowMap: function updateShadowMap() {
      console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
    },
    setFaceCulling: function setFaceCulling() {
      console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
    },
    allocTextureUnit: function allocTextureUnit() {
      console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
    },
    setTexture: function setTexture() {
      console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
    },
    setTexture2D: function setTexture2D() {
      console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
    },
    setTextureCube: function setTextureCube() {
      console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
    },
    getActiveMipMapLevel: function getActiveMipMapLevel() {
      console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
      return this.getActiveMipmapLevel();
    }
  });
  Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
      get: function get() {
        return this.shadowMap.enabled;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
        this.shadowMap.enabled = value;
      }
    },
    shadowMapType: {
      get: function get() {
        return this.shadowMap.type;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
        this.shadowMap.type = value;
      }
    },
    shadowMapCullFace: {
      get: function get() {
        console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
        return undefined;
      },
      set: function set() {
        console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
      }
    },
    context: {
      get: function get() {
        console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
        return this.getContext();
      }
    },
    vr: {
      get: function get() {
        console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
        return this.xr;
      }
    },
    gammaInput: {
      get: function get() {
        console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
        return false;
      },
      set: function set() {
        console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
      }
    },
    gammaOutput: {
      get: function get() {
        console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
        return false;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
        this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
      }
    }
  });
  Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
      get: function get() {
        console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
        return undefined;
      },
      set: function set() {
        console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
      }
    },
    renderReverseSided: {
      get: function get() {
        console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
        return undefined;
      },
      set: function set() {
        console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
      }
    },
    renderSingleSided: {
      get: function get() {
        console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
        return undefined;
      },
      set: function set() {
        console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
      }
    }
  });
  Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
      get: function get() {
        console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
        return this.texture.wrapS;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
        this.texture.wrapS = value;
      }
    },
    wrapT: {
      get: function get() {
        console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
        return this.texture.wrapT;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
        this.texture.wrapT = value;
      }
    },
    magFilter: {
      get: function get() {
        console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
        return this.texture.magFilter;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
        this.texture.magFilter = value;
      }
    },
    minFilter: {
      get: function get() {
        console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
        return this.texture.minFilter;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
        this.texture.minFilter = value;
      }
    },
    anisotropy: {
      get: function get() {
        console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
        return this.texture.anisotropy;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
        this.texture.anisotropy = value;
      }
    },
    offset: {
      get: function get() {
        console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
        return this.texture.offset;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
        this.texture.offset = value;
      }
    },
    repeat: {
      get: function get() {
        console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
        return this.texture.repeat;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
        this.texture.repeat = value;
      }
    },
    format: {
      get: function get() {
        console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
        return this.texture.format;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
        this.texture.format = value;
      }
    },
    type: {
      get: function get() {
        console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
        return this.texture.type;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
        this.texture.type = value;
      }
    },
    generateMipmaps: {
      get: function get() {
        console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
        return this.texture.generateMipmaps;
      },
      set: function set(value) {
        console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
        this.texture.generateMipmaps = value;
      }
    }
  });
  Object.defineProperties(Audio.prototype, {
    load: {
      value: function value(file) {
        console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
        var scope = this;
        var audioLoader = new AudioLoader();
        audioLoader.load(file, function (buffer) {
          scope.setBuffer(buffer);
        });
        return this;
      }
    },
    startTime: {
      set: function set() {
        console.warn('THREE.Audio: .startTime is now .play( delay ).');
      }
    }
  });

  AudioAnalyser.prototype.getData = function () {
    console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
    return this.getFrequencyData();
  };

  CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
    console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
    return this.update(renderer, scene);
  };

  ImageUtils.crossOrigin = undefined;

  ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
    console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
    var loader = new TextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    var texture = loader.load(url, onLoad, undefined, onError);
    if (mapping) texture.mapping = mapping;
    return texture;
  };

  ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
    console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
    var loader = new CubeTextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    var texture = loader.load(urls, onLoad, undefined, onError);
    if (mapping) texture.mapping = mapping;
    return texture;
  };

  ImageUtils.loadCompressedTexture = function () {
    console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
  };

  ImageUtils.loadCompressedTextureCube = function () {
    console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
  };

  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
      detail: {
        revision: REVISION
      }
    }));
  }

  var Event = function Event(type) {
    _classCallCheck(this, Event);

    this.type = type;
    this.target = null;
  };

  var EventTarget = function () {
    function EventTarget() {
      _classCallCheck(this, EventTarget);

      this.listenerFunctions = new Map();
      this.listenerObjects = new Map();
    }

    _createClass(EventTarget, [{
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        var m = typeof listener === "function" ? this.listenerFunctions : this.listenerObjects;

        if (m.has(type)) {
          m.get(type).add(listener);
        } else {
          m.set(type, new Set([listener]));
        }
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener) {
        var m = typeof listener === "function" ? this.listenerFunctions : this.listenerObjects;

        if (m.has(type)) {
          var listeners = m.get(type);
          listeners["delete"](listener);

          if (listeners.size === 0) {
            m["delete"](type);
          }
        }
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
        var listenerFunctions = target.listenerFunctions;
        var listenerObjects = target.listenerObjects;
        var listeners, listener;
        event.target = target;

        if (listenerFunctions.has(event.type)) {
          listeners = listenerFunctions.get(event.type);
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              listener = _step.value;
              listener.call(target, event);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        if (listenerObjects.has(event.type)) {
          listeners = listenerObjects.get(event.type);
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = listeners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              listener = _step2.value;
              listener.handleEvent(event);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      }
    }]);

    return EventTarget;
  }();

  function ___$insertStyle(css) {
    if (!css) {
      return;
    }

    if (typeof window === 'undefined') {
      return;
    }

    var style = document.createElement('style');
    style.setAttribute('type', 'text/css');
    style.innerHTML = css;
    document.head.appendChild(style);
    return css;
  }

  function colorToString(color, forceCSSHex) {
    var colorFormat = color.__state.conversionName.toString();

    var r = Math.round(color.r);
    var g = Math.round(color.g);
    var b = Math.round(color.b);
    var a = color.a;
    var h = Math.round(color.h);
    var s = color.s.toFixed(1);
    var v = color.v.toFixed(1);

    if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
      var str = color.hex.toString(16);

      while (str.length < 6) {
        str = '0' + str;
      }

      return '#' + str;
    } else if (colorFormat === 'CSS_RGB') {
      return 'rgb(' + r + ',' + g + ',' + b + ')';
    } else if (colorFormat === 'CSS_RGBA') {
      return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    } else if (colorFormat === 'HEX') {
      return '0x' + color.hex.toString(16);
    } else if (colorFormat === 'RGB_ARRAY') {
      return '[' + r + ',' + g + ',' + b + ']';
    } else if (colorFormat === 'RGBA_ARRAY') {
      return '[' + r + ',' + g + ',' + b + ',' + a + ']';
    } else if (colorFormat === 'RGB_OBJ') {
      return '{r:' + r + ',g:' + g + ',b:' + b + '}';
    } else if (colorFormat === 'RGBA_OBJ') {
      return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
    } else if (colorFormat === 'HSV_OBJ') {
      return '{h:' + h + ',s:' + s + ',v:' + v + '}';
    } else if (colorFormat === 'HSVA_OBJ') {
      return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
    }

    return 'unknown format';
  }

  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;
  var Common = {
    BREAK: {},
    extend: function extend(target) {
      this.each(ARR_SLICE.call(arguments, 1), function (obj) {
        var keys = this.isObject(obj) ? Object.keys(obj) : [];
        keys.forEach(function (key) {
          if (!this.isUndefined(obj[key])) {
            target[key] = obj[key];
          }
        }.bind(this));
      }, this);
      return target;
    },
    defaults: function defaults(target) {
      this.each(ARR_SLICE.call(arguments, 1), function (obj) {
        var keys = this.isObject(obj) ? Object.keys(obj) : [];
        keys.forEach(function (key) {
          if (this.isUndefined(target[key])) {
            target[key] = obj[key];
          }
        }.bind(this));
      }, this);
      return target;
    },
    compose: function compose() {
      var toCall = ARR_SLICE.call(arguments);
      return function () {
        var args = ARR_SLICE.call(arguments);

        for (var i = toCall.length - 1; i >= 0; i--) {
          args = [toCall[i].apply(this, args)];
        }

        return args[0];
      };
    },
    each: function each(obj, itr, scope) {
      if (!obj) {
        return;
      }

      if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
        obj.forEach(itr, scope);
      } else if (obj.length === obj.length + 0) {
        var key = void 0;
        var l = void 0;

        for (key = 0, l = obj.length; key < l; key++) {
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
            return;
          }
        }
      } else {
        for (var _key in obj) {
          if (itr.call(scope, obj[_key], _key) === this.BREAK) {
            return;
          }
        }
      }
    },
    defer: function defer(fnc) {
      setTimeout(fnc, 0);
    },
    debounce: function debounce(func, threshold, callImmediately) {
      var timeout = void 0;
      return function () {
        var obj = this;
        var args = arguments;

        function delayed() {
          timeout = null;
          if (!callImmediately) func.apply(obj, args);
        }

        var callNow = callImmediately || !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(delayed, threshold);

        if (callNow) {
          func.apply(obj, args);
        }
      };
    },
    toArray: function toArray(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },
    isUndefined: function isUndefined(obj) {
      return obj === undefined;
    },
    isNull: function isNull(obj) {
      return obj === null;
    },
    isNaN: function (_isNaN) {
      function isNaN(_x) {
        return _isNaN.apply(this, arguments);
      }

      isNaN.toString = function () {
        return _isNaN.toString();
      };

      return isNaN;
    }(function (obj) {
      return isNaN(obj);
    }),
    isArray: Array.isArray || function (obj) {
      return obj.constructor === Array;
    },
    isObject: function isObject(obj) {
      return obj === Object(obj);
    },
    isNumber: function isNumber(obj) {
      return obj === obj + 0;
    },
    isString: function isString(obj) {
      return obj === obj + '';
    },
    isBoolean: function isBoolean(obj) {
      return obj === false || obj === true;
    },
    isFunction: function isFunction(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  };
  var INTERPRETATIONS = [{
    litmus: Common.isString,
    conversions: {
      THREE_CHAR_HEX: {
        read: function read(original) {
          var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);

          if (test === null) {
            return false;
          }

          return {
            space: 'HEX',
            hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
          };
        },
        write: colorToString
      },
      SIX_CHAR_HEX: {
        read: function read(original) {
          var test = original.match(/^#([A-F0-9]{6})$/i);

          if (test === null) {
            return false;
          }

          return {
            space: 'HEX',
            hex: parseInt('0x' + test[1].toString(), 0)
          };
        },
        write: colorToString
      },
      CSS_RGB: {
        read: function read(original) {
          var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);

          if (test === null) {
            return false;
          }

          return {
            space: 'RGB',
            r: parseFloat(test[1]),
            g: parseFloat(test[2]),
            b: parseFloat(test[3])
          };
        },
        write: colorToString
      },
      CSS_RGBA: {
        read: function read(original) {
          var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);

          if (test === null) {
            return false;
          }

          return {
            space: 'RGB',
            r: parseFloat(test[1]),
            g: parseFloat(test[2]),
            b: parseFloat(test[3]),
            a: parseFloat(test[4])
          };
        },
        write: colorToString
      }
    }
  }, {
    litmus: Common.isNumber,
    conversions: {
      HEX: {
        read: function read(original) {
          return {
            space: 'HEX',
            hex: original,
            conversionName: 'HEX'
          };
        },
        write: function write(color) {
          return color.hex;
        }
      }
    }
  }, {
    litmus: Common.isArray,
    conversions: {
      RGB_ARRAY: {
        read: function read(original) {
          if (original.length !== 3) {
            return false;
          }

          return {
            space: 'RGB',
            r: original[0],
            g: original[1],
            b: original[2]
          };
        },
        write: function write(color) {
          return [color.r, color.g, color.b];
        }
      },
      RGBA_ARRAY: {
        read: function read(original) {
          if (original.length !== 4) return false;
          return {
            space: 'RGB',
            r: original[0],
            g: original[1],
            b: original[2],
            a: original[3]
          };
        },
        write: function write(color) {
          return [color.r, color.g, color.b, color.a];
        }
      }
    }
  }, {
    litmus: Common.isObject,
    conversions: {
      RGBA_OBJ: {
        read: function read(original) {
          if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
            return {
              space: 'RGB',
              r: original.r,
              g: original.g,
              b: original.b,
              a: original.a
            };
          }

          return false;
        },
        write: function write(color) {
          return {
            r: color.r,
            g: color.g,
            b: color.b,
            a: color.a
          };
        }
      },
      RGB_OBJ: {
        read: function read(original) {
          if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
            return {
              space: 'RGB',
              r: original.r,
              g: original.g,
              b: original.b
            };
          }

          return false;
        },
        write: function write(color) {
          return {
            r: color.r,
            g: color.g,
            b: color.b
          };
        }
      },
      HSVA_OBJ: {
        read: function read(original) {
          if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
            return {
              space: 'HSV',
              h: original.h,
              s: original.s,
              v: original.v,
              a: original.a
            };
          }

          return false;
        },
        write: function write(color) {
          return {
            h: color.h,
            s: color.s,
            v: color.v,
            a: color.a
          };
        }
      },
      HSV_OBJ: {
        read: function read(original) {
          if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
            return {
              space: 'HSV',
              h: original.h,
              s: original.s,
              v: original.v
            };
          }

          return false;
        },
        write: function write(color) {
          return {
            h: color.h,
            s: color.s,
            v: color.v
          };
        }
      }
    }
  }];
  var result = void 0;
  var toReturn = void 0;

  var interpret = function interpret() {
    toReturn = false;
    var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
    Common.each(INTERPRETATIONS, function (family) {
      if (family.litmus(original)) {
        Common.each(family.conversions, function (conversion, conversionName) {
          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return Common.BREAK;
          }
        });
        return Common.BREAK;
      }
    });
    return toReturn;
  };

  var tmpComponent = void 0;
  var ColorMath = {
    hsv_to_rgb: function hsv_to_rgb(h, s, v) {
      var hi = Math.floor(h / 60) % 6;
      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - f * s);
      var t = v * (1.0 - (1.0 - f) * s);
      var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };
    },
    rgb_to_hsv: function rgb_to_hsv(r, g, b) {
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h = void 0;
      var s = void 0;

      if (max !== 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }

      h /= 6;

      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },
    rgb_to_hex: function rgb_to_hex(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },
    component_from_hex: function component_from_hex(hex, componentIndex) {
      return hex >> componentIndex * 8 & 0xFF;
    },
    hex_with_component: function hex_with_component(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
    }
  };

  var _typeof$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
    return _typeof(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
  };

  var classCallCheck = function classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
  };

  var Color$1 = function () {
    function Color() {
      classCallCheck(this, Color);
      this.__state = interpret.apply(this, arguments);

      if (this.__state === false) {
        throw new Error('Failed to interpret color arguments');
      }

      this.__state.a = this.__state.a || 1;
    }

    createClass(Color, [{
      key: 'toString',
      value: function toString() {
        return colorToString(this);
      }
    }, {
      key: 'toHexString',
      value: function toHexString() {
        return colorToString(this, true);
      }
    }, {
      key: 'toOriginal',
      value: function toOriginal() {
        return this.__state.conversion.write(this);
      }
    }]);
    return Color;
  }();

  function defineRGBComponent(target, component, componentHexIndex) {
    Object.defineProperty(target, component, {
      get: function get$$1() {
        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        Color$1.recalculateRGB(this, component, componentHexIndex);
        return this.__state[component];
      },
      set: function set$$1(v) {
        if (this.__state.space !== 'RGB') {
          Color$1.recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;
      }
    });
  }

  function defineHSVComponent(target, component) {
    Object.defineProperty(target, component, {
      get: function get$$1() {
        if (this.__state.space === 'HSV') {
          return this.__state[component];
        }

        Color$1.recalculateHSV(this);
        return this.__state[component];
      },
      set: function set$$1(v) {
        if (this.__state.space !== 'HSV') {
          Color$1.recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;
      }
    });
  }

  Color$1.recalculateRGB = function (color, component, componentHexIndex) {
    if (color.__state.space === 'HEX') {
      color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
    } else if (color.__state.space === 'HSV') {
      Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
    } else {
      throw new Error('Corrupted color state');
    }
  };

  Color$1.recalculateHSV = function (color) {
    var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
    Common.extend(color.__state, {
      s: result.s,
      v: result.v
    });

    if (!Common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (Common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }
  };

  Color$1.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
  defineRGBComponent(Color$1.prototype, 'r', 2);
  defineRGBComponent(Color$1.prototype, 'g', 1);
  defineRGBComponent(Color$1.prototype, 'b', 0);
  defineHSVComponent(Color$1.prototype, 'h');
  defineHSVComponent(Color$1.prototype, 's');
  defineHSVComponent(Color$1.prototype, 'v');
  Object.defineProperty(Color$1.prototype, 'a', {
    get: function get$$1() {
      return this.__state.a;
    },
    set: function set$$1(v) {
      this.__state.a = v;
    }
  });
  Object.defineProperty(Color$1.prototype, 'hex', {
    get: function get$$1() {
      if (!this.__state.space !== 'HEX') {
        this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;
    },
    set: function set$$1(v) {
      this.__state.space = 'HEX';
      this.__state.hex = v;
    }
  });

  var Controller = function () {
    function Controller(object, property) {
      classCallCheck(this, Controller);
      this.initialValue = object[property];
      this.domElement = document.createElement('div');
      this.object = object;
      this.property = property;
      this.__onChange = undefined;
      this.__onFinishChange = undefined;
    }

    createClass(Controller, [{
      key: 'onChange',
      value: function onChange(fnc) {
        this.__onChange = fnc;
        return this;
      }
    }, {
      key: 'onFinishChange',
      value: function onFinishChange(fnc) {
        this.__onFinishChange = fnc;
        return this;
      }
    }, {
      key: 'setValue',
      value: function setValue(newValue) {
        this.object[this.property] = newValue;

        if (this.__onChange) {
          this.__onChange.call(this, newValue);
        }

        this.updateDisplay();
        return this;
      }
    }, {
      key: 'getValue',
      value: function getValue() {
        return this.object[this.property];
      }
    }, {
      key: 'updateDisplay',
      value: function updateDisplay() {
        return this;
      }
    }, {
      key: 'isModified',
      value: function isModified() {
        return this.initialValue !== this.getValue();
      }
    }]);
    return Controller;
  }();

  var EVENT_MAP = {
    HTMLEvents: ['change'],
    MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
    KeyboardEvents: ['keydown']
  };
  var EVENT_MAP_INV = {};
  Common.each(EVENT_MAP, function (v, k) {
    Common.each(v, function (e) {
      EVENT_MAP_INV[e] = k;
    });
  });
  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {
    if (val === '0' || Common.isUndefined(val)) {
      return 0;
    }

    var match = val.match(CSS_VALUE_PIXELS);

    if (!Common.isNull(match)) {
      return parseFloat(match[1]);
    }

    return 0;
  }

  var dom = {
    makeSelectable: function makeSelectable(elem, selectable) {
      if (elem === undefined || elem.style === undefined) return;
      elem.onselectstart = selectable ? function () {
        return false;
      } : function () {};
      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';
    },
    makeFullscreen: function makeFullscreen(elem, hor, vert) {
      var vertical = vert;
      var horizontal = hor;

      if (Common.isUndefined(horizontal)) {
        horizontal = true;
      }

      if (Common.isUndefined(vertical)) {
        vertical = true;
      }

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }

      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }
    },
    fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
      var params = pars || {};
      var className = EVENT_MAP_INV[eventType];

      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }

      var evt = document.createEvent(className);

      switch (className) {
        case 'MouseEvents':
          {
            var clientX = params.x || params.clientX || 0;
            var clientY = params.y || params.clientY || 0;
            evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0, 0, clientX, clientY, false, false, false, false, 0, null);
            break;
          }

        case 'KeyboardEvents':
          {
            var init = evt.initKeyboardEvent || evt.initKeyEvent;
            Common.defaults(params, {
              cancelable: true,
              ctrlKey: false,
              altKey: false,
              shiftKey: false,
              metaKey: false,
              keyCode: undefined,
              charCode: undefined
            });
            init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
            break;
          }

        default:
          {
            evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
            break;
          }
      }

      Common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },
    bind: function bind(elem, event, func, newBool) {
      var bool = newBool || false;

      if (elem.addEventListener) {
        elem.addEventListener(event, func, bool);
      } else if (elem.attachEvent) {
        elem.attachEvent('on' + event, func);
      }

      return dom;
    },
    unbind: function unbind(elem, event, func, newBool) {
      var bool = newBool || false;

      if (elem.removeEventListener) {
        elem.removeEventListener(event, func, bool);
      } else if (elem.detachEvent) {
        elem.detachEvent('on' + event, func);
      }

      return dom;
    },
    addClass: function addClass(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);

        if (classes.indexOf(className) === -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }

      return dom;
    },
    removeClass: function removeClass(elem, className) {
      if (className) {
        if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);

          if (index !== -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }

      return dom;
    },
    hasClass: function hasClass(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },
    getWidth: function getWidth(elem) {
      var style = getComputedStyle(elem);
      return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
    },
    getHeight: function getHeight(elem) {
      var style = getComputedStyle(elem);
      return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
    },
    getOffset: function getOffset(el) {
      var elem = el;
      var offset = {
        left: 0,
        top: 0
      };

      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
          elem = elem.offsetParent;
        } while (elem);
      }

      return offset;
    },
    isActive: function isActive(elem) {
      return elem === document.activeElement && (elem.type || elem.href);
    }
  };

  var BooleanController = function (_Controller) {
    inherits(BooleanController, _Controller);

    function BooleanController(object, property) {
      classCallCheck(this, BooleanController);

      var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));

      var _this = _this2;
      _this2.__prev = _this2.getValue();
      _this2.__checkbox = document.createElement('input');

      _this2.__checkbox.setAttribute('type', 'checkbox');

      function onChange() {
        _this.setValue(!_this.__prev);
      }

      dom.bind(_this2.__checkbox, 'change', onChange, false);

      _this2.domElement.appendChild(_this2.__checkbox);

      _this2.updateDisplay();

      return _this2;
    }

    createClass(BooleanController, [{
      key: 'setValue',
      value: function setValue(v) {
        var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);

        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue());
        }

        this.__prev = this.getValue();
        return toReturn;
      }
    }, {
      key: 'updateDisplay',
      value: function updateDisplay() {
        if (this.getValue() === true) {
          this.__checkbox.setAttribute('checked', 'checked');

          this.__checkbox.checked = true;
          this.__prev = true;
        } else {
          this.__checkbox.checked = false;
          this.__prev = false;
        }

        return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return BooleanController;
  }(Controller);

  var OptionController = function (_Controller) {
    inherits(OptionController, _Controller);

    function OptionController(object, property, opts) {
      classCallCheck(this, OptionController);

      var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));

      var options = opts;
      var _this = _this2;
      _this2.__select = document.createElement('select');

      if (Common.isArray(options)) {
        var map = {};
        Common.each(options, function (element) {
          map[element] = element;
        });
        options = map;
      }

      Common.each(options, function (value, key) {
        var opt = document.createElement('option');
        opt.innerHTML = key;
        opt.setAttribute('value', value);

        _this.__select.appendChild(opt);
      });

      _this2.updateDisplay();

      dom.bind(_this2.__select, 'change', function () {
        var desiredValue = this.options[this.selectedIndex].value;

        _this.setValue(desiredValue);
      });

      _this2.domElement.appendChild(_this2.__select);

      return _this2;
    }

    createClass(OptionController, [{
      key: 'setValue',
      value: function setValue(v) {
        var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);

        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue());
        }

        return toReturn;
      }
    }, {
      key: 'updateDisplay',
      value: function updateDisplay() {
        if (dom.isActive(this.__select)) return this;
        this.__select.value = this.getValue();
        return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return OptionController;
  }(Controller);

  var StringController = function (_Controller) {
    inherits(StringController, _Controller);

    function StringController(object, property) {
      classCallCheck(this, StringController);

      var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));

      var _this = _this2;

      function onChange() {
        _this.setValue(_this.__input.value);
      }

      function onBlur() {
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }

      _this2.__input = document.createElement('input');

      _this2.__input.setAttribute('type', 'text');

      dom.bind(_this2.__input, 'keyup', onChange);
      dom.bind(_this2.__input, 'change', onChange);
      dom.bind(_this2.__input, 'blur', onBlur);
      dom.bind(_this2.__input, 'keydown', function (e) {
        if (e.keyCode === 13) {
          this.blur();
        }
      });

      _this2.updateDisplay();

      _this2.domElement.appendChild(_this2.__input);

      return _this2;
    }

    createClass(StringController, [{
      key: 'updateDisplay',
      value: function updateDisplay() {
        if (!dom.isActive(this.__input)) {
          this.__input.value = this.getValue();
        }

        return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return StringController;
  }(Controller);

  function numDecimals(x) {
    var _x = x.toString();

    if (_x.indexOf('.') > -1) {
      return _x.length - _x.indexOf('.') - 1;
    }

    return 0;
  }

  var NumberController = function (_Controller) {
    inherits(NumberController, _Controller);

    function NumberController(object, property, params) {
      classCallCheck(this, NumberController);

      var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));

      var _params = params || {};

      _this.__min = _params.min;
      _this.__max = _params.max;
      _this.__step = _params.step;

      if (Common.isUndefined(_this.__step)) {
        if (_this.initialValue === 0) {
          _this.__impliedStep = 1;
        } else {
          _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
        }
      } else {
        _this.__impliedStep = _this.__step;
      }

      _this.__precision = numDecimals(_this.__impliedStep);
      return _this;
    }

    createClass(NumberController, [{
      key: 'setValue',
      value: function setValue(v) {
        var _v = v;

        if (this.__min !== undefined && _v < this.__min) {
          _v = this.__min;
        } else if (this.__max !== undefined && _v > this.__max) {
          _v = this.__max;
        }

        if (this.__step !== undefined && _v % this.__step !== 0) {
          _v = Math.round(_v / this.__step) * this.__step;
        }

        return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
      }
    }, {
      key: 'min',
      value: function min(minValue) {
        this.__min = minValue;
        return this;
      }
    }, {
      key: 'max',
      value: function max(maxValue) {
        this.__max = maxValue;
        return this;
      }
    }, {
      key: 'step',
      value: function step(stepValue) {
        this.__step = stepValue;
        this.__impliedStep = stepValue;
        this.__precision = numDecimals(stepValue);
        return this;
      }
    }]);
    return NumberController;
  }(Controller);

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  var NumberControllerBox = function (_NumberController) {
    inherits(NumberControllerBox, _NumberController);

    function NumberControllerBox(object, property, params) {
      classCallCheck(this, NumberControllerBox);

      var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));

      _this2.__truncationSuspended = false;
      var _this = _this2;
      var prevY = void 0;

      function onChange() {
        var attempted = parseFloat(_this.__input.value);

        if (!Common.isNaN(attempted)) {
          _this.setValue(attempted);
        }
      }

      function onFinish() {
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }

      function onBlur() {
        onFinish();
      }

      function onMouseDrag(e) {
        var diff = prevY - e.clientY;

        _this.setValue(_this.getValue() + diff * _this.__impliedStep);

        prevY = e.clientY;
      }

      function onMouseUp() {
        dom.unbind(window, 'mousemove', onMouseDrag);
        dom.unbind(window, 'mouseup', onMouseUp);
        onFinish();
      }

      function onMouseDown(e) {
        dom.bind(window, 'mousemove', onMouseDrag);
        dom.bind(window, 'mouseup', onMouseUp);
        prevY = e.clientY;
      }

      _this2.__input = document.createElement('input');

      _this2.__input.setAttribute('type', 'text');

      dom.bind(_this2.__input, 'change', onChange);
      dom.bind(_this2.__input, 'blur', onBlur);
      dom.bind(_this2.__input, 'mousedown', onMouseDown);
      dom.bind(_this2.__input, 'keydown', function (e) {
        if (e.keyCode === 13) {
          _this.__truncationSuspended = true;
          this.blur();
          _this.__truncationSuspended = false;
          onFinish();
        }
      });

      _this2.updateDisplay();

      _this2.domElement.appendChild(_this2.__input);

      return _this2;
    }

    createClass(NumberControllerBox, [{
      key: 'updateDisplay',
      value: function updateDisplay() {
        this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
        return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return NumberControllerBox;
  }(NumberController);

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  var NumberControllerSlider = function (_NumberController) {
    inherits(NumberControllerSlider, _NumberController);

    function NumberControllerSlider(object, property, min, max, step) {
      classCallCheck(this, NumberControllerSlider);

      var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, {
        min: min,
        max: max,
        step: step
      }));

      var _this = _this2;
      _this2.__background = document.createElement('div');
      _this2.__foreground = document.createElement('div');
      dom.bind(_this2.__background, 'mousedown', onMouseDown);
      dom.bind(_this2.__background, 'touchstart', onTouchStart);
      dom.addClass(_this2.__background, 'slider');
      dom.addClass(_this2.__foreground, 'slider-fg');

      function onMouseDown(e) {
        document.activeElement.blur();
        dom.bind(window, 'mousemove', onMouseDrag);
        dom.bind(window, 'mouseup', onMouseUp);
        onMouseDrag(e);
      }

      function onMouseDrag(e) {
        e.preventDefault();

        var bgRect = _this.__background.getBoundingClientRect();

        _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));

        return false;
      }

      function onMouseUp() {
        dom.unbind(window, 'mousemove', onMouseDrag);
        dom.unbind(window, 'mouseup', onMouseUp);

        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }

      function onTouchStart(e) {
        if (e.touches.length !== 1) {
          return;
        }

        dom.bind(window, 'touchmove', onTouchMove);
        dom.bind(window, 'touchend', onTouchEnd);
        onTouchMove(e);
      }

      function onTouchMove(e) {
        var clientX = e.touches[0].clientX;

        var bgRect = _this.__background.getBoundingClientRect();

        _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      }

      function onTouchEnd() {
        dom.unbind(window, 'touchmove', onTouchMove);
        dom.unbind(window, 'touchend', onTouchEnd);

        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }

      _this2.updateDisplay();

      _this2.__background.appendChild(_this2.__foreground);

      _this2.domElement.appendChild(_this2.__background);

      return _this2;
    }

    createClass(NumberControllerSlider, [{
      key: 'updateDisplay',
      value: function updateDisplay() {
        var pct = (this.getValue() - this.__min) / (this.__max - this.__min);

        this.__foreground.style.width = pct * 100 + '%';
        return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return NumberControllerSlider;
  }(NumberController);

  var FunctionController = function (_Controller) {
    inherits(FunctionController, _Controller);

    function FunctionController(object, property, text) {
      classCallCheck(this, FunctionController);

      var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));

      var _this = _this2;
      _this2.__button = document.createElement('div');
      _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
      dom.bind(_this2.__button, 'click', function (e) {
        e.preventDefault();

        _this.fire();

        return false;
      });
      dom.addClass(_this2.__button, 'button');

      _this2.domElement.appendChild(_this2.__button);

      return _this2;
    }

    createClass(FunctionController, [{
      key: 'fire',
      value: function fire() {
        if (this.__onChange) {
          this.__onChange.call(this);
        }

        this.getValue().call(this.object);

        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue());
        }
      }
    }]);
    return FunctionController;
  }(Controller);

  var ColorController = function (_Controller) {
    inherits(ColorController, _Controller);

    function ColorController(object, property) {
      classCallCheck(this, ColorController);

      var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));

      _this2.__color = new Color$1(_this2.getValue());
      _this2.__temp = new Color$1(0);
      var _this = _this2;
      _this2.domElement = document.createElement('div');
      dom.makeSelectable(_this2.domElement, false);
      _this2.__selector = document.createElement('div');
      _this2.__selector.className = 'selector';
      _this2.__saturation_field = document.createElement('div');
      _this2.__saturation_field.className = 'saturation-field';
      _this2.__field_knob = document.createElement('div');
      _this2.__field_knob.className = 'field-knob';
      _this2.__field_knob_border = '2px solid ';
      _this2.__hue_knob = document.createElement('div');
      _this2.__hue_knob.className = 'hue-knob';
      _this2.__hue_field = document.createElement('div');
      _this2.__hue_field.className = 'hue-field';
      _this2.__input = document.createElement('input');
      _this2.__input.type = 'text';
      _this2.__input_textShadow = '0 1px 1px ';
      dom.bind(_this2.__input, 'keydown', function (e) {
        if (e.keyCode === 13) {
          onBlur.call(this);
        }
      });
      dom.bind(_this2.__input, 'blur', onBlur);
      dom.bind(_this2.__selector, 'mousedown', function () {
        dom.addClass(this, 'drag').bind(window, 'mouseup', function () {
          dom.removeClass(_this.__selector, 'drag');
        });
      });
      dom.bind(_this2.__selector, 'touchstart', function () {
        dom.addClass(this, 'drag').bind(window, 'touchend', function () {
          dom.removeClass(_this.__selector, 'drag');
        });
      });
      var valueField = document.createElement('div');
      Common.extend(_this2.__selector.style, {
        width: '122px',
        height: '102px',
        padding: '3px',
        backgroundColor: '#222',
        boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
      });
      Common.extend(_this2.__field_knob.style, {
        position: 'absolute',
        width: '12px',
        height: '12px',
        border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
        boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
        borderRadius: '12px',
        zIndex: 1
      });
      Common.extend(_this2.__hue_knob.style, {
        position: 'absolute',
        width: '15px',
        height: '2px',
        borderRight: '4px solid #fff',
        zIndex: 1
      });
      Common.extend(_this2.__saturation_field.style, {
        width: '100px',
        height: '100px',
        border: '1px solid #555',
        marginRight: '3px',
        display: 'inline-block',
        cursor: 'pointer'
      });
      Common.extend(valueField.style, {
        width: '100%',
        height: '100%',
        background: 'none'
      });
      linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
      Common.extend(_this2.__hue_field.style, {
        width: '15px',
        height: '100px',
        border: '1px solid #555',
        cursor: 'ns-resize',
        position: 'absolute',
        top: '3px',
        right: '3px'
      });
      hueGradient(_this2.__hue_field);
      Common.extend(_this2.__input.style, {
        outline: 'none',
        textAlign: 'center',
        color: '#fff',
        border: 0,
        fontWeight: 'bold',
        textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
      });
      dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
      dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
      dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
      dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
      dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
      dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);

      function fieldDown(e) {
        setSV(e);
        dom.bind(window, 'mousemove', setSV);
        dom.bind(window, 'touchmove', setSV);
        dom.bind(window, 'mouseup', fieldUpSV);
        dom.bind(window, 'touchend', fieldUpSV);
      }

      function fieldDownH(e) {
        setH(e);
        dom.bind(window, 'mousemove', setH);
        dom.bind(window, 'touchmove', setH);
        dom.bind(window, 'mouseup', fieldUpH);
        dom.bind(window, 'touchend', fieldUpH);
      }

      function fieldUpSV() {
        dom.unbind(window, 'mousemove', setSV);
        dom.unbind(window, 'touchmove', setSV);
        dom.unbind(window, 'mouseup', fieldUpSV);
        dom.unbind(window, 'touchend', fieldUpSV);
        onFinish();
      }

      function fieldUpH() {
        dom.unbind(window, 'mousemove', setH);
        dom.unbind(window, 'touchmove', setH);
        dom.unbind(window, 'mouseup', fieldUpH);
        dom.unbind(window, 'touchend', fieldUpH);
        onFinish();
      }

      function onBlur() {
        var i = interpret(this.value);

        if (i !== false) {
          _this.__color.__state = i;

          _this.setValue(_this.__color.toOriginal());
        } else {
          this.value = _this.__color.toString();
        }
      }

      function onFinish() {
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.__color.toOriginal());
        }
      }

      _this2.__saturation_field.appendChild(valueField);

      _this2.__selector.appendChild(_this2.__field_knob);

      _this2.__selector.appendChild(_this2.__saturation_field);

      _this2.__selector.appendChild(_this2.__hue_field);

      _this2.__hue_field.appendChild(_this2.__hue_knob);

      _this2.domElement.appendChild(_this2.__input);

      _this2.domElement.appendChild(_this2.__selector);

      _this2.updateDisplay();

      function setSV(e) {
        if (e.type.indexOf('touch') === -1) {
          e.preventDefault();
        }

        var fieldRect = _this.__saturation_field.getBoundingClientRect();

        var _ref = e.touches && e.touches[0] || e,
            clientX = _ref.clientX,
            clientY = _ref.clientY;

        var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
        var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);

        if (v > 1) {
          v = 1;
        } else if (v < 0) {
          v = 0;
        }

        if (s > 1) {
          s = 1;
        } else if (s < 0) {
          s = 0;
        }

        _this.__color.v = v;
        _this.__color.s = s;

        _this.setValue(_this.__color.toOriginal());

        return false;
      }

      function setH(e) {
        if (e.type.indexOf('touch') === -1) {
          e.preventDefault();
        }

        var fieldRect = _this.__hue_field.getBoundingClientRect();

        var _ref2 = e.touches && e.touches[0] || e,
            clientY = _ref2.clientY;

        var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);

        if (h > 1) {
          h = 1;
        } else if (h < 0) {
          h = 0;
        }

        _this.__color.h = h * 360;

        _this.setValue(_this.__color.toOriginal());

        return false;
      }

      return _this2;
    }

    createClass(ColorController, [{
      key: 'updateDisplay',
      value: function updateDisplay() {
        var i = interpret(this.getValue());

        if (i !== false) {
          var mismatch = false;
          Common.each(Color$1.COMPONENTS, function (component) {
            if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
              mismatch = true;
              return {};
            }
          }, this);

          if (mismatch) {
            Common.extend(this.__color.__state, i);
          }
        }

        Common.extend(this.__temp.__state, this.__color.__state);
        this.__temp.a = 1;
        var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;

        var _flip = 255 - flip;

        Common.extend(this.__field_knob.style, {
          marginLeft: 100 * this.__color.s - 7 + 'px',
          marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
          backgroundColor: this.__temp.toHexString(),
          border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
        });
        this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
        this.__temp.s = 1;
        this.__temp.v = 1;
        linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
        this.__input.value = this.__color.toString();
        Common.extend(this.__input.style, {
          backgroundColor: this.__color.toHexString(),
          color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
          textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
        });
      }
    }]);
    return ColorController;
  }(Controller);

  var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];

  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    Common.each(vendors, function (vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
    });
  }

  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  }

  var css = {
    load: function load(url, indoc) {
      var doc = indoc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function inject(cssContent, indoc) {
      var doc = indoc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = cssContent;
      var head = doc.getElementsByTagName('head')[0];

      try {
        head.appendChild(injected);
      } catch (e) {}
    }
  };
  var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

  var ControllerFactory = function ControllerFactory(object, property) {
    var initialValue = object[property];

    if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
      return new OptionController(object, property, arguments[2]);
    }

    if (Common.isNumber(initialValue)) {
      if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
        if (Common.isNumber(arguments[4])) {
          return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
        }

        return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
      }

      if (Common.isNumber(arguments[4])) {
        return new NumberControllerBox(object, property, {
          min: arguments[2],
          max: arguments[3],
          step: arguments[4]
        });
      }

      return new NumberControllerBox(object, property, {
        min: arguments[2],
        max: arguments[3]
      });
    }

    if (Common.isString(initialValue)) {
      return new StringController(object, property);
    }

    if (Common.isFunction(initialValue)) {
      return new FunctionController(object, property, '');
    }

    if (Common.isBoolean(initialValue)) {
      return new BooleanController(object, property);
    }

    return null;
  };

  function requestAnimationFrame$1(callback) {
    setTimeout(callback, 1000 / 60);
  }

  var requestAnimationFrame$1$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame$1;

  var CenteredDiv = function () {
    function CenteredDiv() {
      classCallCheck(this, CenteredDiv);
      this.backgroundElement = document.createElement('div');
      Common.extend(this.backgroundElement.style, {
        backgroundColor: 'rgba(0,0,0,0.8)',
        top: 0,
        left: 0,
        display: 'none',
        zIndex: '1000',
        opacity: 0,
        WebkitTransition: 'opacity 0.2s linear',
        transition: 'opacity 0.2s linear'
      });
      dom.makeFullscreen(this.backgroundElement);
      this.backgroundElement.style.position = 'fixed';
      this.domElement = document.createElement('div');
      Common.extend(this.domElement.style, {
        position: 'fixed',
        display: 'none',
        zIndex: '1001',
        opacity: 0,
        WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
        transition: 'transform 0.2s ease-out, opacity 0.2s linear'
      });
      document.body.appendChild(this.backgroundElement);
      document.body.appendChild(this.domElement);

      var _this = this;

      dom.bind(this.backgroundElement, 'click', function () {
        _this.hide();
      });
    }

    createClass(CenteredDiv, [{
      key: 'show',
      value: function show() {
        var _this = this;

        this.backgroundElement.style.display = 'block';
        this.domElement.style.display = 'block';
        this.domElement.style.opacity = 0;
        this.domElement.style.webkitTransform = 'scale(1.1)';
        this.layout();
        Common.defer(function () {
          _this.backgroundElement.style.opacity = 1;
          _this.domElement.style.opacity = 1;
          _this.domElement.style.webkitTransform = 'scale(1)';
        });
      }
    }, {
      key: 'hide',
      value: function hide() {
        var _this = this;

        var hide = function hide() {
          _this.domElement.style.display = 'none';
          _this.backgroundElement.style.display = 'none';
          dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
          dom.unbind(_this.domElement, 'transitionend', hide);
          dom.unbind(_this.domElement, 'oTransitionEnd', hide);
        };

        dom.bind(this.domElement, 'webkitTransitionEnd', hide);
        dom.bind(this.domElement, 'transitionend', hide);
        dom.bind(this.domElement, 'oTransitionEnd', hide);
        this.backgroundElement.style.opacity = 0;
        this.domElement.style.opacity = 0;
        this.domElement.style.webkitTransform = 'scale(1.1)';
      }
    }, {
      key: 'layout',
      value: function layout() {
        this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
        this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
      }
    }]);
    return CenteredDiv;
  }();

  var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

  css.inject(styleSheet);
  var CSS_NAMESPACE = 'dg';
  var HIDE_KEY_CODE = 72;
  var CLOSE_BUTTON_HEIGHT = 20;
  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = function () {
    try {
      return !!window.localStorage;
    } catch (e) {
      return false;
    }
  }();

  var SAVE_DIALOGUE = void 0;
  var autoPlaceVirgin = true;
  var autoPlaceContainer = void 0;
  var hide = false;
  var hideableGuis = [];

  var GUI = function GUI(pars) {
    var _this = this;

    var params = pars || {};
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);
    dom.addClass(this.domElement, CSS_NAMESPACE);
    this.__folders = {};
    this.__controllers = [];
    this.__rememberedObjects = [];
    this.__rememberedObjectIndecesToControllers = [];
    this.__listening = [];
    params = Common.defaults(params, {
      closeOnTop: false,
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });
    params = Common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });

    if (!Common.isUndefined(params.load)) {
      if (params.preset) {
        params.load.preset = params.preset;
      }
    } else {
      params.load = {
        preset: DEFAULT_DEFAULT_PRESET_NAME
      };
    }

    if (Common.isUndefined(params.parent) && params.hideable) {
      hideableGuis.push(this);
    }

    params.resizable = Common.isUndefined(params.parent) && params.resizable;

    if (params.autoPlace && Common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }

    var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
    var saveToLocalStorage = void 0;
    var titleRow = void 0;
    Object.defineProperties(this, {
      parent: {
        get: function get$$1() {
          return params.parent;
        }
      },
      scrollable: {
        get: function get$$1() {
          return params.scrollable;
        }
      },
      autoPlace: {
        get: function get$$1() {
          return params.autoPlace;
        }
      },
      closeOnTop: {
        get: function get$$1() {
          return params.closeOnTop;
        }
      },
      preset: {
        get: function get$$1() {
          if (_this.parent) {
            return _this.getRoot().preset;
          }

          return params.load.preset;
        },
        set: function set$$1(v) {
          if (_this.parent) {
            _this.getRoot().preset = v;
          } else {
            params.load.preset = v;
          }

          setPresetSelectIndex(this);

          _this.revert();
        }
      },
      width: {
        get: function get$$1() {
          return params.width;
        },
        set: function set$$1(v) {
          params.width = v;
          setWidth(_this, v);
        }
      },
      name: {
        get: function get$$1() {
          return params.name;
        },
        set: function set$$1(v) {
          params.name = v;

          if (titleRow) {
            titleRow.innerHTML = params.name;
          }
        }
      },
      closed: {
        get: function get$$1() {
          return params.closed;
        },
        set: function set$$1(v) {
          params.closed = v;

          if (params.closed) {
            dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
          } else {
            dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
          }

          this.onResize();

          if (_this.__closeButton) {
            _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
          }
        }
      },
      load: {
        get: function get$$1() {
          return params.load;
        }
      },
      useLocalStorage: {
        get: function get$$1() {
          return useLocalStorage;
        },
        set: function set$$1(bool) {
          if (SUPPORTS_LOCAL_STORAGE) {
            useLocalStorage = bool;

            if (bool) {
              dom.bind(window, 'unload', saveToLocalStorage);
            } else {
              dom.unbind(window, 'unload', saveToLocalStorage);
            }

            localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
          }
        }
      }
    });

    if (Common.isUndefined(params.parent)) {
      this.closed = params.closed || false;
      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      if (SUPPORTS_LOCAL_STORAGE) {
        if (useLocalStorage) {
          _this.useLocalStorage = true;
          var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (savedGui) {
            params.load = JSON.parse(savedGui);
          }
        }
      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);

      if (params.closeOnTop) {
        dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
        this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
      } else {
        dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
        this.domElement.appendChild(this.__closeButton);
      }

      dom.bind(this.__closeButton, 'click', function () {
        _this.closed = !_this.closed;
      });
    } else {
      if (params.closed === undefined) {
        params.closed = true;
      }

      var titleRowName = document.createTextNode(params.name);
      dom.addClass(titleRowName, 'controller-name');
      titleRow = addRow(_this, titleRowName);

      var onClickTitle = function onClickTitle(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);
      dom.addClass(titleRow, 'title');
      dom.bind(titleRow, 'click', onClickTitle);

      if (!params.closed) {
        this.closed = false;
      }
    }

    if (params.autoPlace) {
      if (Common.isUndefined(params.parent)) {
        if (autoPlaceVirgin) {
          autoPlaceContainer = document.createElement('div');
          dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
          dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(autoPlaceContainer);
          autoPlaceVirgin = false;
        }

        autoPlaceContainer.appendChild(this.domElement);
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
      }

      if (!this.parent) {
        setWidth(_this, params.width);
      }
    }

    this.__resizeHandler = function () {
      _this.onResizeDebounced();
    };

    dom.bind(window, 'resize', this.__resizeHandler);
    dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
    dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
    dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
    this.onResize();

    if (params.resizable) {
      addResizeHandle(this);
    }

    saveToLocalStorage = function saveToLocalStorage() {
      if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
        localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
      }
    };

    this.saveToLocalStorageIfPossible = saveToLocalStorage;

    function resetWidth() {
      var root = _this.getRoot();

      root.width += 1;
      Common.defer(function () {
        root.width -= 1;
      });
    }

    if (!params.parent) {
      resetWidth();
    }
  };

  GUI.toggleHide = function () {
    hide = !hide;
    Common.each(hideableGuis, function (gui) {
      gui.domElement.style.display = hide ? 'none' : '';
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_CLOSE_TOP = 'close-top';
  GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
  GUI.CLASS_DRAG = 'drag';
  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  GUI._keydownHandler = function (e) {
    if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }
  };

  dom.bind(window, 'keydown', GUI._keydownHandler, false);
  Common.extend(GUI.prototype, {
    add: function add(object, property) {
      return _add(this, object, property, {
        factoryArgs: Array.prototype.slice.call(arguments, 2)
      });
    },
    addColor: function addColor(object, property) {
      return _add(this, object, property, {
        color: true
      });
    },
    remove: function remove(controller) {
      this.__ul.removeChild(controller.__li);

      this.__controllers.splice(this.__controllers.indexOf(controller), 1);

      var _this = this;

      Common.defer(function () {
        _this.onResize();
      });
    },
    destroy: function destroy() {
      if (this.parent) {
        throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
      }

      if (this.autoPlace) {
        autoPlaceContainer.removeChild(this.domElement);
      }

      var _this = this;

      Common.each(this.__folders, function (subfolder) {
        _this.removeFolder(subfolder);
      });
      dom.unbind(window, 'keydown', GUI._keydownHandler, false);
      removeListeners(this);
    },
    addFolder: function addFolder(name) {
      if (this.__folders[name] !== undefined) {
        throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
      }

      var newGuiParams = {
        name: name,
        parent: this
      };
      newGuiParams.autoPlace = this.autoPlace;

      if (this.load && this.load.folders && this.load.folders[name]) {
        newGuiParams.closed = this.load.folders[name].closed;
        newGuiParams.load = this.load.folders[name];
      }

      var gui = new GUI(newGuiParams);
      this.__folders[name] = gui;
      var li = addRow(this, gui.domElement);
      dom.addClass(li, 'folder');
      return gui;
    },
    removeFolder: function removeFolder(folder) {
      this.__ul.removeChild(folder.domElement.parentElement);

      delete this.__folders[folder.name];

      if (this.load && this.load.folders && this.load.folders[folder.name]) {
        delete this.load.folders[folder.name];
      }

      removeListeners(folder);

      var _this = this;

      Common.each(folder.__folders, function (subfolder) {
        folder.removeFolder(subfolder);
      });
      Common.defer(function () {
        _this.onResize();
      });
    },
    open: function open() {
      this.closed = false;
    },
    close: function close() {
      this.closed = true;
    },
    hide: function hide() {
      this.domElement.style.display = 'none';
    },
    show: function show() {
      this.domElement.style.display = '';
    },
    onResize: function onResize() {
      var root = this.getRoot();

      if (root.scrollable) {
        var top = dom.getOffset(root.__ul).top;
        var h = 0;
        Common.each(root.__ul.childNodes, function (node) {
          if (!(root.autoPlace && node === root.__save_row)) {
            h += dom.getHeight(node);
          }
        });

        if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
          dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
          root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
        } else {
          dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
          root.__ul.style.height = 'auto';
        }
      }

      if (root.__resize_handle) {
        Common.defer(function () {
          root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
        });
      }

      if (root.__closeButton) {
        root.__closeButton.style.width = root.width + 'px';
      }
    },
    onResizeDebounced: Common.debounce(function () {
      this.onResize();
    }, 50),
    remember: function remember() {
      if (Common.isUndefined(SAVE_DIALOGUE)) {
        SAVE_DIALOGUE = new CenteredDiv();
        SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
      }

      if (this.parent) {
        throw new Error('You can only call remember on a top level GUI.');
      }

      var _this = this;

      Common.each(Array.prototype.slice.call(arguments), function (object) {
        if (_this.__rememberedObjects.length === 0) {
          addSaveMenu(_this);
        }

        if (_this.__rememberedObjects.indexOf(object) === -1) {
          _this.__rememberedObjects.push(object);
        }
      });

      if (this.autoPlace) {
        setWidth(this, this.width);
      }
    },
    getRoot: function getRoot() {
      var gui = this;

      while (gui.parent) {
        gui = gui.parent;
      }

      return gui;
    },
    getSaveObject: function getSaveObject() {
      var toReturn = this.load;
      toReturn.closed = this.closed;

      if (this.__rememberedObjects.length > 0) {
        toReturn.preset = this.preset;

        if (!toReturn.remembered) {
          toReturn.remembered = {};
        }

        toReturn.remembered[this.preset] = getCurrentPreset(this);
      }

      toReturn.folders = {};
      Common.each(this.__folders, function (element, key) {
        toReturn.folders[key] = element.getSaveObject();
      });
      return toReturn;
    },
    save: function save() {
      if (!this.load.remembered) {
        this.load.remembered = {};
      }

      this.load.remembered[this.preset] = getCurrentPreset(this);
      markPresetModified(this, false);
      this.saveToLocalStorageIfPossible();
    },
    saveAs: function saveAs(presetName) {
      if (!this.load.remembered) {
        this.load.remembered = {};
        this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
      }

      this.load.remembered[presetName] = getCurrentPreset(this);
      this.preset = presetName;
      addPresetOption(this, presetName, true);
      this.saveToLocalStorageIfPossible();
    },
    revert: function revert(gui) {
      Common.each(this.__controllers, function (controller) {
        if (!this.getRoot().load.remembered) {
          controller.setValue(controller.initialValue);
        } else {
          recallSavedValue(gui || this.getRoot(), controller);
        }

        if (controller.__onFinishChange) {
          controller.__onFinishChange.call(controller, controller.getValue());
        }
      }, this);
      Common.each(this.__folders, function (folder) {
        folder.revert(folder);
      });

      if (!gui) {
        markPresetModified(this.getRoot(), false);
      }
    },
    listen: function listen(controller) {
      var init = this.__listening.length === 0;

      this.__listening.push(controller);

      if (init) {
        updateDisplays(this.__listening);
      }
    },
    updateDisplay: function updateDisplay() {
      Common.each(this.__controllers, function (controller) {
        controller.updateDisplay();
      });
      Common.each(this.__folders, function (folder) {
        folder.updateDisplay();
      });
    }
  });

  function addRow(gui, newDom, liBefore) {
    var li = document.createElement('li');

    if (newDom) {
      li.appendChild(newDom);
    }

    if (liBefore) {
      gui.__ul.insertBefore(li, liBefore);
    } else {
      gui.__ul.appendChild(li);
    }

    gui.onResize();
    return li;
  }

  function removeListeners(gui) {
    dom.unbind(window, 'resize', gui.__resizeHandler);

    if (gui.saveToLocalStorageIfPossible) {
      dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];

    if (modified) {
      opt.innerHTML = opt.value + '*';
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function augmentController(gui, li, controller) {
    controller.__li = li;
    controller.__gui = gui;
    Common.extend(controller, {
      options: function options(_options) {
        if (arguments.length > 1) {
          var nextSibling = controller.__li.nextElementSibling;
          controller.remove();
          return _add(gui, controller.object, controller.property, {
            before: nextSibling,
            factoryArgs: [Common.toArray(arguments)]
          });
        }

        if (Common.isArray(_options) || Common.isObject(_options)) {
          var _nextSibling = controller.__li.nextElementSibling;
          controller.remove();
          return _add(gui, controller.object, controller.property, {
            before: _nextSibling,
            factoryArgs: [_options]
          });
        }
      },
      name: function name(_name) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
        return controller;
      },
      listen: function listen() {
        controller.__gui.listen(controller);

        return controller;
      },
      remove: function remove() {
        controller.__gui.remove(controller);

        return controller;
      }
    });

    if (controller instanceof NumberControllerSlider) {
      var box = new NumberControllerBox(controller.object, controller.property, {
        min: controller.__min,
        max: controller.__max,
        step: controller.__step
      });
      Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
        var pc = controller[method];
        var pb = box[method];

        controller[method] = box[method] = function () {
          var args = Array.prototype.slice.call(arguments);
          pb.apply(box, args);
          return pc.apply(controller, args);
        };
      });
      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
    } else if (controller instanceof NumberControllerBox) {
      var r = function r(returned) {
        if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
          var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
          var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
          controller.remove();

          var newController = _add(gui, controller.object, controller.property, {
            before: controller.__li.nextElementSibling,
            factoryArgs: [controller.__min, controller.__max, controller.__step]
          });

          newController.name(oldName);
          if (wasListening) newController.listen();
          return newController;
        }

        return returned;
      };

      controller.min = Common.compose(r, controller.min);
      controller.max = Common.compose(r, controller.max);
    } else if (controller instanceof BooleanController) {
      dom.bind(li, 'click', function () {
        dom.fakeEvent(controller.__checkbox, 'click');
      });
      dom.bind(controller.__checkbox, 'click', function (e) {
        e.stopPropagation();
      });
    } else if (controller instanceof FunctionController) {
      dom.bind(li, 'click', function () {
        dom.fakeEvent(controller.__button, 'click');
      });
      dom.bind(li, 'mouseover', function () {
        dom.addClass(controller.__button, 'hover');
      });
      dom.bind(li, 'mouseout', function () {
        dom.removeClass(controller.__button, 'hover');
      });
    } else if (controller instanceof ColorController) {
      dom.addClass(li, 'color');
      controller.updateDisplay = Common.compose(function (val) {
        li.style.borderLeftColor = controller.__color.toString();
        return val;
      }, controller.updateDisplay);
      controller.updateDisplay();
    }

    controller.setValue = Common.compose(function (val) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }

      return val;
    }, controller.setValue);
  }

  function recallSavedValue(gui, controller) {
    var root = gui.getRoot();

    var matchedIndex = root.__rememberedObjects.indexOf(controller.object);

    if (matchedIndex !== -1) {
      var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];

      if (controllerMap === undefined) {
        controllerMap = {};
        root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
      }

      controllerMap[controller.property] = controller;

      if (root.load && root.load.remembered) {
        var presetMap = root.load.remembered;
        var preset = void 0;

        if (presetMap[gui.preset]) {
          preset = presetMap[gui.preset];
        } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
          preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
        } else {
          return;
        }

        if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
          var value = preset[matchedIndex][controller.property];
          controller.initialValue = value;
          controller.setValue(value);
        }
      }
    }
  }

  function _add(gui, object, property, params) {
    if (object[property] === undefined) {
      throw new Error('Object "' + object + '" has no property "' + property + '"');
    }

    var controller = void 0;

    if (params.color) {
      controller = new ColorController(object, property);
    } else {
      var factoryArgs = [object, property].concat(params.factoryArgs);
      controller = ControllerFactory.apply(gui, factoryArgs);
    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);
    dom.addClass(controller.domElement, 'c');
    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;
    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);
    var li = addRow(gui, container, params.before);
    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);

    if (controller instanceof ColorController) {
      dom.addClass(li, 'color');
    } else {
      dom.addClass(li, _typeof$1(controller.getValue()));
    }

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;
  }

  function getLocalStorageHash(gui, key) {
    return document.location.href + '.' + key;
  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;

    gui.__preset_select.appendChild(opt);

    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function showHideExplain(gui, explain) {
    explain.style.display = gui.useLocalStorage ? 'block' : 'none';
  }

  function addSaveMenu(gui) {
    var div = gui.__save_row = document.createElement('li');
    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');
    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');
    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');
    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');
    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {
      Common.each(gui.load.remembered, function (value, key) {
        addPresetOption(gui, key, key === gui.preset);
      });
    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function () {
      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;
    });
    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {
      var explain = document.getElementById('dg-local-explain');
      var localStorageCheckBox = document.getElementById('dg-local-storage');
      var saveLocally = document.getElementById('dg-save-locally');
      saveLocally.style.display = 'block';

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      showHideExplain(gui, explain);
      dom.bind(localStorageCheckBox, 'change', function () {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain(gui, explain);
      });
    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');
    dom.bind(newConstructorTextArea, 'keydown', function (e) {
      if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
        SAVE_DIALOGUE.hide();
      }
    });
    dom.bind(gears, 'click', function () {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });
    dom.bind(button, 'click', function () {
      gui.save();
    });
    dom.bind(button2, 'click', function () {
      var presetName = prompt('Enter a new preset name.');

      if (presetName) {
        gui.saveAs(presetName);
      }
    });
    dom.bind(button3, 'click', function () {
      gui.revert();
    });
  }

  function addResizeHandle(gui) {
    var pmouseX = void 0;
    gui.__resize_handle = document.createElement('div');
    Common.extend(gui.__resize_handle.style, {
      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
    });

    function drag(e) {
      e.preventDefault();
      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;
      return false;
    }

    function dragStop() {
      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);
    }

    function dragStart(e) {
      e.preventDefault();
      pmouseX = e.clientX;
      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);
      return false;
    }

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);
    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';

    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }

    if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {
    var toReturn = {};
    Common.each(gui.__rememberedObjects, function (val, index) {
      var savedValues = {};
      var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
      Common.each(controllerMap, function (controller, property) {
        savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });
      toReturn[index] = savedValues;
    });
    return toReturn;
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value === gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function updateDisplays(controllerArray) {
    if (controllerArray.length !== 0) {
      requestAnimationFrame$1$1.call(window, function () {
        updateDisplays(controllerArray);
      });
    }

    Common.each(controllerArray, function (c) {
      c.updateDisplay();
    });
  }

  var GUI$1 = GUI;
  /**
   * three-demo v3.16.0 build Sun Feb 02 2020
   * https://github.com/vanruesc/three-demo
   * Copyright 2020 Raoul van Rschen
   * @license Zlib
   */

  var Demo = function () {
    function Demo() {
      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "demo";

      _classCallCheck(this, Demo);

      this.id = id;
      this.renderer = null;
      this.loadingManager = new LoadingManager();
      this.assets = new Map();
      this.scene = new Scene();
      this.camera = null;
      this.controls = null;
      this.ready = false;
    }

    _createClass(Demo, [{
      key: "setRenderer",
      value: function setRenderer(renderer) {
        this.renderer = renderer;
        return this;
      }
    }, {
      key: "load",
      value: function load() {
        return Promise.resolve();
      }
    }, {
      key: "initialize",
      value: function initialize() {}
    }, {
      key: "render",
      value: function render(delta) {
        this.renderer.render(this.scene, this.camera);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {}
    }, {
      key: "reset",
      value: function reset() {
        this.scene = new Scene();
        this.camera = null;

        if (this.controls !== null) {
          this.controls.dispose();
          this.controls = null;
        }

        this.ready = false;
        return this;
      }
    }]);

    return Demo;
  }();

  var DemoManagerEvent = function (_Event) {
    _inherits(DemoManagerEvent, _Event);

    function DemoManagerEvent(type) {
      var _this5;

      _classCallCheck(this, DemoManagerEvent);

      _this5 = _possibleConstructorReturn(this, _getPrototypeOf(DemoManagerEvent).call(this, type));
      _this5.previousDemo = null;
      _this5.demo = null;
      return _this5;
    }

    return DemoManagerEvent;
  }(Event);

  var change = new DemoManagerEvent("change");
  var load = new DemoManagerEvent("load");

  var DemoManager = function (_EventTarget) {
    _inherits(DemoManager, _EventTarget);

    function DemoManager(viewport) {
      var _this6;

      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$aside = _ref3.aside,
          aside = _ref3$aside === void 0 ? viewport : _ref3$aside,
          renderer = _ref3.renderer;

      _classCallCheck(this, DemoManager);

      _this6 = _possibleConstructorReturn(this, _getPrototypeOf(DemoManager).call(this));
      _this6.renderer = renderer !== undefined ? renderer : function () {
        var renderer = new WebGLRenderer();
        renderer.setSize(viewport.clientWidth, viewport.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        return renderer;
      }();
      viewport.appendChild(_this6.renderer.domElement);
      _this6.clock = new Clock();
      _this6.menu = new GUI$1({
        autoPlace: false
      });
      aside.appendChild(_this6.menu.domElement);
      _this6.demos = new Map();
      _this6.demo = null;
      _this6.currentDemo = null;
      return _this6;
    }

    _createClass(DemoManager, [{
      key: "resetMenu",
      value: function resetMenu() {
        var _this7 = this;

        var node = this.menu.domElement.parentNode;
        var menu = new GUI$1({
          autoPlace: false
        });

        if (this.demos.size > 1) {
          var selection = menu.add(this, "demo", Array.from(this.demos.keys()));
          selection.onChange(function () {
            return _this7.loadDemo();
          });
        }

        node.removeChild(this.menu.domElement);
        node.appendChild(menu.domElement);
        this.menu.destroy();
        this.menu = menu;
        return menu;
      }
    }, {
      key: "startDemo",
      value: function startDemo(demo) {
        if (demo.id === this.demo) {
          demo.initialize();
          demo.registerOptions(this.resetMenu());
          demo.ready = true;
          load.demo = demo;
          this.dispatchEvent(load);
        }
      }
    }, {
      key: "loadDemo",
      value: function loadDemo() {
        var _this8 = this;

        var nextDemo = this.demos.get(this.demo);
        var currentDemo = this.currentDemo;
        var renderer = this.renderer;
        window.location.hash = nextDemo.id;

        if (currentDemo !== null) {
          currentDemo.reset();
        }

        this.menu.domElement.style.display = "none";
        change.previousDemo = currentDemo;
        change.demo = nextDemo;
        this.currentDemo = nextDemo;
        this.dispatchEvent(change);
        renderer.clear();
        nextDemo.load().then(function () {
          return _this8.startDemo(nextDemo);
        })["catch"](console.error);
      }
    }, {
      key: "addDemo",
      value: function addDemo(demo) {
        var hash = window.location.hash.slice(1);
        var currentDemo = this.currentDemo;
        this.demos.set(demo.id, demo.setRenderer(this.renderer));

        if (this.demo === null && hash.length === 0 || demo.id === hash) {
          this.demo = demo.id;
          this.loadDemo();
        }

        this.resetMenu();

        if (currentDemo !== null && currentDemo.ready) {
          currentDemo.registerOptions(this.menu);
        }

        return this;
      }
    }, {
      key: "removeDemo",
      value: function removeDemo(id) {
        var demos = this.demos;
        var firstEntry;

        if (demos.has(id)) {
          demos["delete"](id);

          if (this.demo === id && demos.size > 0) {
            firstEntry = demos.entries().next().value;
            this.demo = firstEntry[0];
            this.currentDemo = firstEntry[1];
            this.loadDemo();
          } else {
            this.demo = null;
            this.currentDemo = null;
            this.renderer.clear();
          }
        }

        return this;
      }
    }, {
      key: "setSize",
      value: function setSize(width, height, updateStyle) {
        var demo = this.currentDemo;
        this.renderer.setSize(width, height, updateStyle);

        if (demo !== null && demo.camera !== null) {
          var camera = demo.camera;

          if (camera instanceof OrthographicCamera) {
            camera.left = width / -2.0;
            camera.right = width / 2.0;
            camera.top = height / 2.0;
            camera.bottom = height / -2.0;
            camera.updateProjectionMatrix();
          } else if (!(camera instanceof CubeCamera)) {
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
          }
        }
      }
    }, {
      key: "render",
      value: function render(now) {
        var demo = this.currentDemo;
        var delta = this.clock.getDelta();

        if (demo !== null && demo.ready) {
          demo.render(delta);
        }
      }
    }]);

    return DemoManager;
  }(EventTarget);

  var ColorChannel = {
    RED: 0,
    GREEN: 1,
    BLUE: 2,
    ALPHA: 3
  };
  var fragmentShader = "uniform sampler2D previousLuminanceBuffer;uniform sampler2D currentLuminanceBuffer;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float previousLuminance=texture2D(previousLuminanceBuffer,vUv,MIP_LEVEL_1X1).r;float currentLuminance=texture2D(currentLuminanceBuffer,vUv,MIP_LEVEL_1X1).r;previousLuminance=max(minLuminance,previousLuminance);currentLuminance=max(minLuminance,currentLuminance);float adaptedLum=previousLuminance+(currentLuminance-previousLuminance)*(1.0-exp(-deltaTime*tau));gl_FragColor.r=adaptedLum;}";
  var vertexShader = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";

  var AdaptiveLuminanceMaterial = function (_ShaderMaterial) {
    _inherits(AdaptiveLuminanceMaterial, _ShaderMaterial);

    function AdaptiveLuminanceMaterial() {
      _classCallCheck(this, AdaptiveLuminanceMaterial);

      return _possibleConstructorReturn(this, _getPrototypeOf(AdaptiveLuminanceMaterial).call(this, {
        type: "AdaptiveLuminanceMaterial",
        defines: {
          MIP_LEVEL_1X1: "0.0"
        },
        uniforms: {
          previousLuminanceBuffer: new Uniform(null),
          currentLuminanceBuffer: new Uniform(null),
          minLuminance: new Uniform(0.01),
          deltaTime: new Uniform(0.0),
          tau: new Uniform(1.0)
        },
        fragmentShader: fragmentShader,
        vertexShader: vertexShader,
        toneMapped: false,
        depthWrite: false,
        depthTest: false
      }));
    }

    return AdaptiveLuminanceMaterial;
  }(ShaderMaterial);

  var fragmentShader$1 = "uniform sampler2D inputBuffer;uniform sampler2D cocBuffer;uniform vec2 cocMask;uniform vec2 texelSize;uniform float scale;\n#if PASS == 1\nuniform float kernel64[128];\n#else\nuniform float kernel16[32];\n#endif\nvarying vec2 vUv;void main(){vec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=dot(CoCNearFar,cocMask)*scale;if(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{vec2 step=texelSize*CoC;\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<128;i+=2){vec2 uv=step*vec2(kernel64[i],kernel64[i+1])+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<32;i+=2){vec2 uv=step*vec2(kernel16[i],kernel16[i+1])+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}";

  var BokehMaterial = function (_ShaderMaterial2) {
    _inherits(BokehMaterial, _ShaderMaterial2);

    function BokehMaterial() {
      var _this9;

      var fill = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      _classCallCheck(this, BokehMaterial);

      _this9 = _possibleConstructorReturn(this, _getPrototypeOf(BokehMaterial).call(this, {
        type: "BokehMaterial",
        defines: {
          PASS: fill ? "2" : "1"
        },
        uniforms: {
          kernel64: new Uniform(new Float32Array(128)),
          kernel16: new Uniform(new Float32Array(32)),
          inputBuffer: new Uniform(null),
          cocBuffer: new Uniform(null),
          cocMask: new Uniform(new Vector2()),
          texelSize: new Uniform(new Vector2()),
          scale: new Uniform(1.0)
        },
        fragmentShader: fragmentShader$1,
        vertexShader: vertexShader,
        toneMapped: false,
        depthWrite: false,
        depthTest: false
      }));

      _this9.generateKernel();

      return _this9;
    }

    _createClass(BokehMaterial, [{
      key: "generateKernel",
      value: function generateKernel() {
        var GOLDEN_ANGLE = 2.39996323;
        var points64 = this.uniforms.kernel64.value;
        var points16 = this.uniforms.kernel16.value;
        var i64 = 0,
            i16 = 0;

        for (var _i = 0; _i < 80; ++_i) {
          var theta = _i * GOLDEN_ANGLE;
          var r = Math.sqrt(_i) / Math.sqrt(80);

          var u = r * Math.cos(theta),
              _v4 = r * Math.sin(theta);

          if (_i % 5 === 0) {
            points16[i16++] = u;
            points16[i16++] = _v4;
          } else {
            points64[i64++] = u;
            points64[i64++] = _v4;
          }
        }
      }
    }, {
      key: "setTexelSize",
      value: function setTexelSize(x, y) {
        this.uniforms.texelSize.value.set(x, y);
      }
    }]);

    return BokehMaterial;
  }(ShaderMaterial);

  var fragmentShader$2 = "#include <common>\n#include <packing>\nuniform sampler2D depthBuffer;uniform float focusDistance;uniform float focalLength;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focalLength,abs(signedDistance));gl_FragColor.rg=vec2(step(signedDistance,0.0)*magnitude,step(0.0,signedDistance)*magnitude);}";

  var CircleOfConfusionMaterial = function (_ShaderMaterial3) {
    _inherits(CircleOfConfusionMaterial, _ShaderMaterial3);

    function CircleOfConfusionMaterial(camera) {
      var _this10;

      _classCallCheck(this, CircleOfConfusionMaterial);

      _this10 = _possibleConstructorReturn(this, _getPrototypeOf(CircleOfConfusionMaterial).call(this, {
        type: "CircleOfConfusionMaterial",
        defines: {
          DEPTH_PACKING: "0"
        },
        uniforms: {
          depthBuffer: new Uniform(null),
          focusDistance: new Uniform(0.0),
          focalLength: new Uniform(0.0),
          cameraNear: new Uniform(0.3),
          cameraFar: new Uniform(1000)
        },
        fragmentShader: fragmentShader$2,
        vertexShader: vertexShader,
        toneMapped: false,
        depthWrite: false,
        depthTest: false
      }));

      _this10.adoptCameraSettings(camera);

      return _this10;
    }

    _createClass(CircleOfConfusionMaterial, [{
      key: "adoptCameraSettings",
      value: function adoptCameraSettings() {
        var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (camera !== null) {
          this.uniforms.cameraNear.value = camera.near;
          this.uniforms.cameraFar.value = camera.far;

          if (camera instanceof PerspectiveCamera) {
            this.defines.PERSPECTIVE_CAMERA = "1";
          } else {
            delete this.defines.PERSPECTIVE_CAMERA;
          }

          this.needsUpdate = true;
        }
      }
    }]);

    return CircleOfConfusionMaterial;
  }(ShaderMaterial);

  var fragmentShaderColor = "uniform sampler2D inputBuffer;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;void main(){const vec2 threshold=vec2(EDGE_THRESHOLD);vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);}";
  var vertexShader$1 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}";
  var fragmentShader$3 = "#include <common>\n#include <dithering_pars_fragment>\nuniform sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <dithering_fragment>\n}";
  var vertexShader$2 = "uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;/*Packing multiple texture coordinates into one varying and using a swizzle toextract them in the fragment shader still causes a dependent texture read.*/varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}";

  var ConvolutionMaterial = function (_ShaderMaterial4) {
    _inherits(ConvolutionMaterial, _ShaderMaterial4);

    function ConvolutionMaterial() {
      var _this11;

      var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();

      _classCallCheck(this, ConvolutionMaterial);

      _this11 = _possibleConstructorReturn(this, _getPrototypeOf(ConvolutionMaterial).call(this, {
        type: "ConvolutionMaterial",
        uniforms: {
          inputBuffer: new Uniform(null),
          texelSize: new Uniform(new Vector2()),
          halfTexelSize: new Uniform(new Vector2()),
          kernel: new Uniform(0.0),
          scale: new Uniform(1.0)
        },
        fragmentShader: fragmentShader$3,
        vertexShader: vertexShader$2,
        toneMapped: false,
        depthWrite: false,
        depthTest: false
      }));

      _this11.setTexelSize(texelSize.x, texelSize.y);

      _this11.kernelSize = KernelSize.LARGE;
      return _this11;
    }

    _createClass(ConvolutionMaterial, [{
      key: "getKernel",
      value: function getKernel() {
        return kernelPresets[this.kernelSize];
      }
    }, {
      key: "setTexelSize",
      value: function setTexelSize(x, y) {
        this.uniforms.texelSize.value.set(x, y);
        this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);
      }
    }]);

    return ConvolutionMaterial;
  }(ShaderMaterial);

  var kernelPresets = [new Float32Array([0.0, 0.0]), new Float32Array([0.0, 1.0, 1.0]), new Float32Array([0.0, 1.0, 1.0, 2.0]), new Float32Array([0.0, 1.0, 2.0, 2.0, 3.0]), new Float32Array([0.0, 1.0, 2.0, 3.0, 4.0, 4.0, 5.0]), new Float32Array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 7.0, 8.0, 9.0, 10.0])];
  var KernelSize = {
    VERY_SMALL: 0,
    SMALL: 1,
    MEDIUM: 2,
    LARGE: 3,
    VERY_LARGE: 4,
    HUGE: 5
  };
  var fragmentShader$4 = "uniform sampler2D inputBuffer;uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <encodings_fragment>\n}";

  var CopyMaterial = function (_ShaderMaterial5) {
    _inherits(CopyMaterial, _ShaderMaterial5);

    function CopyMaterial() {
      _classCallCheck(this, CopyMaterial);

      return _possibleConstructorReturn(this, _getPrototypeOf(CopyMaterial).call(this, {
        type: "CopyMaterial",
        uniforms: {
          inputBuffer: new Uniform(null),
          opacity: new Uniform(1.0)
        },
        fragmentShader: fragmentShader$4,
        vertexShader: vertexShader,
        toneMapped: false,
        depthWrite: false,
        depthTest: false
      }));
    }

    return CopyMaterial;
  }(ShaderMaterial);

  var fragmentShader$5 = "#include <packing>\n#include <clipping_planes_pars_fragment>\nuniform sampler2D depthBuffer;uniform float cameraNear;uniform float cameraFar;varying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <clipping_planes_fragment>\nvec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);float fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#else\nfloat viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#endif\nfloat depthTest=(-vViewZ>-viewZ)? 1.0 : 0.0;gl_FragColor.rg=vec2(0.0,depthTest);}";
  var vertexShader$3 = "#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\nvViewZ=mvPosition.z;vProjTexCoord=gl_Position;\n#include <clipping_planes_vertex>\n}";

  var DepthComparisonMaterial = function (_ShaderMaterial6) {
    _inherits(DepthComparisonMaterial, _ShaderMaterial6);

    function DepthComparisonMaterial() {
      var _this12;

      var depthTexture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var camera = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, DepthComparisonMaterial);

      _this12 = _possibleConstructorReturn(this, _getPrototypeOf(DepthComparisonMaterial).call(this, {
        type: "DepthComparisonMaterial",
        uniforms: {
          depthBuffer: new Uniform(depthTexture),
          cameraNear: new Uniform(0.3),
          cameraFar: new Uniform(1000)
        },
        fragmentShader: fragmentShader$5,
        vertexShader: vertexShader$3,
        toneMapped: false,
        depthWrite: false,
        depthTest: false,
        morphTargets: true,
        skinning: true
      }));

      _this12.adoptCameraSettings(camera);

      return _this12;
    }

    _createClass(DepthComparisonMaterial, [{
      key: "adoptCameraSettings",
      value: function adoptCameraSettings() {
        var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (camera !== null) {
          this.uniforms.cameraNear.value = camera.near;
          this.uniforms.cameraFar.value = camera.far;

          if (camera instanceof PerspectiveCamera) {
            this.defines.PERSPECTIVE_CAMERA = "1";
          } else {
            delete this.defines.PERSPECTIVE_CAMERA;
          }
        }
      }
    }]);

    return DepthComparisonMaterial;
  }(ShaderMaterial);

  var fragmentShader$6 = "#include <common>\n#include <packing>\nuniform sampler2D depthBuffer0;uniform sampler2D depthBuffer1;uniform sampler2D inputBuffer;varying vec2 vUv;void main(){\n#if DEPTH_PACKING_0 == 3201\nfloat d0=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));\n#else\nfloat d0=texture2D(depthBuffer0,vUv).r;\n#endif\n#if DEPTH_PACKING_1 == 3201\nfloat d1=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));\n#else\nfloat d1=texture2D(depthBuffer1,vUv).r;\n#endif\nif(d0<d1){discard;}gl_FragColor=texture2D(inputBuffer,vUv);}";

  var DepthMaskMaterial = function (_ShaderMaterial7) {
    _inherits(DepthMaskMaterial, _ShaderMaterial7);

    function DepthMaskMaterial() {
      _classCallCheck(this, DepthMaskMaterial);

      return _possibleConstructorReturn(this, _getPrototypeOf(DepthMaskMaterial).call(this, {
        type: "DepthMaskMaterial",
        defines: {
          DEPTH_PACKING_0: "0",
          DEPTH_PACKING_1: "0"
        },
        uniforms: {
          depthBuffer0: new Uniform(null),
          depthBuffer1: new Uniform(null),
          inputBuffer: new Uniform(null)
        },
        fragmentShader: fragmentShader$6,
        vertexShader: vertexShader,
        toneMapped: false,
        depthWrite: false,
        depthTest: false
      }));
    }

    return DepthMaskMaterial;
  }(ShaderMaterial);

  var fragmentShaderDepth = "#include <packing>\nuniform sampler2D depthBuffer;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}/***Gathers the current texel,and the top-left neighbors.*/vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}void main(){const vec2 threshold=vec2(DEPTH_THRESHOLD);vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-vec2(neighbours.y,neighbours.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);}";
  var fragmentShaderLuma = "#include <common>\nuniform sampler2D inputBuffer;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;void main(){const vec2 threshold=vec2(EDGE_THRESHOLD);float l=linearToRelativeLuminance(texture2D(inputBuffer,vUv).rgb);float lLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv0).rgb);float lTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=linearToRelativeLuminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=linearToRelativeLuminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);}";

  var EdgeDetectionMaterial = function (_ShaderMaterial8) {
    _inherits(EdgeDetectionMaterial, _ShaderMaterial8);

    function EdgeDetectionMaterial() {
      var _this13;

      var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
      var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EdgeDetectionMode.COLOR;

      _classCallCheck(this, EdgeDetectionMaterial);

      _this13 = _possibleConstructorReturn(this, _getPrototypeOf(EdgeDetectionMaterial).call(this, {
        type: "EdgeDetectionMaterial",
        defines: {
          LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
          EDGE_THRESHOLD: "0.1",
          DEPTH_THRESHOLD: "0.01",
          DEPTH_PACKING: "0"
        },
        uniforms: {
          inputBuffer: new Uniform(null),
          depthBuffer: new Uniform(null),
          texelSize: new Uniform(texelSize)
        },
        vertexShader: vertexShader$1,
        toneMapped: false,
        depthWrite: false,
        depthTest: false
      }));

      _this13.setEdgeDetectionMode(mode);

      return _this13;
    }

    _createClass(EdgeDetectionMaterial, [{
      key: "setEdgeDetectionMode",
      value: function setEdgeDetectionMode(mode) {
        switch (mode) {
          case EdgeDetectionMode.DEPTH:
            this.fragmentShader = fragmentShaderDepth;
            break;

          case EdgeDetectionMode.LUMA:
            this.fragmentShader = fragmentShaderLuma;
            break;

          case EdgeDetectionMode.COLOR:
          default:
            this.fragmentShader = fragmentShaderColor;
            break;
        }

        this.defines.EDGE_DETECTION_MODE = mode.toFixed(0);
        this.needsUpdate = true;
      }
    }, {
      key: "setLocalContrastAdaptationFactor",
      value: function setLocalContrastAdaptationFactor(factor) {
        this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = factor.toFixed("2");
        this.needsUpdate = true;
      }
    }, {
      key: "setEdgeDetectionThreshold",
      value: function setEdgeDetectionThreshold(threshold) {
        threshold = Math.min(Math.max(threshold, 0.05), 0.5);
        this.defines.EDGE_THRESHOLD = threshold.toFixed("2");
        this.defines.DEPTH_THRESHOLD = (threshold * 0.1).toFixed("3");
        this.needsUpdate = true;
      }
    }, {
      key: "depthPacking",
      get: function get() {
        return Number(this.defines.DEPTH_PACKING);
      },
      set: function set(value) {
        this.defines.DEPTH_PACKING = value.toFixed(0);
        this.needsUpdate = true;
      }
    }]);

    return EdgeDetectionMaterial;
  }(ShaderMaterial);

  var EdgeDetectionMode = {
    DEPTH: 0,
    LUMA: 1,
    COLOR: 2
  };
  var fragmentTemplate = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\nuniform sampler2D inputBuffer;uniform sampler2D depthBuffer;uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <encodings_fragment>\n#endif\n#include <dithering_fragment>\n}";
  var vertexTemplate = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}";

  var EffectMaterial = function (_ShaderMaterial9) {
    _inherits(EffectMaterial, _ShaderMaterial9);

    function EffectMaterial() {
      var _this14;

      var shaderParts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var defines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var uniforms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var camera = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var dithering = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      _classCallCheck(this, EffectMaterial);

      _this14 = _possibleConstructorReturn(this, _getPrototypeOf(EffectMaterial).call(this, {
        type: "EffectMaterial",
        defines: {
          DEPTH_PACKING: "0",
          ENCODE_OUTPUT: "1"
        },
        uniforms: {
          inputBuffer: new Uniform(null),
          depthBuffer: new Uniform(null),
          resolution: new Uniform(new Vector2()),
          texelSize: new Uniform(new Vector2()),
          cameraNear: new Uniform(0.3),
          cameraFar: new Uniform(1000.0),
          aspect: new Uniform(1.0),
          time: new Uniform(0.0)
        },
        toneMapped: false,
        depthWrite: false,
        depthTest: false,
        dithering: dithering
      }));

      if (shaderParts !== null) {
        _this14.setShaderParts(shaderParts);
      }

      if (defines !== null) {
        _this14.setDefines(defines);
      }

      if (uniforms !== null) {
        _this14.setUniforms(uniforms);
      }

      _this14.adoptCameraSettings(camera);

      return _this14;
    }

    _createClass(EffectMaterial, [{
      key: "setShaderParts",
      value: function setShaderParts(shaderParts) {
        this.fragmentShader = fragmentTemplate.replace(Section.FRAGMENT_HEAD, shaderParts.get(Section.FRAGMENT_HEAD)).replace(Section.FRAGMENT_MAIN_UV, shaderParts.get(Section.FRAGMENT_MAIN_UV)).replace(Section.FRAGMENT_MAIN_IMAGE, shaderParts.get(Section.FRAGMENT_MAIN_IMAGE));
        this.vertexShader = vertexTemplate.replace(Section.VERTEX_HEAD, shaderParts.get(Section.VERTEX_HEAD)).replace(Section.VERTEX_MAIN_SUPPORT, shaderParts.get(Section.VERTEX_MAIN_SUPPORT));
        this.needsUpdate = true;
        return this;
      }
    }, {
      key: "setDefines",
      value: function setDefines(defines) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = defines.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var entry = _step3.value;
            this.defines[entry[0]] = entry[1];
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        this.needsUpdate = true;
        return this;
      }
    }, {
      key: "setUniforms",
      value: function setUniforms(uniforms) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = uniforms.entries()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var entry = _step4.value;
            this.uniforms[entry[0]] = entry[1];
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        return this;
      }
    }, {
      key: "adoptCameraSettings",
      value: function adoptCameraSettings() {
        var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (camera !== null) {
          this.uniforms.cameraNear.value = camera.near;
          this.uniforms.cameraFar.value = camera.far;

          if (camera instanceof PerspectiveCamera) {
            this.defines.PERSPECTIVE_CAMERA = "1";
          } else {
            delete this.defines.PERSPECTIVE_CAMERA;
          }

          this.needsUpdate = true;
        }
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        width = Math.max(width, 1.0);
        height = Math.max(height, 1.0);
        this.uniforms.resolution.value.set(width, height);
        this.uniforms.texelSize.value.set(1.0 / width, 1.0 / height);
        this.uniforms.aspect.value = width / height;
      }
    }, {
      key: "depthPacking",
      get: function get() {
        return Number(this.defines.DEPTH_PACKING);
      },
      set: function set(value) {
        this.defines.DEPTH_PACKING = value.toFixed(0);
        this.needsUpdate = true;
      }
    }]);

    return EffectMaterial;
  }(ShaderMaterial);

  var Section = {
    FRAGMENT_HEAD: "FRAGMENT_HEAD",
    FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
    FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
    VERTEX_HEAD: "VERTEX_HEAD",
    VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
  };
  var fragmentShader$7 = "#include <common>\n#include <dithering_pars_fragment>\nuniform sampler2D inputBuffer;uniform vec2 lightPosition;uniform float exposure;uniform float decay;uniform float density;uniform float weight;uniform float clampMax;varying vec2 vUv;void main(){vec2 coord=vUv;vec2 delta=lightPosition-coord;delta*=1.0/SAMPLES_FLOAT*density;float illuminationDecay=1.0;vec4 color=vec4(0.0);/*Estimate the probability of occlusion at each pixel by summing samplesalong a ray to the light position.*/for(int i=0;i<SAMPLES_INT;++i){coord+=delta;vec4 texel=texture2D(inputBuffer,coord);texel*=illuminationDecay*weight;color+=texel;illuminationDecay*=decay;}gl_FragColor=clamp(color*exposure,0.0,clampMax);\n#include <dithering_fragment>\n}";

  var GodRaysMaterial = function (_ShaderMaterial10) {
    _inherits(GodRaysMaterial, _ShaderMaterial10);

    function GodRaysMaterial(lightPosition) {
      _classCallCheck(this, GodRaysMaterial);

      return _possibleConstructorReturn(this, _getPrototypeOf(GodRaysMaterial).call(this, {
        type: "GodRaysMaterial",
        defines: {
          SAMPLES_INT: "60",
          SAMPLES_FLOAT: "60.0"
        },
        uniforms: {
          inputBuffer: new Uniform(null),
          lightPosition: new Uniform(lightPosition),
          density: new Uniform(1.0),
          decay: new Uniform(1.0),
          weight: new Uniform(1.0),
          exposure: new Uniform(1.0),
          clampMax: new Uniform(1.0)
        },
        fragmentShader: fragmentShader$7,
        vertexShader: vertexShader,
        toneMapped: false,
        depthWrite: false,
        depthTest: false
      }));
    }

    _createClass(GodRaysMaterial, [{
      key: "samples",
      get: function get() {
        return Number.parseInt(this.defines.SAMPLES_INT);
      },
      set: function set(value) {
        value = Math.floor(value);
        this.defines.SAMPLES_INT = value.toFixed(0);
        this.defines.SAMPLES_FLOAT = value.toFixed(1);
        this.needsUpdate = true;
      }
    }]);

    return GodRaysMaterial;
  }(ShaderMaterial);

  var fragmentShader$8 = "#include <common>\nuniform sampler2D inputBuffer;\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=linearToRelativeLuminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l);\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*l,l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}";

  var LuminanceMaterial = function (_ShaderMaterial11) {
    _inherits(LuminanceMaterial, _ShaderMaterial11);

    function LuminanceMaterial() {
      var _this15;

      var colorOutput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var luminanceRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, LuminanceMaterial);

      var useRange = luminanceRange !== null;
      _this15 = _possibleConstructorReturn(this, _getPrototypeOf(LuminanceMaterial).call(this, {
        type: "LuminanceMaterial",
        uniforms: {
          inputBuffer: new Uniform(null),
          threshold: new Uniform(0.0),
          smoothing: new Uniform(1.0),
          range: new Uniform(useRange ? luminanceRange : new Vector2())
        },
        fragmentShader: fragmentShader$8,
        vertexShader: vertexShader,
        toneMapped: false,
        depthWrite: false,
        depthTest: false
      }));
      _this15.colorOutput = colorOutput;
      _this15.useThreshold = true;
      _this15.useRange = useRange;
      return _this15;
    }

    _createClass(LuminanceMaterial, [{
      key: "setColorOutputEnabled",
      value: function setColorOutputEnabled(enabled) {
        enabled ? this.defines.COLOR = "1" : delete this.defines.COLOR;
        this.needsUpdate = true;
      }
    }, {
      key: "setLuminanceRangeEnabled",
      value: function setLuminanceRangeEnabled(enabled) {
        enabled ? this.defines.RANGE = "1" : delete this.defines.RANGE;
        this.needsUpdate = true;
      }
    }, {
      key: "threshold",
      get: function get() {
        return this.uniforms.threshold.value;
      },
      set: function set(value) {
        this.uniforms.threshold.value = value;
      }
    }, {
      key: "smoothing",
      get: function get() {
        return this.uniforms.smoothing.value;
      },
      set: function set(value) {
        this.uniforms.smoothing.value = value;
      }
    }, {
      key: "useThreshold",
      get: function get() {
        return this.defines.THRESHOLD !== undefined;
      },
      set: function set(value) {
        value ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD;
        this.needsUpdate = true;
      }
    }, {
      key: "colorOutput",
      get: function get() {
        return this.defines.COLOR !== undefined;
      },
      set: function set(value) {
        value ? this.defines.COLOR = "1" : delete this.defines.COLOR;
        this.needsUpdate = true;
      }
    }, {
      key: "useRange",
      get: function get() {
        return this.defines.RANGE !== undefined;
      },
      set: function set(value) {
        value ? this.defines.RANGE = "1" : delete this.defines.RANGE;
        this.needsUpdate = true;
      }
    }, {
      key: "luminanceRange",
      get: function get() {
        return this.defines.RANGE !== undefined;
      },
      set: function set(value) {
        value ? this.defines.RANGE = "1" : delete this.defines.RANGE;
        this.needsUpdate = true;
      }
    }]);

    return LuminanceMaterial;
  }(ShaderMaterial);

  var fragmentShader$9 = "uniform sampler2D maskTexture;uniform sampler2D inputBuffer;varying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nif(mask>0.0){discard;}\n#else\nif(mask==0.0){discard;}\n#endif\n#else\n#ifdef INVERTED\ngl_FragColor=(1.0-mask)*texture2D(inputBuffer,vUv);\n#else\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#endif\n#endif\n}";

  var MaskMaterial = function (_ShaderMaterial12) {
    _inherits(MaskMaterial, _ShaderMaterial12);

    function MaskMaterial() {
      var _this16;

      var maskTexture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _classCallCheck(this, MaskMaterial);

      _this16 = _possibleConstructorReturn(this, _getPrototypeOf(MaskMaterial).call(this, {
        type: "MaskMaterial",
        uniforms: {
          maskTexture: new Uniform(maskTexture),
          inputBuffer: new Uniform(null)
        },
        fragmentShader: fragmentShader$9,
        vertexShader: vertexShader,
        toneMapped: false,
        depthWrite: false,
        depthTest: false
      }));
      _this16.colorChannel = ColorChannel.RED;
      _this16.maskFunction = MaskFunction.DISCARD;
      return _this16;
    }

    _createClass(MaskMaterial, [{
      key: "maskTexture",
      set: function set(value) {
        this.uniforms.maskTexture.value = value;
      }
    }, {
      key: "colorChannel",
      set: function set(value) {
        this.defines.COLOR_CHANNEL = value.toFixed(0);
        this.needsUpdate = true;
      }
    }, {
      key: "maskFunction",
      set: function set(value) {
        this.defines.MASK_FUNCTION = value.toFixed(0);
        this.needsUpdate = true;
      }
    }, {
      key: "inverted",
      get: function get() {
        return this.defines.INVERTED !== undefined;
      },
      set: function set(value) {
        if (this.inverted && !value) {
          delete this.defines.INVERTED;
        } else if (value) {
          this.defines.INVERTED = "1";
        }

        this.needsUpdate = true;
      }
    }]);

    return MaskMaterial;
  }(ShaderMaterial);

  var MaskFunction = {
    DISCARD: 0,
    MULTIPLY: 1
  };
  var fragmentShader$a = "uniform sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)? vec2(d,0.0): vec2(0.0,d);}";
  var vertexShader$4 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}";

  var OutlineMaterial = function (_ShaderMaterial13) {
    _inherits(OutlineMaterial, _ShaderMaterial13);

    function OutlineMaterial() {
      var _this17;

      var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();

      _classCallCheck(this, OutlineMaterial);

      _this17 = _possibleConstructorReturn(this, _getPrototypeOf(OutlineMaterial).call(this, {
        type: "OutlineMaterial",
        uniforms: {
          inputBuffer: new Uniform(null),
          texelSize: new Uniform(new Vector2())
        },
        fragmentShader: fragmentShader$a,
        vertexShader: vertexShader$4,
        toneMapped: false,
        depthWrite: false,
        depthTest: false
      }));

      _this17.setTexelSize(texelSize.x, texelSize.y);

      _this17.uniforms.maskTexture = _this17.uniforms.inputBuffer;
      return _this17;
    }

    _createClass(OutlineMaterial, [{
      key: "setTexelSize",
      value: function setTexelSize(x, y) {
        this.uniforms.texelSize.value.set(x, y);
      }
    }]);

    return OutlineMaterial;
  }(ShaderMaterial);

  var fragmentShader$b = "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\nuniform sampler2D inputBuffer;uniform sampler2D areaTexture;uniform sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;/***Moves values to a target vector based on a given conditional vector.*/void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}/***Allows to decode two binary values from a bilinear-filtered access.**Bilinear access for fetching 'e' have a 0.25 offset,and we are interested*in the R and G edges:**+---G---+-------+*|x o R   x|*+-------+-------+**Then,if one of these edge is enabled:*Red:(0.75*X+0.25*1)=>0.25 or 1.0*Green:(0.75*1+0.25*X)=>0.75 or 1.0**This function will unpack the values(mad+mul+round):*wolframalpha.com: round(x*abs(5*x-5*0.75))plot 0 to 1*/vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}/***Diagonal pattern searches.*/vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}/***Calculates the area corresponding to a certain diagonal distance and crossing*edges 'e'.*/vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}/***Searches for diagonal patterns and returns the corresponding weights.*/vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}/***Determines how much length should be added in the last step of the searches.**Takes the bilinearly interpolated edge(see @PSEUDO_GATHER4),and adds 0,1*or 2 depending on which edges and crossing edges are active.*/float searchLength(const in vec2 e,const in float offset){/*The texture is flipped vertically,with left and right cases taking halfof the space horizontally.*/vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}/***Horizontal search for the second pass.*/float searchXLeft(in vec2 texCoord,const in float end){/*@PSEUDO_GATHER4This texCoord has been offset by(-0.25,-0.125)in the vertex shader tosample between edges,thus fetching four edges in a row.Sampling with different offsets in each direction allows to disambiguatewhich edges are active from the four fetched ones.*/vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}/***Vertical search for the second pass.*/float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}/***Determines the areas at each side of the current edge.*/vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}/***Corner detection.*/void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\n/*Diagonals have both north and west edges,so searching for them in one ofthe boundaries is enough.*/weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;/*Now fetch the left crossing edges,two at a time using bilinearfiltering. Sampling at-0.25(see @CROSSING_OFFSET)enables to discern whatvalue each edge has.*/float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;/*Translate distances to pixel units for better interleave arithmetic andmemory accesses.*/d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}";
  var vertexShader$5 = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}";

  var SMAAWeightsMaterial = function (_ShaderMaterial14) {
    _inherits(SMAAWeightsMaterial, _ShaderMaterial14);

    function SMAAWeightsMaterial() {
      var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
      var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();

      _classCallCheck(this, SMAAWeightsMaterial);

      return _possibleConstructorReturn(this, _getPrototypeOf(SMAAWeightsMaterial).call(this, {
        type: "SMAAWeightsMaterial",
        defines: {
          MAX_SEARCH_STEPS_INT: "16",
          MAX_SEARCH_STEPS_FLOAT: "16.0",
          MAX_SEARCH_STEPS_DIAG_INT: "8",
          MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
          CORNER_ROUNDING: "25",
          CORNER_ROUNDING_NORM: "0.25",
          AREATEX_MAX_DISTANCE: "16.0",
          AREATEX_MAX_DISTANCE_DIAG: "20.0",
          AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
          AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
          SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
          SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
        },
        uniforms: {
          inputBuffer: new Uniform(null),
          areaTexture: new Uniform(null),
          searchTexture: new Uniform(null),
          texelSize: new Uniform(texelSize),
          resolution: new Uniform(resolution)
        },
        fragmentShader: fragmentShader$b,
        vertexShader: vertexShader$5,
        toneMapped: false,
        depthWrite: false,
        depthTest: false
      }));
    }

    _createClass(SMAAWeightsMaterial, [{
      key: "setOrthogonalSearchSteps",
      value: function setOrthogonalSearchSteps(steps) {
        steps = Math.min(Math.max(steps, 0), 112);
        this.defines.MAX_SEARCH_STEPS_INT = steps.toFixed("0");
        this.defines.MAX_SEARCH_STEPS_FLOAT = steps.toFixed("1");
        this.needsUpdate = true;
      }
    }, {
      key: "setDiagonalSearchSteps",
      value: function setDiagonalSearchSteps(steps) {
        steps = Math.min(Math.max(steps, 0), 20);
        this.defines.MAX_SEARCH_STEPS_DIAG_INT = steps.toFixed("0");
        this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = steps.toFixed("1");
        this.needsUpdate = true;
      }
    }, {
      key: "setCornerRounding",
      value: function setCornerRounding(rounding) {
        rounding = Math.min(Math.max(rounding, 0), 100);
        this.defines.CORNER_ROUNDING = rounding.toFixed("4");
        this.defines.CORNER_ROUNDING_NORM = (rounding / 100.0).toFixed("4");
        this.needsUpdate = true;
      }
    }, {
      key: "diagonalDetection",
      get: function get() {
        return this.defines.DISABLE_DIAG_DETECTION === undefined;
      },
      set: function set(value) {
        value ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1";
        this.needsUpdate = true;
      }
    }, {
      key: "cornerRounding",
      get: function get() {
        return this.defines.DISABLE_CORNER_DETECTION === undefined;
      },
      set: function set(value) {
        value ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1";
        this.needsUpdate = true;
      }
    }]);

    return SMAAWeightsMaterial;
  }(ShaderMaterial);

  var AUTO_SIZE = -1;

  var Resizer = function () {
    function Resizer(resizable) {
      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AUTO_SIZE;
      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AUTO_SIZE;

      _classCallCheck(this, Resizer);

      this.resizable = resizable;
      this.base = new Vector2(1, 1);
      this.target = new Vector2(width, height);
      this.scale = 1.0;
    }

    _createClass(Resizer, [{
      key: "width",
      get: function get() {
        var base = this.base;
        var target = this.target;
        var result;

        if (target.x !== AUTO_SIZE) {
          result = target.x;
        } else if (target.y !== AUTO_SIZE) {
          result = Math.round(target.y * (base.x / base.y));
        } else {
          result = Math.round(base.x * this.scale);
        }

        return result;
      },
      set: function set(value) {
        this.target.x = value;
        this.resizable.setSize(this.base.x, this.base.y);
      }
    }, {
      key: "height",
      get: function get() {
        var base = this.base;
        var target = this.target;
        var result;

        if (target.y !== AUTO_SIZE) {
          result = target.y;
        } else if (target.x !== AUTO_SIZE) {
          result = Math.round(target.x / (base.x / base.y));
        } else {
          result = Math.round(base.y * this.scale);
        }

        return result;
      },
      set: function set(value) {
        this.target.y = value;
        this.resizable.setSize(this.base.x, this.base.y);
      }
    }], [{
      key: "AUTO_SIZE",
      get: function get() {
        return AUTO_SIZE;
      }
    }]);

    return Resizer;
  }();

  var geometry = null;

  function getFullscreenTriangle() {
    if (geometry === null) {
      var _vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);

      var _uvs = new Float32Array([0, 0, 2, 0, 0, 2]);

      geometry = new BufferGeometry();

      if (geometry.setAttribute !== undefined) {
        geometry.setAttribute("position", new BufferAttribute(_vertices, 3));
        geometry.setAttribute("uv", new BufferAttribute(_uvs, 2));
      } else {
        geometry.addAttribute("position", new BufferAttribute(_vertices, 3));
        geometry.addAttribute("uv", new BufferAttribute(_uvs, 2));
      }
    }

    return geometry;
  }

  var Pass = function () {
    function Pass() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Pass";
      var scene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Scene();
      var camera = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new OrthographicCamera(-1, 1, 1, -1, 0, 1);

      _classCallCheck(this, Pass);

      this.name = name;
      this.scene = scene;
      this.camera = camera;
      this.screen = null;
      this.rtt = true;
      this.needsSwap = true;
      this.needsDepthTexture = false;
      this.enabled = true;
    }

    _createClass(Pass, [{
      key: "getFullscreenMaterial",
      value: function getFullscreenMaterial() {
        return this.screen !== null ? this.screen.material : null;
      }
    }, {
      key: "setFullscreenMaterial",
      value: function setFullscreenMaterial(material) {
        var screen = this.screen;

        if (screen !== null) {
          screen.material = material;
        } else {
          screen = new Mesh(getFullscreenTriangle(), material);
          screen.frustumCulled = false;

          if (this.scene === null) {
            this.scene = new Scene();
          }

          this.scene.add(screen);
          this.screen = screen;
        }
      }
    }, {
      key: "getDepthTexture",
      value: function getDepthTexture() {
        return null;
      }
    }, {
      key: "setDepthTexture",
      value: function setDepthTexture(depthTexture) {
      }
    }, {
      key: "render",
      value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        throw new Error("Render method not implemented!");
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {}
    }, {
      key: "initialize",
      value: function initialize(renderer, alpha, frameBufferType) {}
    }, {
      key: "dispose",
      value: function dispose() {
        var material = this.getFullscreenMaterial();

        if (material !== null) {
          material.dispose();
        }

        for (var _i2 = 0, _Object$keys = Object.keys(this); _i2 < _Object$keys.length; _i2++) {
          var key = _Object$keys[_i2];

          if (this[key] !== null && typeof this[key].dispose === "function") {
            this[key].dispose();
          }
        }
      }
    }, {
      key: "renderToScreen",
      get: function get() {
        return !this.rtt;
      },
      set: function set(value) {
        var material = this.getFullscreenMaterial();

        if (material !== null) {
          material.needsUpdate = true;
        }

        this.rtt = !value;
      }
    }]);

    return Pass;
  }();

  var BlurPass = function (_Pass) {
    _inherits(BlurPass, _Pass);

    function BlurPass() {
      var _this18;

      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$resolutionScale = _ref4.resolutionScale,
          resolutionScale = _ref4$resolutionScale === void 0 ? 0.5 : _ref4$resolutionScale,
          _ref4$width = _ref4.width,
          width = _ref4$width === void 0 ? Resizer.AUTO_SIZE : _ref4$width,
          _ref4$height = _ref4.height,
          height = _ref4$height === void 0 ? Resizer.AUTO_SIZE : _ref4$height,
          _ref4$kernelSize = _ref4.kernelSize,
          kernelSize = _ref4$kernelSize === void 0 ? KernelSize.LARGE : _ref4$kernelSize;

      _classCallCheck(this, BlurPass);

      _this18 = _possibleConstructorReturn(this, _getPrototypeOf(BlurPass).call(this, "BlurPass"));
      _this18.renderTargetA = new WebGLRenderTarget(1, 1, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      });
      _this18.renderTargetA.texture.name = "Blur.Target.A";
      _this18.renderTargetB = _this18.renderTargetA.clone();
      _this18.renderTargetB.texture.name = "Blur.Target.B";
      _this18.resolution = new Resizer(_assertThisInitialized(_this18), width, height);
      _this18.resolution.scale = resolutionScale;
      _this18.convolutionMaterial = new ConvolutionMaterial();
      _this18.ditheredConvolutionMaterial = new ConvolutionMaterial();
      _this18.ditheredConvolutionMaterial.dithering = true;
      _this18.dithering = false;
      _this18.kernelSize = kernelSize;
      return _this18;
    }

    _createClass(BlurPass, [{
      key: "getResolutionScale",
      value: function getResolutionScale() {
        return this.resolution.scale;
      }
    }, {
      key: "setResolutionScale",
      value: function setResolutionScale(scale) {
        this.resolution.scale = scale;
        this.setSize(this.resolution.base.x, this.resolution.base.y);
      }
    }, {
      key: "render",
      value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        var scene = this.scene;
        var camera = this.camera;
        var renderTargetA = this.renderTargetA;
        var renderTargetB = this.renderTargetB;
        var material = this.convolutionMaterial;
        var uniforms = material.uniforms;
        var kernel = material.getKernel();
        var lastRT = inputBuffer;
        var destRT;
        var i, l;
        this.setFullscreenMaterial(material);

        for (i = 0, l = kernel.length - 1; i < l; ++i) {
          destRT = (i & 1) === 0 ? renderTargetA : renderTargetB;
          uniforms.kernel.value = kernel[i];
          uniforms.inputBuffer.value = lastRT.texture;
          renderer.setRenderTarget(destRT);
          renderer.render(scene, camera);
          lastRT = destRT;
        }

        if (this.dithering) {
          material = this.ditheredConvolutionMaterial;
          uniforms = material.uniforms;
          this.setFullscreenMaterial(material);
        }

        uniforms.kernel.value = kernel[i];
        uniforms.inputBuffer.value = lastRT.texture;
        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
        renderer.render(scene, camera);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        var resolution = this.resolution;
        resolution.base.set(width, height);
        width = resolution.width;
        height = resolution.height;
        this.renderTargetA.setSize(width, height);
        this.renderTargetB.setSize(width, height);
        this.convolutionMaterial.setTexelSize(1.0 / width, 1.0 / height);
        this.ditheredConvolutionMaterial.setTexelSize(1.0 / width, 1.0 / height);
      }
    }, {
      key: "initialize",
      value: function initialize(renderer, alpha, frameBufferType) {
        if (!alpha) {
          this.renderTargetA.texture.format = RGBFormat;
          this.renderTargetB.texture.format = RGBFormat;
        }

        if (frameBufferType !== undefined) {
          this.renderTargetA.texture.type = frameBufferType;
          this.renderTargetB.texture.type = frameBufferType;
        }
      }
    }, {
      key: "width",
      get: function get() {
        return this.resolution.width;
      },
      set: function set(value) {
        this.resolution.width = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this.resolution.height;
      },
      set: function set(value) {
        this.resolution.height = value;
      }
    }, {
      key: "scale",
      get: function get() {
        return this.convolutionMaterial.uniforms.scale.value;
      },
      set: function set(value) {
        this.convolutionMaterial.uniforms.scale.value = value;
        this.ditheredConvolutionMaterial.uniforms.scale.value = value;
      }
    }, {
      key: "kernelSize",
      get: function get() {
        return this.convolutionMaterial.kernelSize;
      },
      set: function set(value) {
        this.convolutionMaterial.kernelSize = value;
        this.ditheredConvolutionMaterial.kernelSize = value;
      }
    }], [{
      key: "AUTO_SIZE",
      get: function get() {
        return Resizer.AUTO_SIZE;
      }
    }]);

    return BlurPass;
  }(Pass);

  var ClearMaskPass = function (_Pass2) {
    _inherits(ClearMaskPass, _Pass2);

    function ClearMaskPass() {
      var _this19;

      _classCallCheck(this, ClearMaskPass);

      _this19 = _possibleConstructorReturn(this, _getPrototypeOf(ClearMaskPass).call(this, "ClearMaskPass", null, null));
      _this19.needsSwap = false;
      return _this19;
    }

    _createClass(ClearMaskPass, [{
      key: "render",
      value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        var stencil = renderer.state.buffers.stencil;
        stencil.setLocked(false);
        stencil.setTest(false);
      }
    }]);

    return ClearMaskPass;
  }(Pass);

  var color = new Color();

  var ClearPass = function (_Pass3) {
    _inherits(ClearPass, _Pass3);

    function ClearPass() {
      var _this20;

      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var stencil = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _classCallCheck(this, ClearPass);

      _this20 = _possibleConstructorReturn(this, _getPrototypeOf(ClearPass).call(this, "ClearPass", null, null));
      _this20.needsSwap = false;
      _this20.color = color;
      _this20.depth = depth;
      _this20.stencil = stencil;
      _this20.overrideClearColor = null;
      _this20.overrideClearAlpha = -1.0;
      return _this20;
    }

    _createClass(ClearPass, [{
      key: "render",
      value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        var overrideClearColor = this.overrideClearColor;
        var overrideClearAlpha = this.overrideClearAlpha;
        var clearAlpha = renderer.getClearAlpha();
        var hasOverrideClearColor = overrideClearColor !== null;
        var hasOverrideClearAlpha = overrideClearAlpha >= 0.0;

        if (hasOverrideClearColor) {
          color.copy(renderer.getClearColor());
          renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);
        } else if (hasOverrideClearAlpha) {
          renderer.setClearAlpha(overrideClearAlpha);
        }

        renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);
        renderer.clear(this.color, this.depth, this.stencil);

        if (hasOverrideClearColor) {
          renderer.setClearColor(color, clearAlpha);
        } else if (hasOverrideClearAlpha) {
          renderer.setClearAlpha(clearAlpha);
        }
      }
    }]);

    return ClearPass;
  }(Pass);

  var RenderPass = function (_Pass4) {
    _inherits(RenderPass, _Pass4);

    function RenderPass(scene, camera) {
      var _this21;

      var overrideMaterial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      _classCallCheck(this, RenderPass);

      _this21 = _possibleConstructorReturn(this, _getPrototypeOf(RenderPass).call(this, "RenderPass", scene, camera));
      _this21.needsSwap = false;
      _this21.overrideMaterial = overrideMaterial;
      _this21.clearPass = new ClearPass();
      _this21.depthTexture = null;
      return _this21;
    }

    _createClass(RenderPass, [{
      key: "getClearPass",
      value: function getClearPass() {
        return this.clearPass;
      }
    }, {
      key: "getDepthTexture",
      value: function getDepthTexture() {
        return this.depthTexture;
      }
    }, {
      key: "setDepthTexture",
      value: function setDepthTexture(depthTexture) {
        this.depthTexture = depthTexture;
      }
    }, {
      key: "render",
      value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        var scene = this.scene;
        var renderTarget = this.renderToScreen ? null : inputBuffer;
        var overrideMaterial = scene.overrideMaterial;

        if (this.depthTexture !== null && !this.renderToScreen) {
          inputBuffer.depthTexture = this.depthTexture;
          outputBuffer.depthTexture = null;
        }

        if (this.clear) {
          this.clearPass.renderToScreen = this.renderToScreen;
          this.clearPass.render(renderer, inputBuffer);
        }

        scene.overrideMaterial = this.overrideMaterial;
        renderer.setRenderTarget(renderTarget);
        renderer.render(scene, this.camera);
        scene.overrideMaterial = overrideMaterial;
      }
    }, {
      key: "clear",
      get: function get() {
        return this.clearPass.enabled;
      },
      set: function set(value) {
        this.clearPass.enabled = value;
      }
    }]);

    return RenderPass;
  }(Pass);

  var DepthPass = function (_Pass5) {
    _inherits(DepthPass, _Pass5);

    function DepthPass(scene, camera) {
      var _this22;

      var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref5$resolutionScale = _ref5.resolutionScale,
          resolutionScale = _ref5$resolutionScale === void 0 ? 1.0 : _ref5$resolutionScale,
          _ref5$width = _ref5.width,
          width = _ref5$width === void 0 ? Resizer.AUTO_SIZE : _ref5$width,
          _ref5$height = _ref5.height,
          height = _ref5$height === void 0 ? Resizer.AUTO_SIZE : _ref5$height,
          renderTarget = _ref5.renderTarget;

      _classCallCheck(this, DepthPass);

      _this22 = _possibleConstructorReturn(this, _getPrototypeOf(DepthPass).call(this, "DepthPass"));
      _this22.needsSwap = false;
      _this22.renderPass = new RenderPass(scene, camera, new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: true,
        skinning: true
      }));

      var clearPass = _this22.renderPass.getClearPass();

      clearPass.overrideClearColor = new Color(0xffffff);
      clearPass.overrideClearAlpha = 1.0;
      _this22.renderTarget = renderTarget;

      if (_this22.renderTarget === undefined) {
        _this22.renderTarget = new WebGLRenderTarget(1, 1, {
          minFilter: NearestFilter,
          magFilter: NearestFilter,
          stencilBuffer: false
        });
        _this22.renderTarget.texture.name = "DepthPass.Target";
      }

      _this22.resolution = new Resizer(_assertThisInitialized(_this22), width, height);
      _this22.resolution.scale = resolutionScale;
      return _this22;
    }

    _createClass(DepthPass, [{
      key: "getResolutionScale",
      value: function getResolutionScale() {
        return this.resolutionScale;
      }
    }, {
      key: "setResolutionScale",
      value: function setResolutionScale(scale) {
        this.resolutionScale = scale;
        this.setSize(this.originalSize.x, this.originalSize.y);
      }
    }, {
      key: "render",
      value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        var renderTarget = this.renderToScreen ? null : this.renderTarget;
        this.renderPass.render(renderer, renderTarget);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        var resolution = this.resolution;
        resolution.base.set(width, height);
        width = resolution.width;
        height = resolution.height;
        this.renderTarget.setSize(width, height);
      }
    }]);

    return DepthPass;
  }(Pass);

  var BlendFunction = {
    SKIP: 0,
    ADD: 1,
    ALPHA: 2,
    AVERAGE: 3,
    COLOR_BURN: 4,
    COLOR_DODGE: 5,
    DARKEN: 6,
    DIFFERENCE: 7,
    EXCLUSION: 8,
    LIGHTEN: 9,
    MULTIPLY: 10,
    DIVIDE: 11,
    NEGATION: 12,
    NORMAL: 13,
    OVERLAY: 14,
    REFLECT: 15,
    SCREEN: 16,
    SOFT_LIGHT: 17,
    SUBTRACT: 18
  };
  var addBlendFunction = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}";
  var alphaBlendFunction = "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}";
  var averageBlendFunction = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}";
  var colorBurnBlendFunction = "float blend(const in float x,const in float y){return(y==0.0)? y : max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
  var colorDodgeBlendFunction = "float blend(const in float x,const in float y){return(y==1.0)? y : min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
  var darkenBlendFunction = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}";
  var differenceBlendFunction = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}";
  var exclusionBlendFunction = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}";
  var lightenBlendFunction = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}";
  var multiplyBlendFunction = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}";
  var divideBlendFunction = "float blend(const in float x,const in float y){return(y>0.0)? min(x/y,1.0): 1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
  var negationBlendFunction = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}";
  var normalBlendFunction = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}";
  var overlayBlendFunction = "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
  var reflectBlendFunction = "float blend(const in float x,const in float y){return(y==1.0)? y : min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
  var screenBlendFunction = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}";
  var softLightBlendFunction = "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
  var subtractBlendFunction = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}";
  var blendFunctions = new Map([[BlendFunction.SKIP, null], [BlendFunction.ADD, addBlendFunction], [BlendFunction.ALPHA, alphaBlendFunction], [BlendFunction.AVERAGE, averageBlendFunction], [BlendFunction.COLOR_BURN, colorBurnBlendFunction], [BlendFunction.COLOR_DODGE, colorDodgeBlendFunction], [BlendFunction.DARKEN, darkenBlendFunction], [BlendFunction.DIFFERENCE, differenceBlendFunction], [BlendFunction.EXCLUSION, exclusionBlendFunction], [BlendFunction.LIGHTEN, lightenBlendFunction], [BlendFunction.MULTIPLY, multiplyBlendFunction], [BlendFunction.DIVIDE, divideBlendFunction], [BlendFunction.NEGATION, negationBlendFunction], [BlendFunction.NORMAL, normalBlendFunction], [BlendFunction.OVERLAY, overlayBlendFunction], [BlendFunction.REFLECT, reflectBlendFunction], [BlendFunction.SCREEN, screenBlendFunction], [BlendFunction.SOFT_LIGHT, softLightBlendFunction], [BlendFunction.SUBTRACT, subtractBlendFunction]]);

  var BlendMode = function () {
    function BlendMode(blendFunction) {
      var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;

      _classCallCheck(this, BlendMode);

      this.blendFunction = blendFunction;
      this.opacity = new Uniform(opacity);
    }

    _createClass(BlendMode, [{
      key: "getShaderCode",
      value: function getShaderCode() {
        return blendFunctions.get(this.blendFunction);
      }
    }]);

    return BlendMode;
  }();

  var Effect = function () {
    function Effect(name, fragmentShader) {
      var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref6$attributes = _ref6.attributes,
          attributes = _ref6$attributes === void 0 ? EffectAttribute.NONE : _ref6$attributes,
          _ref6$blendFunction = _ref6.blendFunction,
          blendFunction = _ref6$blendFunction === void 0 ? BlendFunction.SCREEN : _ref6$blendFunction,
          _ref6$defines = _ref6.defines,
          defines = _ref6$defines === void 0 ? new Map() : _ref6$defines,
          _ref6$uniforms = _ref6.uniforms,
          uniforms = _ref6$uniforms === void 0 ? new Map() : _ref6$uniforms,
          _ref6$extensions = _ref6.extensions,
          extensions = _ref6$extensions === void 0 ? null : _ref6$extensions,
          _ref6$vertexShader = _ref6.vertexShader,
          vertexShader = _ref6$vertexShader === void 0 ? null : _ref6$vertexShader;

      _classCallCheck(this, Effect);

      this.name = name;
      this.attributes = attributes;
      this.fragmentShader = fragmentShader;
      this.vertexShader = vertexShader;
      this.defines = defines;
      this.uniforms = uniforms;
      this.extensions = extensions;
      this.blendMode = new BlendMode(blendFunction);
    }

    _createClass(Effect, [{
      key: "setDepthTexture",
      value: function setDepthTexture(depthTexture) {
      }
    }, {
      key: "update",
      value: function update(renderer, inputBuffer, deltaTime) {}
    }, {
      key: "setSize",
      value: function setSize(width, height) {}
    }, {
      key: "initialize",
      value: function initialize(renderer, alpha, frameBufferType) {}
    }, {
      key: "dispose",
      value: function dispose() {
        for (var _i3 = 0, _Object$keys2 = Object.keys(this); _i3 < _Object$keys2.length; _i3++) {
          var key = _Object$keys2[_i3];

          if (this[key] !== null && typeof this[key].dispose === "function") {
            this[key].dispose();
          }
        }
      }
    }]);

    return Effect;
  }();

  var EffectAttribute = {
    CONVOLUTION: 2,
    DEPTH: 1,
    NONE: 0
  };

  function findSubstrings(regExp, string) {
    var substrings = [];
    var result;

    while ((result = regExp.exec(string)) !== null) {
      substrings.push(result[1]);
    }

    return substrings;
  }

  function prefixSubstrings(prefix, substrings, strings) {
    var prefixed, regExp;
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = substrings[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var substring = _step5.value;
        prefixed = "$1" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);
        regExp = new RegExp("([^\\.])(\\b" + substring + "\\b)", "g");
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = strings.entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var entry = _step6.value;

            if (entry[1] !== null) {
              strings.set(entry[0], entry[1].replace(regExp, prefixed));
            }
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
          _iterator5["return"]();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }
  }

  function integrateEffect(prefix, effect, shaderParts, blendModes, defines, uniforms, attributes) {
    var functionRegExp = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g;
    var varyingRegExp = /(?:varying\s+\w+\s+(\w*))/g;
    var blendMode = effect.blendMode;
    var shaders = new Map([["fragment", effect.fragmentShader], ["vertex", effect.vertexShader]]);
    var mainImageExists = shaders.get("fragment") !== undefined && shaders.get("fragment").indexOf("mainImage") >= 0;
    var mainUvExists = shaders.get("fragment") !== undefined && shaders.get("fragment").indexOf("mainUv") >= 0;
    var varyings = [],
        names = [];
    var transformedUv = false;
    var readDepth = false;

    if (shaders.get("fragment") === undefined) {
      console.error("Missing fragment shader", effect);
    } else if (mainUvExists && (attributes & EffectAttribute.CONVOLUTION) !== 0) {
      console.error("Effects that transform UV coordinates are incompatible with convolution effects", effect);
    } else if (!mainImageExists && !mainUvExists) {
      console.error("The fragment shader contains neither a mainImage nor a mainUv function", effect);
    } else {
      if (mainUvExists) {
        shaderParts.set(Section.FRAGMENT_MAIN_UV, shaderParts.get(Section.FRAGMENT_MAIN_UV) + "\t" + prefix + "MainUv(UV);\n");
        transformedUv = true;
      }

      if (shaders.get("vertex") !== null && shaders.get("vertex").indexOf("mainSupport") >= 0) {
        var string = "\t" + prefix + "MainSupport(";

        if (shaders.get("vertex").indexOf("uv") >= 0) {
          string += "vUv";
        }

        string += ");\n";
        shaderParts.set(Section.VERTEX_MAIN_SUPPORT, shaderParts.get(Section.VERTEX_MAIN_SUPPORT) + string);
        varyings = varyings.concat(findSubstrings(varyingRegExp, shaders.get("vertex")));
        names = names.concat(varyings).concat(findSubstrings(functionRegExp, shaders.get("vertex")));
      }

      names = names.concat(findSubstrings(functionRegExp, shaders.get("fragment"))).concat(Array.from(effect.uniforms.keys())).concat(Array.from(effect.defines.keys()));
      effect.uniforms.forEach(function (value, key) {
        return uniforms.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), value);
      });
      effect.defines.forEach(function (value, key) {
        return defines.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), value);
      });
      prefixSubstrings(prefix, names, defines);
      prefixSubstrings(prefix, names, shaders);
      blendModes.set(blendMode.blendFunction, blendMode);

      if (mainImageExists) {
        var _string = prefix + "MainImage(color0, UV, ";

        if ((attributes & EffectAttribute.DEPTH) !== 0 && shaders.get("fragment").indexOf("depth") >= 0) {
          _string += "depth, ";
          readDepth = true;
        }

        _string += "color1);\n\t";
        var blendOpacity = prefix + "BlendOpacity";
        uniforms.set(blendOpacity, blendMode.opacity);
        _string += "color0 = blend" + blendMode.blendFunction + "(color0, color1, " + blendOpacity + ");\n\n\t";
        shaderParts.set(Section.FRAGMENT_MAIN_IMAGE, shaderParts.get(Section.FRAGMENT_MAIN_IMAGE) + _string);
        shaderParts.set(Section.FRAGMENT_HEAD, shaderParts.get(Section.FRAGMENT_HEAD) + "uniform float " + blendOpacity + ";\n\n");
      }

      shaderParts.set(Section.FRAGMENT_HEAD, shaderParts.get(Section.FRAGMENT_HEAD) + shaders.get("fragment") + "\n");

      if (shaders.get("vertex") !== null) {
        shaderParts.set(Section.VERTEX_HEAD, shaderParts.get(Section.VERTEX_HEAD) + shaders.get("vertex") + "\n");
      }
    }

    return {
      varyings: varyings,
      transformedUv: transformedUv,
      readDepth: readDepth
    };
  }

  var EffectPass = function (_Pass6) {
    _inherits(EffectPass, _Pass6);

    function EffectPass(camera) {
      var _this23;

      _classCallCheck(this, EffectPass);

      _this23 = _possibleConstructorReturn(this, _getPrototypeOf(EffectPass).call(this, "EffectPass"));

      _this23.setFullscreenMaterial(new EffectMaterial(null, null, null, camera));

      for (var _len = arguments.length, effects = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
        effects[_key2 - 1] = arguments[_key2];
      }

      _this23.effects = effects.sort(function (a, b) {
        return b.attributes - a.attributes;
      });
      _this23.skipRendering = false;
      _this23.uniforms = 0;
      _this23.varyings = 0;
      _this23.minTime = 1.0;
      _this23.maxTime = 1e3;
      return _this23;
    }

    _createClass(EffectPass, [{
      key: "updateMaterial",
      value: function updateMaterial() {
        var blendRegExp = /\bblend\b/g;
        var shaderParts = new Map([[Section.FRAGMENT_HEAD, ""], [Section.FRAGMENT_MAIN_UV, ""], [Section.FRAGMENT_MAIN_IMAGE, ""], [Section.VERTEX_HEAD, ""], [Section.VERTEX_MAIN_SUPPORT, ""]]);
        var blendModes = new Map();
        var defines = new Map();
        var uniforms = new Map();
        var extensions = new Set();
        var id = 0,
            varyings = 0,
            attributes = 0;
        var transformedUv = false;
        var readDepth = false;
        var result;
        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = this.effects[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var effect = _step7.value;

            if (effect.blendMode.blendFunction === BlendFunction.SKIP) {
              attributes |= effect.attributes & EffectAttribute.DEPTH;
            } else if ((attributes & EffectAttribute.CONVOLUTION) !== 0 && (effect.attributes & EffectAttribute.CONVOLUTION) !== 0) {
              console.error("Convolution effects cannot be merged", effect);
            } else {
              attributes |= effect.attributes;
              result = integrateEffect("e" + id++, effect, shaderParts, blendModes, defines, uniforms, attributes);
              varyings += result.varyings.length;
              transformedUv = transformedUv || result.transformedUv;
              readDepth = readDepth || result.readDepth;

              if (effect.extensions !== null) {
                var _iteratorNormalCompletion10 = true;
                var _didIteratorError10 = false;
                var _iteratorError10 = undefined;

                try {
                  for (var _iterator10 = effect.extensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                    var _extension = _step10.value;
                    extensions.add(_extension);
                  }
                } catch (err) {
                  _didIteratorError10 = true;
                  _iteratorError10 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
                      _iterator10["return"]();
                    }
                  } finally {
                    if (_didIteratorError10) {
                      throw _iteratorError10;
                    }
                  }
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
              _iterator7["return"]();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }

        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = blendModes.values()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var blendMode = _step8.value;
            shaderParts.set(Section.FRAGMENT_HEAD, shaderParts.get(Section.FRAGMENT_HEAD) + blendMode.getShaderCode().replace(blendRegExp, "blend" + blendMode.blendFunction) + "\n");
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
              _iterator8["return"]();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }

        if ((attributes & EffectAttribute.DEPTH) !== 0) {
          if (readDepth) {
            shaderParts.set(Section.FRAGMENT_MAIN_IMAGE, "float depth = readDepth(UV);\n\n\t" + shaderParts.get(Section.FRAGMENT_MAIN_IMAGE));
          }

          this.needsDepthTexture = this.getDepthTexture() === null;
        } else {
          this.needsDepthTexture = false;
        }

        if (transformedUv) {
          shaderParts.set(Section.FRAGMENT_MAIN_UV, "vec2 transformedUv = vUv;\n" + shaderParts.get(Section.FRAGMENT_MAIN_UV));
          defines.set("UV", "transformedUv");
        } else {
          defines.set("UV", "vUv");
        }

        shaderParts.forEach(function (value, key, map) {
          return map.set(key, value.trim());
        });
        this.uniforms = uniforms.size;
        this.varyings = varyings;
        this.skipRendering = id === 0;
        this.needsSwap = !this.skipRendering;
        var material = this.getFullscreenMaterial();
        material.setShaderParts(shaderParts).setDefines(defines).setUniforms(uniforms);
        material.extensions = {};

        if (extensions.size > 0) {
          var _iteratorNormalCompletion9 = true;
          var _didIteratorError9 = false;
          var _iteratorError9 = undefined;

          try {
            for (var _iterator9 = extensions[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
              var extension = _step9.value;
              material.extensions[extension] = true;
            }
          } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
                _iterator9["return"]();
              }
            } finally {
              if (_didIteratorError9) {
                throw _iteratorError9;
              }
            }
          }
        }
      }
    }, {
      key: "recompile",
      value: function recompile() {
        this.updateMaterial();
      }
    }, {
      key: "getDepthTexture",
      value: function getDepthTexture() {
        return this.getFullscreenMaterial().uniforms.depthBuffer.value;
      }
    }, {
      key: "setDepthTexture",
      value: function setDepthTexture(depthTexture) {
        var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var material = this.getFullscreenMaterial();
        material.uniforms.depthBuffer.value = depthTexture;
        material.depthPacking = depthPacking;
        material.needsUpdate = true;
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = this.effects[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var effect = _step11.value;
            effect.setDepthTexture(depthTexture, depthPacking);
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
              _iterator11["return"]();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }
      }
    }, {
      key: "render",
      value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        var material = this.getFullscreenMaterial();
        var time = material.uniforms.time.value + deltaTime;
        var _iteratorNormalCompletion12 = true;
        var _didIteratorError12 = false;
        var _iteratorError12 = undefined;

        try {
          for (var _iterator12 = this.effects[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
            var effect = _step12.value;
            effect.update(renderer, inputBuffer, deltaTime);
          }
        } catch (err) {
          _didIteratorError12 = true;
          _iteratorError12 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
              _iterator12["return"]();
            }
          } finally {
            if (_didIteratorError12) {
              throw _iteratorError12;
            }
          }
        }

        if (!this.skipRendering || this.renderToScreen) {
          material.uniforms.inputBuffer.value = inputBuffer.texture;
          material.uniforms.time.value = time <= this.maxTime ? time : this.minTime;
          renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
          renderer.render(this.scene, this.camera);
        }
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.getFullscreenMaterial().setSize(width, height);
        var _iteratorNormalCompletion13 = true;
        var _didIteratorError13 = false;
        var _iteratorError13 = undefined;

        try {
          for (var _iterator13 = this.effects[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
            var effect = _step13.value;
            effect.setSize(width, height);
          }
        } catch (err) {
          _didIteratorError13 = true;
          _iteratorError13 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
              _iterator13["return"]();
            }
          } finally {
            if (_didIteratorError13) {
              throw _iteratorError13;
            }
          }
        }
      }
    }, {
      key: "initialize",
      value: function initialize(renderer, alpha, frameBufferType) {
        var _iteratorNormalCompletion14 = true;
        var _didIteratorError14 = false;
        var _iteratorError14 = undefined;

        try {
          for (var _iterator14 = this.effects[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
            var effect = _step14.value;
            effect.initialize(renderer, alpha, frameBufferType);
          }
        } catch (err) {
          _didIteratorError14 = true;
          _iteratorError14 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
              _iterator14["return"]();
            }
          } finally {
            if (_didIteratorError14) {
              throw _iteratorError14;
            }
          }
        }

        this.updateMaterial();
        var capabilities = renderer.capabilities;
        var max = Math.min(capabilities.maxFragmentUniforms, capabilities.maxVertexUniforms);

        if (this.uniforms > max) {
          console.warn("The current rendering context doesn't support more than " + max + " uniforms, but " + this.uniforms + " were defined");
        }

        max = capabilities.maxVaryings;

        if (this.varyings > max) {
          console.warn("The current rendering context doesn't support more than " + max + " varyings, but " + this.varyings + " were defined");
        }
      }
    }, {
      key: "dispose",
      value: function dispose() {
        _get(_getPrototypeOf(EffectPass.prototype), "dispose", this).call(this);

        var _iteratorNormalCompletion15 = true;
        var _didIteratorError15 = false;
        var _iteratorError15 = undefined;

        try {
          for (var _iterator15 = this.effects[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
            var effect = _step15.value;
            effect.dispose();
          }
        } catch (err) {
          _didIteratorError15 = true;
          _iteratorError15 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
              _iterator15["return"]();
            }
          } finally {
            if (_didIteratorError15) {
              throw _iteratorError15;
            }
          }
        }
      }
    }, {
      key: "encodeOutput",
      get: function get() {
        return this.getFullscreenMaterial().defines.ENCODE_OUTPUT !== undefined;
      },
      set: function set(value) {
        if (this.encodeOutput !== value) {
          var material = this.getFullscreenMaterial();
          material.needsUpdate = true;

          if (value) {
            material.defines.ENCODE_OUTPUT = "1";
          } else {
            delete material.defines.ENCODE_OUTPUT;
          }
        }
      }
    }, {
      key: "dithering",
      get: function get() {
        return this.getFullscreenMaterial().dithering;
      },
      set: function set(value) {
        var material = this.getFullscreenMaterial();

        if (material.dithering !== value) {
          material.dithering = value;
          material.needsUpdate = true;
        }
      }
    }]);

    return EffectPass;
  }(Pass);

  var MaskPass = function (_Pass7) {
    _inherits(MaskPass, _Pass7);

    function MaskPass(scene, camera) {
      var _this24;

      _classCallCheck(this, MaskPass);

      _this24 = _possibleConstructorReturn(this, _getPrototypeOf(MaskPass).call(this, "MaskPass", scene, camera));
      _this24.needsSwap = false;
      _this24.clearPass = new ClearPass(false, false, true);
      _this24.inverse = false;
      return _this24;
    }

    _createClass(MaskPass, [{
      key: "render",
      value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        var context = renderer.getContext();
        var buffers = renderer.state.buffers;
        var scene = this.scene;
        var camera = this.camera;
        var clearPass = this.clearPass;
        var writeValue = this.inverse ? 0 : 1;
        var clearValue = 1 - writeValue;
        buffers.color.setMask(false);
        buffers.depth.setMask(false);
        buffers.color.setLocked(true);
        buffers.depth.setLocked(true);
        buffers.stencil.setTest(true);
        buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
        buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
        buffers.stencil.setClear(clearValue);
        buffers.stencil.setLocked(true);

        if (this.clear) {
          if (this.renderToScreen) {
            clearPass.render(renderer, null);
          } else {
            clearPass.render(renderer, inputBuffer);
            clearPass.render(renderer, outputBuffer);
          }
        }

        if (this.renderToScreen) {
          renderer.setRenderTarget(null);
          renderer.render(scene, camera);
        } else {
          renderer.setRenderTarget(inputBuffer);
          renderer.render(scene, camera);
          renderer.setRenderTarget(outputBuffer);
          renderer.render(scene, camera);
        }

        buffers.color.setLocked(false);
        buffers.depth.setLocked(false);
        buffers.stencil.setLocked(false);
        buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff);
        buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
        buffers.stencil.setLocked(true);
      }
    }, {
      key: "clear",
      get: function get() {
        return this.clearPass.enabled;
      },
      set: function set(value) {
        this.clearPass.enabled = value;
      }
    }]);

    return MaskPass;
  }(Pass);

  var NormalPass = function (_Pass8) {
    _inherits(NormalPass, _Pass8);

    function NormalPass(scene, camera) {
      var _this25;

      var _ref7 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref7$resolutionScale = _ref7.resolutionScale,
          resolutionScale = _ref7$resolutionScale === void 0 ? 1.0 : _ref7$resolutionScale,
          _ref7$width = _ref7.width,
          width = _ref7$width === void 0 ? Resizer.AUTO_SIZE : _ref7$width,
          _ref7$height = _ref7.height,
          height = _ref7$height === void 0 ? Resizer.AUTO_SIZE : _ref7$height,
          renderTarget = _ref7.renderTarget;

      _classCallCheck(this, NormalPass);

      _this25 = _possibleConstructorReturn(this, _getPrototypeOf(NormalPass).call(this, "NormalPass"));
      _this25.needsSwap = false;
      _this25.renderPass = new RenderPass(scene, camera, new MeshNormalMaterial({
        morphTargets: true,
        morphNormals: true,
        skinning: true
      }));

      var clearPass = _this25.renderPass.getClearPass();

      clearPass.overrideClearColor = new Color(0x7777ff);
      clearPass.overrideClearAlpha = 1.0;
      _this25.renderTarget = renderTarget;

      if (_this25.renderTarget === undefined) {
        _this25.renderTarget = new WebGLRenderTarget(1, 1, {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          format: RGBFormat,
          stencilBuffer: false
        });
        _this25.renderTarget.texture.name = "NormalPass.Target";
      }

      _this25.resolution = new Resizer(_assertThisInitialized(_this25), width, height);
      _this25.resolution.scale = resolutionScale;
      return _this25;
    }

    _createClass(NormalPass, [{
      key: "getResolutionScale",
      value: function getResolutionScale() {
        return this.resolutionScale;
      }
    }, {
      key: "setResolutionScale",
      value: function setResolutionScale(scale) {
        this.resolutionScale = scale;
        this.setSize(this.originalSize.x, this.originalSize.y);
      }
    }, {
      key: "render",
      value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        var renderTarget = this.renderToScreen ? null : this.renderTarget;
        this.renderPass.render(renderer, renderTarget, renderTarget);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        var resolution = this.resolution;
        resolution.base.set(width, height);
        width = resolution.width;
        height = resolution.height;
        this.renderTarget.setSize(width, height);
      }
    }]);

    return NormalPass;
  }(Pass);

  var SavePass = function (_Pass9) {
    _inherits(SavePass, _Pass9);

    function SavePass(renderTarget) {
      var _this26;

      var resize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      _classCallCheck(this, SavePass);

      _this26 = _possibleConstructorReturn(this, _getPrototypeOf(SavePass).call(this, "SavePass"));

      _this26.setFullscreenMaterial(new CopyMaterial());

      _this26.needsSwap = false;
      _this26.renderTarget = renderTarget;

      if (renderTarget === undefined) {
        _this26.renderTarget = new WebGLRenderTarget(1, 1, {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          stencilBuffer: false,
          depthBuffer: false
        });
        _this26.renderTarget.texture.name = "SavePass.Target";
      }

      _this26.resize = resize;
      return _this26;
    }

    _createClass(SavePass, [{
      key: "render",
      value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        this.getFullscreenMaterial().uniforms.inputBuffer.value = inputBuffer.texture;
        renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
        renderer.render(this.scene, this.camera);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        if (this.resize) {
          width = Math.max(1, width);
          height = Math.max(1, height);
          this.renderTarget.setSize(width, height);
        }
      }
    }, {
      key: "initialize",
      value: function initialize(renderer, alpha, frameBufferType) {
        if (!alpha) {
          this.renderTarget.texture.format = RGBFormat;
        }

        if (frameBufferType !== undefined) {
          this.renderTarget.texture.type = frameBufferType;
        }
      }
    }]);

    return SavePass;
  }(Pass);

  var ShaderPass = function (_Pass10) {
    _inherits(ShaderPass, _Pass10);

    function ShaderPass(material) {
      var _this27;

      var input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "inputBuffer";

      _classCallCheck(this, ShaderPass);

      _this27 = _possibleConstructorReturn(this, _getPrototypeOf(ShaderPass).call(this, "ShaderPass"));

      _this27.setFullscreenMaterial(material);

      _this27.uniform = null;

      _this27.setInput(input);

      return _this27;
    }

    _createClass(ShaderPass, [{
      key: "setInput",
      value: function setInput(input) {
        var material = this.getFullscreenMaterial();
        this.uniform = null;

        if (material !== null) {
          var uniforms = material.uniforms;

          if (uniforms !== undefined && uniforms[input] !== undefined) {
            this.uniform = uniforms[input];
          }
        }
      }
    }, {
      key: "render",
      value: function render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
        if (this.uniform !== null && inputBuffer !== null) {
          this.uniform.value = inputBuffer.texture;
        }

        renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
        renderer.render(this.scene, this.camera);
      }
    }]);

    return ShaderPass;
  }(Pass);

  var EffectComposer = function () {
    function EffectComposer() {
      var renderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref8$depthBuffer = _ref8.depthBuffer,
          depthBuffer = _ref8$depthBuffer === void 0 ? true : _ref8$depthBuffer,
          _ref8$stencilBuffer = _ref8.stencilBuffer,
          stencilBuffer = _ref8$stencilBuffer === void 0 ? false : _ref8$stencilBuffer,
          frameBufferType = _ref8.frameBufferType;

      _classCallCheck(this, EffectComposer);

      this.renderer = renderer;
      this.inputBuffer = null;
      this.outputBuffer = null;

      if (this.renderer !== null) {
        this.renderer.autoClear = false;
        this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType);
        this.outputBuffer = this.inputBuffer.clone();
      }

      this.copyPass = new ShaderPass(new CopyMaterial());
      this.depthTexture = null;
      this.passes = [];
      this.autoRenderToScreen = true;
    }

    _createClass(EffectComposer, [{
      key: "getRenderer",
      value: function getRenderer() {
        return this.renderer;
      }
    }, {
      key: "replaceRenderer",
      value: function replaceRenderer(renderer) {
        var updateDOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var oldRenderer = this.renderer;

        if (oldRenderer !== null && oldRenderer !== renderer) {
          var oldSize = oldRenderer.getSize(new Vector2());
          var newSize = renderer.getSize(new Vector2());
          var parent = oldRenderer.domElement.parentNode;
          this.renderer = renderer;
          this.renderer.autoClear = false;

          if (!oldSize.equals(newSize)) {
            this.setSize();
          }

          if (updateDOM && parent !== null) {
            parent.removeChild(oldRenderer.domElement);
            parent.appendChild(renderer.domElement);
          }
        }

        return oldRenderer;
      }
    }, {
      key: "createDepthTexture",
      value: function createDepthTexture() {
        var depthTexture = this.depthTexture = new DepthTexture();

        if (this.inputBuffer.stencilBuffer) {
          depthTexture.format = DepthStencilFormat;
          depthTexture.type = UnsignedInt248Type;
        }

        return depthTexture;
      }
    }, {
      key: "createBuffer",
      value: function createBuffer(depthBuffer, stencilBuffer, type) {
        var drawingBufferSize = this.renderer.getDrawingBufferSize(new Vector2());
        var alpha = this.renderer.getContext().getContextAttributes().alpha;
        var renderTarget = new WebGLRenderTarget(drawingBufferSize.width, drawingBufferSize.height, {
          format: alpha ? RGBAFormat : RGBFormat,
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          stencilBuffer: stencilBuffer,
          depthBuffer: depthBuffer,
          type: type
        });
        renderTarget.texture.name = "EffectComposer.Buffer";
        renderTarget.texture.generateMipmaps = false;
        return renderTarget;
      }
    }, {
      key: "addPass",
      value: function addPass(pass, index) {
        var passes = this.passes;
        var renderer = this.renderer;
        var alpha = renderer.getContext().getContextAttributes().alpha;
        var frameBufferType = this.inputBuffer.texture.type;
        var drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());

        if (this.autoRenderToScreen) {
          if (passes.length > 0) {
            passes[passes.length - 1].renderToScreen = false;
          }

          if (pass.renderToScreen) {
            this.autoRenderToScreen = false;
          } else {
            pass.renderToScreen = true;
          }
        }

        pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
        pass.initialize(renderer, alpha, frameBufferType);

        if (index !== undefined) {
          passes.splice(index, 0, pass);
        } else {
          passes.push(pass);
        }

        if (pass.needsDepthTexture || this.depthTexture !== null) {
          if (this.depthTexture === null) {
            var depthTexture = this.createDepthTexture();
            var _iteratorNormalCompletion16 = true;
            var _didIteratorError16 = false;
            var _iteratorError16 = undefined;

            try {
              for (var _iterator16 = passes[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                pass = _step16.value;
                pass.setDepthTexture(depthTexture);
              }
            } catch (err) {
              _didIteratorError16 = true;
              _iteratorError16 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
                  _iterator16["return"]();
                }
              } finally {
                if (_didIteratorError16) {
                  throw _iteratorError16;
                }
              }
            }
          } else {
            pass.setDepthTexture(this.depthTexture);
          }
        }
      }
    }, {
      key: "removePass",
      value: function removePass(pass) {
        var passes = this.passes;
        var index = passes.indexOf(pass);
        var removed = passes.splice(index, 1).length > 0;

        if (removed) {
          if (this.depthTexture !== null) {
            var reducer = function reducer(a, b) {
              return a || b.needsDepthTexture;
            };

            var depthTextureRequired = passes.reduce(reducer, false);

            if (!depthTextureRequired) {
              this.depthTexture.dispose();
              this.depthTexture = null;
              this.inputBuffer.depthTexture = null;
              this.outputBuffer.depthTexture = null;
              pass.setDepthTexture(null);
              var _iteratorNormalCompletion17 = true;
              var _didIteratorError17 = false;
              var _iteratorError17 = undefined;

              try {
                for (var _iterator17 = passes[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                  pass = _step17.value;
                  pass.setDepthTexture(null);
                }
              } catch (err) {
                _didIteratorError17 = true;
                _iteratorError17 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
                    _iterator17["return"]();
                  }
                } finally {
                  if (_didIteratorError17) {
                    throw _iteratorError17;
                  }
                }
              }
            }
          }

          if (this.autoRenderToScreen && passes.length > 0) {
            if (index === passes.length) {
              passes[passes.length - 1].renderToScreen = true;
            }
          }
        }
      }
    }, {
      key: "render",
      value: function render(deltaTime) {
        var renderer = this.renderer;
        var copyPass = this.copyPass;
        var inputBuffer = this.inputBuffer;
        var outputBuffer = this.outputBuffer;
        var stencilTest = false;
        var context, stencil, buffer;
        var _iteratorNormalCompletion18 = true;
        var _didIteratorError18 = false;
        var _iteratorError18 = undefined;

        try {
          for (var _iterator18 = this.passes[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
            var pass = _step18.value;

            if (pass.enabled) {
              pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);

              if (pass.needsSwap) {
                if (stencilTest) {
                  copyPass.renderToScreen = pass.renderToScreen;
                  context = renderer.getContext();
                  stencil = renderer.state.buffers.stencil;
                  stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff);
                  copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
                  stencil.setFunc(context.EQUAL, 1, 0xffffffff);
                }

                buffer = inputBuffer;
                inputBuffer = outputBuffer;
                outputBuffer = buffer;
              }

              if (pass instanceof MaskPass) {
                stencilTest = true;
              } else if (pass instanceof ClearMaskPass) {
                stencilTest = false;
              }
            }
          }
        } catch (err) {
          _didIteratorError18 = true;
          _iteratorError18 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
              _iterator18["return"]();
            }
          } finally {
            if (_didIteratorError18) {
              throw _iteratorError18;
            }
          }
        }
      }
    }, {
      key: "setSize",
      value: function setSize(width, height, updateStyle) {
        var renderer = this.renderer;

        if (width === undefined || height === undefined) {
          var size = renderer.getSize(new Vector2());
          width = size.width;
          height = size.height;
        }

        renderer.setSize(width, height, updateStyle);
        var drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
        this.inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
        this.outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
        var _iteratorNormalCompletion19 = true;
        var _didIteratorError19 = false;
        var _iteratorError19 = undefined;

        try {
          for (var _iterator19 = this.passes[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
            var pass = _step19.value;
            pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
          }
        } catch (err) {
          _didIteratorError19 = true;
          _iteratorError19 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
              _iterator19["return"]();
            }
          } finally {
            if (_didIteratorError19) {
              throw _iteratorError19;
            }
          }
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        var renderTarget = this.inputBuffer.clone();
        this.dispose();
        this.inputBuffer = renderTarget;
        this.outputBuffer = renderTarget.clone();
        this.depthTexture = null;
        this.copyPass = new ShaderPass(new CopyMaterial());
        this.autoRenderToScreen = true;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        var _iteratorNormalCompletion20 = true;
        var _didIteratorError20 = false;
        var _iteratorError20 = undefined;

        try {
          for (var _iterator20 = this.passes[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
            var pass = _step20.value;
            pass.dispose();
          }
        } catch (err) {
          _didIteratorError20 = true;
          _iteratorError20 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion20 && _iterator20["return"] != null) {
              _iterator20["return"]();
            }
          } finally {
            if (_didIteratorError20) {
              throw _iteratorError20;
            }
          }
        }

        this.passes = [];

        if (this.inputBuffer !== null) {
          this.inputBuffer.dispose();
          this.inputBuffer = null;
        }

        if (this.outputBuffer !== null) {
          this.outputBuffer.dispose();
          this.outputBuffer = null;
        }

        if (this.depthTexture !== null) {
          this.depthTexture.dispose();
        }

        this.copyPass.dispose();
      }
    }]);

    return EffectComposer;
  }();

  var Selection = function (_Set) {
    _inherits(Selection, _Set);

    function Selection(iterable) {
      var _this28;

      var layer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

      _classCallCheck(this, Selection);

      _this28 = _possibleConstructorReturn(this, _getPrototypeOf(Selection).call(this));
      _this28.currentLayer = layer;

      if (iterable !== undefined) {
        _this28.set(iterable);
      }

      return _this28;
    }

    _createClass(Selection, [{
      key: "clear",
      value: function clear() {
        var layer = this.layer;
        var _iteratorNormalCompletion21 = true;
        var _didIteratorError21 = false;
        var _iteratorError21 = undefined;

        try {
          for (var _iterator21 = this[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
            var object = _step21.value;
            object.layers.disable(layer);
          }
        } catch (err) {
          _didIteratorError21 = true;
          _iteratorError21 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion21 && _iterator21["return"] != null) {
              _iterator21["return"]();
            }
          } finally {
            if (_didIteratorError21) {
              throw _iteratorError21;
            }
          }
        }

        return _get(_getPrototypeOf(Selection.prototype), "clear", this).call(this);
      }
    }, {
      key: "set",
      value: function set(objects) {
        this.clear();
        var _iteratorNormalCompletion22 = true;
        var _didIteratorError22 = false;
        var _iteratorError22 = undefined;

        try {
          for (var _iterator22 = objects[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
            var object = _step22.value;
            this.add(object);
          }
        } catch (err) {
          _didIteratorError22 = true;
          _iteratorError22 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion22 && _iterator22["return"] != null) {
              _iterator22["return"]();
            }
          } finally {
            if (_didIteratorError22) {
              throw _iteratorError22;
            }
          }
        }

        return this;
      }
    }, {
      key: "indexOf",
      value: function indexOf(object) {
        return this.has(object) ? 0 : -1;
      }
    }, {
      key: "add",
      value: function add(object) {
        object.layers.enable(this.layer);

        _get(_getPrototypeOf(Selection.prototype), "add", this).call(this, object);

        return this;
      }
    }, {
      key: "delete",
      value: function _delete(object) {
        if (this.has(object)) {
          object.layers.disable(this.layer);
        }

        return _get(_getPrototypeOf(Selection.prototype), "delete", this).call(this, object);
      }
    }, {
      key: "setVisible",
      value: function setVisible(visible) {
        var _iteratorNormalCompletion23 = true;
        var _didIteratorError23 = false;
        var _iteratorError23 = undefined;

        try {
          for (var _iterator23 = this[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
            var object = _step23.value;

            if (visible) {
              object.layers.enable(0);
            } else {
              object.layers.disable(0);
            }
          }
        } catch (err) {
          _didIteratorError23 = true;
          _iteratorError23 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion23 && _iterator23["return"] != null) {
              _iterator23["return"]();
            }
          } finally {
            if (_didIteratorError23) {
              throw _iteratorError23;
            }
          }
        }

        return this;
      }
    }, {
      key: "layer",
      get: function get() {
        return this.currentLayer;
      },
      set: function set(value) {
        var currentLayer = this.currentLayer;
        var _iteratorNormalCompletion24 = true;
        var _didIteratorError24 = false;
        var _iteratorError24 = undefined;

        try {
          for (var _iterator24 = this[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
            var object = _step24.value;
            object.layers.disable(currentLayer);
            object.layers.enable(value);
          }
        } catch (err) {
          _didIteratorError24 = true;
          _iteratorError24 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion24 && _iterator24["return"] != null) {
              _iterator24["return"]();
            }
          } finally {
            if (_didIteratorError24) {
              throw _iteratorError24;
            }
          }
        }

        this.currentLayer = value;
      }
    }]);

    return Selection;
  }(_wrapNativeSuper(Set));

  var fragmentShader$c = "uniform sampler2D texture;\n#ifdef ASPECT_CORRECTION\nvarying vec2 vUv2;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#ifdef ASPECT_CORRECTION\noutputColor=texture2D(texture,vUv2);\n#else\noutputColor=texture2D(texture,uv);\n#endif\n}";

  var BloomEffect = function (_Effect) {
    _inherits(BloomEffect, _Effect);

    function BloomEffect() {
      var _this29;

      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref9$blendFunction = _ref9.blendFunction,
          blendFunction = _ref9$blendFunction === void 0 ? BlendFunction.SCREEN : _ref9$blendFunction,
          _ref9$luminanceThresh = _ref9.luminanceThreshold,
          luminanceThreshold = _ref9$luminanceThresh === void 0 ? 0.9 : _ref9$luminanceThresh,
          _ref9$luminanceSmooth = _ref9.luminanceSmoothing,
          luminanceSmoothing = _ref9$luminanceSmooth === void 0 ? 0.025 : _ref9$luminanceSmooth,
          _ref9$resolutionScale = _ref9.resolutionScale,
          resolutionScale = _ref9$resolutionScale === void 0 ? 0.5 : _ref9$resolutionScale,
          _ref9$width = _ref9.width,
          width = _ref9$width === void 0 ? Resizer.AUTO_SIZE : _ref9$width,
          _ref9$height = _ref9.height,
          height = _ref9$height === void 0 ? Resizer.AUTO_SIZE : _ref9$height,
          _ref9$kernelSize = _ref9.kernelSize,
          kernelSize = _ref9$kernelSize === void 0 ? KernelSize.LARGE : _ref9$kernelSize;

      _classCallCheck(this, BloomEffect);

      _this29 = _possibleConstructorReturn(this, _getPrototypeOf(BloomEffect).call(this, "BloomEffect", fragmentShader$c, {
        blendFunction: blendFunction,
        uniforms: new Map([["texture", new Uniform(null)]])
      }));
      _this29.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      });
      _this29.renderTarget.texture.name = "Bloom.Target";
      _this29.renderTarget.texture.generateMipmaps = false;
      _this29.uniforms.get("texture").value = _this29.renderTarget.texture;
      _this29.blurPass = new BlurPass({
        resolutionScale: resolutionScale,
        width: width,
        height: height,
        kernelSize: kernelSize
      });
      _this29.blurPass.resolution.resizable = _assertThisInitialized(_this29);
      _this29.luminancePass = new ShaderPass(new LuminanceMaterial(true));
      _this29.luminanceMaterial.threshold = luminanceThreshold;
      _this29.luminanceMaterial.smoothing = luminanceSmoothing;
      return _this29;
    }

    _createClass(BloomEffect, [{
      key: "getResolutionScale",
      value: function getResolutionScale() {
        return this.resolution.scale;
      }
    }, {
      key: "setResolutionScale",
      value: function setResolutionScale(scale) {
        this.resolution.scale = scale;
        this.setSize(this.resolution.base.x, this.resolution.base.y);
      }
    }, {
      key: "update",
      value: function update(renderer, inputBuffer, deltaTime) {
        var renderTarget = this.renderTarget;

        if (this.luminancePass.enabled) {
          this.luminancePass.render(renderer, inputBuffer, renderTarget);
          this.blurPass.render(renderer, renderTarget, renderTarget);
        } else {
          this.blurPass.render(renderer, inputBuffer, renderTarget);
        }
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.blurPass.setSize(width, height);
        this.renderTarget.setSize(this.resolution.width, this.resolution.height);
      }
    }, {
      key: "initialize",
      value: function initialize(renderer, alpha, frameBufferType) {
        this.blurPass.initialize(renderer, alpha, frameBufferType);

        if (!alpha) {
          this.renderTarget.texture.format = RGBFormat;
        }

        if (frameBufferType !== undefined) {
          this.renderTarget.texture.type = frameBufferType;
        }
      }
    }, {
      key: "texture",
      get: function get() {
        return this.renderTarget.texture;
      }
    }, {
      key: "luminanceMaterial",
      get: function get() {
        return this.luminancePass.getFullscreenMaterial();
      }
    }, {
      key: "resolution",
      get: function get() {
        return this.blurPass.resolution;
      }
    }, {
      key: "width",
      get: function get() {
        return this.resolution.width;
      },
      set: function set(value) {
        this.resolution.width = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this.resolution.height;
      },
      set: function set(value) {
        this.resolution.height = value;
      }
    }, {
      key: "dithering",
      get: function get() {
        return this.blurPass.dithering;
      },
      set: function set(value) {
        this.blurPass.dithering = value;
      }
    }, {
      key: "kernelSize",
      get: function get() {
        return this.blurPass.kernelSize;
      },
      set: function set(value) {
        this.blurPass.kernelSize = value;
      }
    }, {
      key: "distinction",
      get: function get() {
        console.warn(this.name, "The distinction field has been removed, use luminanceMaterial.threshold and luminanceMaterial.smoothing instead.");
        return 1.0;
      },
      set: function set(value) {
        console.warn(this.name, "The distinction field has been removed, use luminanceMaterial.threshold and luminanceMaterial.smoothing instead.");
      }
    }]);

    return BloomEffect;
  }(Effect);

  var fragmentShader$d = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(min(color+vec3(0.5),1.0),inputColor.a);}";

  var BrightnessContrastEffect = function (_Effect2) {
    _inherits(BrightnessContrastEffect, _Effect2);

    function BrightnessContrastEffect() {
      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref10$blendFunction = _ref10.blendFunction,
          blendFunction = _ref10$blendFunction === void 0 ? BlendFunction.NORMAL : _ref10$blendFunction,
          _ref10$brightness = _ref10.brightness,
          brightness = _ref10$brightness === void 0 ? 0.0 : _ref10$brightness,
          _ref10$contrast = _ref10.contrast,
          contrast = _ref10$contrast === void 0 ? 0.0 : _ref10$contrast;

      _classCallCheck(this, BrightnessContrastEffect);

      return _possibleConstructorReturn(this, _getPrototypeOf(BrightnessContrastEffect).call(this, "BrightnessContrastEffect", fragmentShader$d, {
        blendFunction: blendFunction,
        uniforms: new Map([["brightness", new Uniform(brightness)], ["contrast", new Uniform(contrast)]])
      }));
    }

    return BrightnessContrastEffect;
  }(Effect);

  var fragmentShader$e = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float sum=inputColor.r+inputColor.g+inputColor.b;outputColor=vec4(vec3(sum/3.0),inputColor.a);}";

  var ColorAverageEffect = function (_Effect3) {
    _inherits(ColorAverageEffect, _Effect3);

    function ColorAverageEffect() {
      var blendFunction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : BlendFunction.NORMAL;

      _classCallCheck(this, ColorAverageEffect);

      return _possibleConstructorReturn(this, _getPrototypeOf(ColorAverageEffect).call(this, "ColorAverageEffect", fragmentShader$e, {
        blendFunction: blendFunction
      }));
    }

    return ColorAverageEffect;
  }(Effect);

  var fragmentShader$f = "uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}";

  var ColorDepthEffect = function (_Effect4) {
    _inherits(ColorDepthEffect, _Effect4);

    function ColorDepthEffect() {
      var _this30;

      var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref11$blendFunction = _ref11.blendFunction,
          blendFunction = _ref11$blendFunction === void 0 ? BlendFunction.NORMAL : _ref11$blendFunction,
          _ref11$bits = _ref11.bits,
          bits = _ref11$bits === void 0 ? 16 : _ref11$bits;

      _classCallCheck(this, ColorDepthEffect);

      _this30 = _possibleConstructorReturn(this, _getPrototypeOf(ColorDepthEffect).call(this, "ColorDepthEffect", fragmentShader$f, {
        blendFunction: blendFunction,
        uniforms: new Map([["factor", new Uniform(1.0)]])
      }));
      _this30.bits = 0;

      _this30.setBitDepth(bits);

      return _this30;
    }

    _createClass(ColorDepthEffect, [{
      key: "getBitDepth",
      value: function getBitDepth() {
        return this.bits;
      }
    }, {
      key: "setBitDepth",
      value: function setBitDepth(bits) {
        this.bits = bits;
        this.uniforms.get("factor").value = Math.pow(2.0, bits / 3.0);
      }
    }]);

    return ColorDepthEffect;
  }(Effect);

  var fragmentShader$g = "varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 color=inputColor;\n#ifdef ALPHA\nvec2 ra=texture2D(inputBuffer,vUvR).ra;vec2 ba=texture2D(inputBuffer,vUvB).ba;color.r=ra.x;color.b=ba.x;color.a=max(max(ra.y,ba.y),inputColor.a);\n#else\ncolor.r=texture2D(inputBuffer,vUvR).r;color.b=texture2D(inputBuffer,vUvB).b;\n#endif\noutputColor=color;}";
  var vertexShader$6 = "uniform vec2 offset;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vUvR=uv+offset;vUvB=uv-offset;}";

  var ChromaticAberrationEffect = function (_Effect5) {
    _inherits(ChromaticAberrationEffect, _Effect5);

    function ChromaticAberrationEffect() {
      var _ref12 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref12$blendFunction = _ref12.blendFunction,
          blendFunction = _ref12$blendFunction === void 0 ? BlendFunction.NORMAL : _ref12$blendFunction,
          _ref12$offset = _ref12.offset,
          offset = _ref12$offset === void 0 ? new Vector2(0.001, 0.0005) : _ref12$offset;

      _classCallCheck(this, ChromaticAberrationEffect);

      return _possibleConstructorReturn(this, _getPrototypeOf(ChromaticAberrationEffect).call(this, "ChromaticAberrationEffect", fragmentShader$g, {
        vertexShader: vertexShader$6,
        blendFunction: blendFunction,
        attributes: EffectAttribute.CONVOLUTION,
        uniforms: new Map([["offset", new Uniform(offset)]])
      }));
    }

    _createClass(ChromaticAberrationEffect, [{
      key: "initialize",
      value: function initialize(renderer, alpha, frameBufferType) {
        if (alpha) {
          this.defines.set("ALPHA", "1");
        } else {
          this.defines["delete"]("ALPHA");
        }
      }
    }, {
      key: "offset",
      get: function get() {
        return this.uniforms.get("offset").value;
      },
      set: function set(value) {
        this.uniforms.get("offset").value = value;
      }
    }]);

    return ChromaticAberrationEffect;
  }(Effect);

  var fragmentShader$h = "void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\n#ifdef INVERTED\nvec3 color=vec3(1.0-depth);\n#else\nvec3 color=vec3(depth);\n#endif\noutputColor=vec4(color,inputColor.a);}";

  var DepthEffect = function (_Effect6) {
    _inherits(DepthEffect, _Effect6);

    function DepthEffect() {
      var _this31;

      var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref13$blendFunction = _ref13.blendFunction,
          blendFunction = _ref13$blendFunction === void 0 ? BlendFunction.NORMAL : _ref13$blendFunction,
          _ref13$inverted = _ref13.inverted,
          inverted = _ref13$inverted === void 0 ? false : _ref13$inverted;

      _classCallCheck(this, DepthEffect);

      _this31 = _possibleConstructorReturn(this, _getPrototypeOf(DepthEffect).call(this, "DepthEffect", fragmentShader$h, {
        blendFunction: blendFunction,
        attributes: EffectAttribute.DEPTH
      }));
      _this31.inverted = inverted;
      return _this31;
    }

    _createClass(DepthEffect, [{
      key: "inverted",
      get: function get() {
        return this.defines.has("INVERTED");
      },
      set: function set(value) {
        value ? this.defines.set("INVERTED", "1") : this.defines["delete"]("INVERTED");
      }
    }]);

    return DepthEffect;
  }(Effect);

  var fragmentShader$i = "uniform sampler2D nearBuffer;uniform sampler2D farBuffer;uniform sampler2D cocBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearBuffer,uv);vec4 colorFar=texture2D(farBuffer,uv);float CoCNear=texture2D(cocBuffer,uv).r;float blendNear=min(scale*CoCNear,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,blendNear);outputColor=result;}";

  var DepthOfFieldEffect = function (_Effect7) {
    _inherits(DepthOfFieldEffect, _Effect7);

    function DepthOfFieldEffect(camera) {
      var _this32;

      var _ref14 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref14$blendFunction = _ref14.blendFunction,
          blendFunction = _ref14$blendFunction === void 0 ? BlendFunction.NORMAL : _ref14$blendFunction,
          _ref14$focusDistance = _ref14.focusDistance,
          focusDistance = _ref14$focusDistance === void 0 ? 0.0 : _ref14$focusDistance,
          _ref14$focalLength = _ref14.focalLength,
          focalLength = _ref14$focalLength === void 0 ? 0.1 : _ref14$focalLength,
          _ref14$bokehScale = _ref14.bokehScale,
          bokehScale = _ref14$bokehScale === void 0 ? 1.0 : _ref14$bokehScale,
          _ref14$width = _ref14.width,
          width = _ref14$width === void 0 ? Resizer.AUTO_SIZE : _ref14$width,
          _ref14$height = _ref14.height,
          height = _ref14$height === void 0 ? Resizer.AUTO_SIZE : _ref14$height;

      _classCallCheck(this, DepthOfFieldEffect);

      _this32 = _possibleConstructorReturn(this, _getPrototypeOf(DepthOfFieldEffect).call(this, "DepthOfFieldEffect", fragmentShader$i, {
        blendFunction: blendFunction,
        attributes: EffectAttribute.DEPTH,
        uniforms: new Map([["nearBuffer", new Uniform(null)], ["farBuffer", new Uniform(null)], ["cocBuffer", new Uniform(null)], ["scale", new Uniform(1.0)]])
      }));
      _this32.camera = camera;
      _this32.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      });
      _this32.renderTarget.texture.name = "DoF.Intermediate";
      _this32.renderTarget.texture.generateMipmaps = false;
      _this32.renderTargetMasked = _this32.renderTarget.clone();
      _this32.renderTargetMasked.texture.name = "DoF.Masked.Far";
      _this32.renderTargetNear = _this32.renderTarget.clone();
      _this32.renderTargetNear.texture.name = "DoF.Bokeh.Near";
      _this32.uniforms.get("nearBuffer").value = _this32.renderTargetNear.texture;
      _this32.renderTargetFar = _this32.renderTarget.clone();
      _this32.renderTargetFar.texture.name = "DoF.Bokeh.Far";
      _this32.uniforms.get("farBuffer").value = _this32.renderTargetFar.texture;
      _this32.renderTargetCoC = _this32.renderTarget.clone();
      _this32.renderTargetCoC.texture.format = RGBFormat;
      _this32.renderTargetCoC.texture.name = "DoF.CoC";
      _this32.renderTargetCoCNear = _this32.renderTargetCoC.clone();
      _this32.renderTargetCoCNear.texture.name = "DoF.CoC.Near";
      _this32.uniforms.get("cocBuffer").value = _this32.renderTargetCoCNear.texture;
      _this32.cocPass = new ShaderPass(new CircleOfConfusionMaterial(camera));
      var cocMaterial = _this32.circleOfConfusionMaterial;
      cocMaterial.uniforms.focusDistance.value = focusDistance;
      cocMaterial.uniforms.focalLength.value = focalLength;
      _this32.blurPass = new BlurPass({
        width: width,
        height: height,
        kernelSize: KernelSize.MEDIUM
      });
      _this32.blurPass.resolution.resizable = _assertThisInitialized(_this32);
      _this32.maskPass = new ShaderPass(new MaskMaterial(_this32.renderTargetCoC.texture));

      var maskMaterial = _this32.maskPass.getFullscreenMaterial();

      maskMaterial.colorChannel = ColorChannel.GREEN;
      maskMaterial.maskFunction = MaskFunction.MULTIPLY;
      _this32.bokehBasePass = new ShaderPass(new BokehMaterial(false));
      _this32.bokehFillPass = new ShaderPass(new BokehMaterial(true));
      _this32.bokehScale = bokehScale;
      _this32.target = null;
      return _this32;
    }

    _createClass(DepthOfFieldEffect, [{
      key: "calculateFocusDistance",
      value: function calculateFocusDistance(target) {
        var camera = this.camera;
        var viewDistance = camera.far - camera.near;
        var distance = camera.position.distanceTo(target);
        return Math.min(Math.max(distance / viewDistance, 0.0), 1.0);
      }
    }, {
      key: "setDepthTexture",
      value: function setDepthTexture(depthTexture) {
        var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var material = this.circleOfConfusionMaterial;
        material.uniforms.depthBuffer.value = depthTexture;
        material.depthPacking = depthPacking;
      }
    }, {
      key: "update",
      value: function update(renderer, inputBuffer, deltaTime) {
        var renderTarget = this.renderTarget;
        var renderTargetNear = this.renderTargetNear;
        var renderTargetFar = this.renderTargetFar;
        var renderTargetCoC = this.renderTargetCoC;
        var renderTargetCoCNear = this.renderTargetCoCNear;
        var renderTargetMasked = this.renderTargetMasked;
        var bokehBasePass = this.bokehBasePass;
        var bokehFillPass = this.bokehFillPass;
        var uniformsBase = bokehBasePass.getFullscreenMaterial().uniforms;
        var uniformsFill = bokehFillPass.getFullscreenMaterial().uniforms;

        if (this.target !== null) {
          var focusDistance = this.calculateFocusDistance(this.target);
          this.circleOfConfusionMaterial.uniforms.focusDistance.value = focusDistance;
        }

        this.cocPass.render(renderer, null, renderTargetCoC);
        this.blurPass.render(renderer, renderTargetCoC, renderTargetCoCNear);
        uniformsBase.cocBuffer.value = renderTargetCoCNear.texture;
        uniformsFill.cocBuffer.value = renderTargetCoCNear.texture;
        uniformsBase.cocMask.value.copy(uniformsFill.cocMask.value.set(1.0, 0.0));
        bokehBasePass.render(renderer, inputBuffer, renderTarget);
        bokehFillPass.render(renderer, renderTarget, renderTargetNear);
        uniformsBase.cocBuffer.value = renderTargetCoC.texture;
        uniformsFill.cocBuffer.value = renderTargetCoC.texture;
        uniformsBase.cocMask.value.copy(uniformsFill.cocMask.value.set(0.0, 1.0));
        this.maskPass.render(renderer, inputBuffer, renderTargetMasked);
        bokehBasePass.render(renderer, renderTargetMasked, renderTarget);
        bokehFillPass.render(renderer, renderTarget, renderTargetFar);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        var resolution = this.resolution;
        this.cocPass.setSize(width, height);
        this.blurPass.setSize(width, height);
        this.maskPass.setSize(width, height);
        this.bokehBasePass.setSize(width, height);
        this.bokehFillPass.setSize(width, height);
        this.renderTargetCoC.setSize(width, height);
        this.renderTargetMasked.setSize(width, height);
        width = resolution.width;
        height = resolution.height;
        this.renderTarget.setSize(width, height);
        this.renderTargetNear.setSize(width, height);
        this.renderTargetFar.setSize(width, height);
        this.renderTargetCoCNear.setSize(width, height);
        this.bokehBasePass.getFullscreenMaterial().setTexelSize(1.0 / width, 1.0 / height);
        this.bokehFillPass.getFullscreenMaterial().setTexelSize(1.0 / width, 1.0 / height);
      }
    }, {
      key: "initialize",
      value: function initialize(renderer, alpha, frameBufferType) {
        this.cocPass.initialize(renderer, alpha, frameBufferType);
        this.blurPass.initialize(renderer, alpha, frameBufferType);
        this.maskPass.initialize(renderer, alpha, frameBufferType);
        this.bokehBasePass.initialize(renderer, alpha, frameBufferType);
        this.bokehFillPass.initialize(renderer, alpha, frameBufferType);

        if (!alpha) {
          this.renderTargetNear.texture.format = RGBFormat;
        }

        if (frameBufferType !== undefined) {
          this.renderTarget.texture.type = frameBufferType;
          this.renderTargetNear.texture.type = frameBufferType;
          this.renderTargetFar.texture.type = frameBufferType;
          this.renderTargetMasked.texture.type = frameBufferType;
        }
      }
    }, {
      key: "circleOfConfusionMaterial",
      get: function get() {
        return this.cocPass.getFullscreenMaterial();
      }
    }, {
      key: "resolution",
      get: function get() {
        return this.blurPass.resolution;
      }
    }, {
      key: "bokehScale",
      get: function get() {
        return this.bokehBasePass.getFullscreenMaterial().uniforms.scale.value;
      },
      set: function set(value) {
        this.uniforms.get("scale").value = value;
        this.bokehBasePass.getFullscreenMaterial().uniforms.scale.value = value;
        this.bokehFillPass.getFullscreenMaterial().uniforms.scale.value = value;
      }
    }]);

    return DepthOfFieldEffect;
  }(Effect);

  var fragmentShader$j = "uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}";

  var DotScreenEffect = function (_Effect8) {
    _inherits(DotScreenEffect, _Effect8);

    function DotScreenEffect() {
      var _this33;

      var _ref15 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref15$blendFunction = _ref15.blendFunction,
          blendFunction = _ref15$blendFunction === void 0 ? BlendFunction.NORMAL : _ref15$blendFunction,
          _ref15$angle = _ref15.angle,
          angle = _ref15$angle === void 0 ? Math.PI * 0.5 : _ref15$angle,
          _ref15$scale = _ref15.scale,
          scale = _ref15$scale === void 0 ? 1.0 : _ref15$scale;

      _classCallCheck(this, DotScreenEffect);

      _this33 = _possibleConstructorReturn(this, _getPrototypeOf(DotScreenEffect).call(this, "DotScreenEffect", fragmentShader$j, {
        blendFunction: blendFunction,
        uniforms: new Map([["angle", new Uniform(new Vector2())], ["scale", new Uniform(scale)]])
      }));

      _this33.setAngle(angle);

      return _this33;
    }

    _createClass(DotScreenEffect, [{
      key: "setAngle",
      value: function setAngle(angle) {
        this.uniforms.get("angle").value.set(Math.sin(angle), Math.cos(angle));
      }
    }]);

    return DotScreenEffect;
  }(Effect);

  var fragmentShader$k = "uniform sampler2D perturbationMap;uniform bool active;uniform float columns;uniform float random;uniform vec2 seed;uniform vec2 distortion;void mainUv(inout vec2 uv){if(active){if(uv.y<distortion.x+columns&&uv.y>distortion.x-columns*random){float sx=clamp(ceil(seed.x),0.0,1.0);uv.y=sx*(1.0-(uv.y+distortion.y))+(1.0-sx)*distortion.y;}if(uv.x<distortion.y+columns&&uv.x>distortion.y-columns*random){float sy=clamp(ceil(seed.y),0.0,1.0);uv.x=sy*distortion.x+(1.0-sy)*(1.0-(uv.x+distortion.x));}vec2 normal=texture2D(perturbationMap,uv*random*random).rg;uv+=normal*seed*(random*0.2);}}";
  var tag = "Glitch.Generated";

  function randomFloat(low, high) {
    return low + Math.random() * (high - low);
  }

  var GlitchEffect = function (_Effect9) {
    _inherits(GlitchEffect, _Effect9);

    function GlitchEffect() {
      var _this34;

      var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref16$blendFunction = _ref16.blendFunction,
          blendFunction = _ref16$blendFunction === void 0 ? BlendFunction.NORMAL : _ref16$blendFunction,
          _ref16$chromaticAberr = _ref16.chromaticAberrationOffset,
          chromaticAberrationOffset = _ref16$chromaticAberr === void 0 ? null : _ref16$chromaticAberr,
          _ref16$delay = _ref16.delay,
          delay = _ref16$delay === void 0 ? new Vector2(1.5, 3.5) : _ref16$delay,
          _ref16$duration = _ref16.duration,
          duration = _ref16$duration === void 0 ? new Vector2(0.6, 1.0) : _ref16$duration,
          _ref16$strength = _ref16.strength,
          strength = _ref16$strength === void 0 ? new Vector2(0.3, 1.0) : _ref16$strength,
          _ref16$columns = _ref16.columns,
          columns = _ref16$columns === void 0 ? 0.05 : _ref16$columns,
          _ref16$ratio = _ref16.ratio,
          ratio = _ref16$ratio === void 0 ? 0.85 : _ref16$ratio,
          _ref16$perturbationMa = _ref16.perturbationMap,
          perturbationMap = _ref16$perturbationMa === void 0 ? null : _ref16$perturbationMa,
          _ref16$dtSize = _ref16.dtSize,
          dtSize = _ref16$dtSize === void 0 ? 64 : _ref16$dtSize;

      _classCallCheck(this, GlitchEffect);

      _this34 = _possibleConstructorReturn(this, _getPrototypeOf(GlitchEffect).call(this, "GlitchEffect", fragmentShader$k, {
        blendFunction: blendFunction,
        uniforms: new Map([["perturbationMap", new Uniform(null)], ["columns", new Uniform(columns)], ["active", new Uniform(false)], ["random", new Uniform(0.02)], ["seed", new Uniform(new Vector2())], ["distortion", new Uniform(new Vector2())]])
      }));
      _this34.perturbationMap = null;

      _this34.setPerturbationMap(perturbationMap === null ? _this34.generatePerturbationMap(dtSize) : perturbationMap);

      _this34.perturbationMap.generateMipmaps = false;
      _this34.delay = delay;
      _this34.duration = duration;
      _this34.breakPoint = new Vector2(randomFloat(_this34.delay.x, _this34.delay.y), randomFloat(_this34.duration.x, _this34.duration.y));
      _this34.time = 0;
      _this34.seed = _this34.uniforms.get("seed").value;
      _this34.distortion = _this34.uniforms.get("distortion").value;
      _this34.mode = GlitchMode.SPORADIC;
      _this34.strength = strength;
      _this34.ratio = ratio;
      _this34.chromaticAberrationOffset = chromaticAberrationOffset;
      return _this34;
    }

    _createClass(GlitchEffect, [{
      key: "getPerturbationMap",
      value: function getPerturbationMap() {
        return this.perturbationMap;
      }
    }, {
      key: "setPerturbationMap",
      value: function setPerturbationMap(perturbationMap) {
        if (this.perturbationMap !== null && this.perturbationMap.name === tag) {
          this.perturbationMap.dispose();
        }

        perturbationMap.wrapS = perturbationMap.wrapT = RepeatWrapping;
        perturbationMap.magFilter = perturbationMap.minFilter = NearestFilter;
        this.perturbationMap = perturbationMap;
        this.uniforms.get("perturbationMap").value = perturbationMap;
      }
    }, {
      key: "generatePerturbationMap",
      value: function generatePerturbationMap() {
        var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 64;
        var pixels = size * size;
        var data = new Uint8Array(pixels * 3);
        var i, l, x;

        for (i = 0, l = data.length; i < l; i += 3) {
          x = Math.random() * 255;
          data[i] = x;
          data[i + 1] = x;
          data[i + 2] = x;
        }

        var map = new DataTexture(data, size, size, RGBFormat);
        map.name = tag;
        map.needsUpdate = true;
        return map;
      }
    }, {
      key: "update",
      value: function update(renderer, inputBuffer, deltaTime) {
        var mode = this.mode;
        var breakPoint = this.breakPoint;
        var offset = this.chromaticAberrationOffset;
        var s = this.strength;
        var time = this.time;
        var active = false;
        var r = 0.0,
            a = 0.0;
        var trigger;

        if (mode !== GlitchMode.DISABLED) {
          if (mode === GlitchMode.SPORADIC) {
            time += deltaTime;
            trigger = time > breakPoint.x;

            if (time >= breakPoint.x + breakPoint.y) {
              breakPoint.set(randomFloat(this.delay.x, this.delay.y), randomFloat(this.duration.x, this.duration.y));
              time = 0;
            }
          }

          r = Math.random();
          this.uniforms.get("random").value = r;

          if (trigger && r > this.ratio || mode === GlitchMode.CONSTANT_WILD) {
            active = true;
            r *= s.y * 0.03;
            a = randomFloat(-Math.PI, Math.PI);
            this.seed.set(randomFloat(-s.y, s.y), randomFloat(-s.y, s.y));
            this.distortion.set(randomFloat(0.0, 1.0), randomFloat(0.0, 1.0));
          } else if (trigger || mode === GlitchMode.CONSTANT_MILD) {
            active = true;
            r *= s.x * 0.03;
            a = randomFloat(-Math.PI, Math.PI);
            this.seed.set(randomFloat(-s.x, s.x), randomFloat(-s.x, s.x));
            this.distortion.set(randomFloat(0.0, 1.0), randomFloat(0.0, 1.0));
          }

          this.time = time;
        }

        if (offset !== null) {
          if (active) {
            offset.set(Math.cos(a), Math.sin(a)).multiplyScalar(r);
          } else {
            offset.set(0.0, 0.0);
          }
        }

        this.uniforms.get("active").value = active;
      }
    }, {
      key: "active",
      get: function get() {
        return this.uniforms.get("active").value;
      }
    }]);

    return GlitchEffect;
  }(Effect);

  var GlitchMode = {
    DISABLED: 0,
    SPORADIC: 1,
    CONSTANT_MILD: 2,
    CONSTANT_WILD: 3
  };
  var v = new Vector3();
  var m = new Matrix4();

  var GodRaysEffect = function (_Effect10) {
    _inherits(GodRaysEffect, _Effect10);

    function GodRaysEffect(camera, lightSource) {
      var _this35;

      var _ref17 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref17$blendFunction = _ref17.blendFunction,
          blendFunction = _ref17$blendFunction === void 0 ? BlendFunction.SCREEN : _ref17$blendFunction,
          _ref17$samples = _ref17.samples,
          samples = _ref17$samples === void 0 ? 60.0 : _ref17$samples,
          _ref17$density = _ref17.density,
          density = _ref17$density === void 0 ? 0.96 : _ref17$density,
          _ref17$decay = _ref17.decay,
          decay = _ref17$decay === void 0 ? 0.9 : _ref17$decay,
          _ref17$weight = _ref17.weight,
          weight = _ref17$weight === void 0 ? 0.4 : _ref17$weight,
          _ref17$exposure = _ref17.exposure,
          exposure = _ref17$exposure === void 0 ? 0.6 : _ref17$exposure,
          _ref17$clampMax = _ref17.clampMax,
          clampMax = _ref17$clampMax === void 0 ? 1.0 : _ref17$clampMax,
          _ref17$resolutionScal = _ref17.resolutionScale,
          resolutionScale = _ref17$resolutionScal === void 0 ? 0.5 : _ref17$resolutionScal,
          _ref17$width = _ref17.width,
          width = _ref17$width === void 0 ? Resizer.AUTO_SIZE : _ref17$width,
          _ref17$height = _ref17.height,
          height = _ref17$height === void 0 ? Resizer.AUTO_SIZE : _ref17$height,
          _ref17$kernelSize = _ref17.kernelSize,
          kernelSize = _ref17$kernelSize === void 0 ? KernelSize.SMALL : _ref17$kernelSize,
          _ref17$blur = _ref17.blur,
          blur = _ref17$blur === void 0 ? true : _ref17$blur;

      _classCallCheck(this, GodRaysEffect);

      _this35 = _possibleConstructorReturn(this, _getPrototypeOf(GodRaysEffect).call(this, "GodRaysEffect", fragmentShader$c, {
        blendFunction: blendFunction,
        attributes: EffectAttribute.DEPTH,
        uniforms: new Map([["texture", new Uniform(null)]])
      }));
      _this35.camera = camera;
      _this35.lightSource = lightSource;
      _this35.lightSource.material.depthWrite = false;
      _this35.lightSource.material.transparent = true;
      _this35.lightScene = new Scene();
      _this35.screenPosition = new Vector2();
      _this35.renderTargetA = new WebGLRenderTarget(1, 1, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      });
      _this35.renderTargetA.texture.name = "GodRays.TargetX";
      _this35.renderTargetB = _this35.renderTargetA.clone();
      _this35.renderTargetB.texture.name = "GodRays.TargetY";
      _this35.uniforms.get("texture").value = _this35.renderTargetB.texture;
      _this35.renderTargetLight = _this35.renderTargetA.clone();
      _this35.renderTargetLight.texture.name = "GodRays.Light";
      _this35.renderTargetLight.depthBuffer = true;
      _this35.renderTargetLight.depthTexture = new DepthTexture();
      _this35.renderPassLight = new RenderPass(_this35.lightScene, camera);
      _this35.renderPassLight.getClearPass().overrideClearColor = new Color(0x000000);
      _this35.clearPass = new ClearPass(true, false, false);
      _this35.clearPass.overrideClearColor = new Color(0x000000);
      _this35.blurPass = new BlurPass({
        resolutionScale: resolutionScale,
        width: width,
        height: height,
        kernelSize: kernelSize
      });
      _this35.blurPass.resolution.resizable = _assertThisInitialized(_this35);
      _this35.depthMaskPass = new ShaderPass(function (depthTexture) {
        var material = new DepthMaskMaterial();
        material.uniforms.depthBuffer1.value = depthTexture;
        return material;
      }(_this35.renderTargetLight.depthTexture));
      _this35.godRaysPass = new ShaderPass(function () {
        var material = new GodRaysMaterial(_this35.screenPosition);
        material.uniforms.density.value = density;
        material.uniforms.decay.value = decay;
        material.uniforms.weight.value = weight;
        material.uniforms.exposure.value = exposure;
        material.uniforms.clampMax.value = clampMax;
        return material;
      }());
      _this35.samples = samples;
      _this35.blur = blur;
      return _this35;
    }

    _createClass(GodRaysEffect, [{
      key: "getResolutionScale",
      value: function getResolutionScale() {
        return this.resolution.scale;
      }
    }, {
      key: "setResolutionScale",
      value: function setResolutionScale(scale) {
        this.resolution.scale = scale;
        this.setSize(this.resolution.base.x, this.resolution.base.y);
      }
    }, {
      key: "setDepthTexture",
      value: function setDepthTexture(depthTexture) {
        var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var material = this.depthMaskPass.getFullscreenMaterial();
        material.uniforms.depthBuffer0.value = depthTexture;
        material.defines.DEPTH_PACKING_0 = depthPacking.toFixed(0);
      }
    }, {
      key: "update",
      value: function update(renderer, inputBuffer, deltaTime) {
        var lightSource = this.lightSource;
        var parent = lightSource.parent;
        var matrixAutoUpdate = lightSource.matrixAutoUpdate;
        var renderTargetA = this.renderTargetA;
        var renderTargetLight = this.renderTargetLight;
        lightSource.material.depthWrite = true;
        lightSource.matrixAutoUpdate = false;
        lightSource.updateWorldMatrix(true, false);

        if (parent !== null) {
          if (!matrixAutoUpdate) {
            m.copy(lightSource.matrix);
          }

          lightSource.matrix.copy(lightSource.matrixWorld);
        }

        this.lightScene.add(lightSource);
        this.renderPassLight.render(renderer, renderTargetLight);
        this.clearPass.render(renderer, renderTargetA);
        this.depthMaskPass.render(renderer, renderTargetLight, renderTargetA);
        lightSource.material.depthWrite = false;
        lightSource.matrixAutoUpdate = matrixAutoUpdate;

        if (parent !== null) {
          if (!matrixAutoUpdate) {
            lightSource.matrix.copy(m);
          }

          parent.add(lightSource);
        }

        v.setFromMatrixPosition(lightSource.matrixWorld).project(this.camera);
        this.screenPosition.set(Math.min(Math.max((v.x + 1.0) * 0.5, -1.0), 2.0), Math.min(Math.max((v.y + 1.0) * 0.5, -1.0), 2.0));

        if (this.blur) {
          this.blurPass.render(renderer, renderTargetA, renderTargetA);
        }

        this.godRaysPass.render(renderer, renderTargetA, this.renderTargetB);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.blurPass.setSize(width, height);
        this.renderPassLight.setSize(width, height);
        this.depthMaskPass.setSize(width, height);
        this.godRaysPass.setSize(width, height);
        width = this.resolution.width;
        height = this.resolution.height;
        this.renderTargetA.setSize(width, height);
        this.renderTargetB.setSize(width, height);
        this.renderTargetLight.setSize(width, height);
      }
    }, {
      key: "initialize",
      value: function initialize(renderer, alpha, frameBufferType) {
        this.blurPass.initialize(renderer, alpha, frameBufferType);
        this.renderPassLight.initialize(renderer, alpha, frameBufferType);
        this.depthMaskPass.initialize(renderer, alpha, frameBufferType);
        this.godRaysPass.initialize(renderer, alpha, frameBufferType);

        if (!alpha) {
          this.renderTargetA.texture.format = RGBFormat;
          this.renderTargetB.texture.format = RGBFormat;
          this.renderTargetLight.texture.format = RGBFormat;
        }

        if (frameBufferType !== undefined) {
          this.renderTargetA.texture.type = frameBufferType;
          this.renderTargetB.texture.type = frameBufferType;
          this.renderTargetLight.texture.type = frameBufferType;
        }
      }
    }, {
      key: "texture",
      get: function get() {
        return this.renderTargetB.texture;
      }
    }, {
      key: "godRaysMaterial",
      get: function get() {
        return this.godRaysPass.getFullscreenMaterial();
      }
    }, {
      key: "resolution",
      get: function get() {
        return this.blurPass.resolution;
      }
    }, {
      key: "width",
      get: function get() {
        return this.resolution.width;
      },
      set: function set(value) {
        this.resolution.width = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this.resolution.height;
      },
      set: function set(value) {
        this.resolution.height = value;
      }
    }, {
      key: "dithering",
      get: function get() {
        return this.godRaysMaterial.dithering;
      },
      set: function set(value) {
        var material = this.godRaysMaterial;
        material.dithering = value;
        material.needsUpdate = true;
      }
    }, {
      key: "blur",
      get: function get() {
        return this.blurPass.enabled;
      },
      set: function set(value) {
        this.blurPass.enabled = value;
      }
    }, {
      key: "kernelSize",
      get: function get() {
        return this.blurPass.kernelSize;
      },
      set: function set(value) {
        this.blurPass.kernelSize = value;
      }
    }, {
      key: "samples",
      get: function get() {
        return this.godRaysMaterial.samples;
      },
      set: function set(value) {
        this.godRaysMaterial.samples = value;
      }
    }]);

    return GodRaysEffect;
  }(Effect);

  var fragmentShader$l = "uniform vec2 scale;uniform float lineWidth;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float grid=0.5-max(abs(mod(uv.x*scale.x,1.0)-0.5),abs(mod(uv.y*scale.y,1.0)-0.5));outputColor=vec4(vec3(smoothstep(0.0,lineWidth,grid)),inputColor.a);}";

  var GridEffect = function (_Effect11) {
    _inherits(GridEffect, _Effect11);

    function GridEffect() {
      var _this36;

      var _ref18 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref18$blendFunction = _ref18.blendFunction,
          blendFunction = _ref18$blendFunction === void 0 ? BlendFunction.OVERLAY : _ref18$blendFunction,
          _ref18$scale = _ref18.scale,
          scale = _ref18$scale === void 0 ? 1.0 : _ref18$scale,
          _ref18$lineWidth = _ref18.lineWidth,
          lineWidth = _ref18$lineWidth === void 0 ? 0.0 : _ref18$lineWidth;

      _classCallCheck(this, GridEffect);

      _this36 = _possibleConstructorReturn(this, _getPrototypeOf(GridEffect).call(this, "GridEffect", fragmentShader$l, {
        blendFunction: blendFunction,
        uniforms: new Map([["scale", new Uniform(new Vector2())], ["lineWidth", new Uniform(lineWidth)]])
      }));
      _this36.resolution = new Vector2();
      _this36.scale = Math.max(scale, 1e-6);
      _this36.lineWidth = Math.max(lineWidth, 0.0);
      return _this36;
    }

    _createClass(GridEffect, [{
      key: "getScale",
      value: function getScale() {
        return this.scale;
      }
    }, {
      key: "setScale",
      value: function setScale(scale) {
        this.scale = scale;
        this.setSize(this.resolution.x, this.resolution.y);
      }
    }, {
      key: "getLineWidth",
      value: function getLineWidth() {
        return this.lineWidth;
      }
    }, {
      key: "setLineWidth",
      value: function setLineWidth(lineWidth) {
        this.lineWidth = lineWidth;
        this.setSize(this.resolution.x, this.resolution.y);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.resolution.set(width, height);
        var aspect = width / height;
        var scale = this.scale * (height * 0.125);
        this.uniforms.get("scale").value.set(aspect * scale, scale);
        this.uniforms.get("lineWidth").value = scale / height + this.lineWidth;
      }
    }]);

    return GridEffect;
  }(Effect);

  var fragmentShader$m = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}";

  var HueSaturationEffect = function (_Effect12) {
    _inherits(HueSaturationEffect, _Effect12);

    function HueSaturationEffect() {
      var _this37;

      var _ref19 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref19$blendFunction = _ref19.blendFunction,
          blendFunction = _ref19$blendFunction === void 0 ? BlendFunction.NORMAL : _ref19$blendFunction,
          _ref19$hue = _ref19.hue,
          hue = _ref19$hue === void 0 ? 0.0 : _ref19$hue,
          _ref19$saturation = _ref19.saturation,
          saturation = _ref19$saturation === void 0 ? 0.0 : _ref19$saturation;

      _classCallCheck(this, HueSaturationEffect);

      _this37 = _possibleConstructorReturn(this, _getPrototypeOf(HueSaturationEffect).call(this, "HueSaturationEffect", fragmentShader$m, {
        blendFunction: blendFunction,
        uniforms: new Map([["hue", new Uniform(new Vector3())], ["saturation", new Uniform(saturation)]])
      }));

      _this37.setHue(hue);

      return _this37;
    }

    _createClass(HueSaturationEffect, [{
      key: "setHue",
      value: function setHue(hue) {
        var s = Math.sin(hue),
            c = Math.cos(hue);
        this.uniforms.get("hue").value.set(2.0 * c, -Math.sqrt(3.0) * s - c, Math.sqrt(3.0) * s - c).addScalar(1.0).divideScalar(3.0);
      }
    }]);

    return HueSaturationEffect;
  }(Effect);

  var fragmentShader$n = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));\n#ifdef PREMULTIPLY\noutputColor=vec4(inputColor.rgb*noise,inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}";

  var NoiseEffect = function (_Effect13) {
    _inherits(NoiseEffect, _Effect13);

    function NoiseEffect() {
      var _this38;

      var _ref20 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref20$blendFunction = _ref20.blendFunction,
          blendFunction = _ref20$blendFunction === void 0 ? BlendFunction.SCREEN : _ref20$blendFunction,
          _ref20$premultiply = _ref20.premultiply,
          premultiply = _ref20$premultiply === void 0 ? false : _ref20$premultiply;

      _classCallCheck(this, NoiseEffect);

      _this38 = _possibleConstructorReturn(this, _getPrototypeOf(NoiseEffect).call(this, "NoiseEffect", fragmentShader$n, {
        blendFunction: blendFunction
      }));
      _this38.premultiply = premultiply;
      return _this38;
    }

    _createClass(NoiseEffect, [{
      key: "premultiply",
      get: function get() {
        return this.defines.has("PREMULTIPLY");
      },
      set: function set(value) {
        value ? this.defines.set("PREMULTIPLY", "1") : this.defines["delete"]("PREMULTIPLY");
      }
    }]);

    return NoiseEffect;
  }(Effect);

  var fragmentShader$o = "uniform sampler2D edgeTexture;uniform sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;\n#ifdef USE_PATTERN\nuniform sampler2D patternTexture;varying vec2 vUvPattern;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;\n#ifndef X_RAY\nedge.y=0.0;\n#endif\nedge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;\n#ifdef USE_PATTERN\nvec4 patternColor=texture2D(patternTexture,vUvPattern);\n#ifdef X_RAY\nfloat hiddenFactor=0.5;\n#else\nfloat hiddenFactor=0.0;\n#endif\nvisibilityFactor=(1.0-mask.y>0.0)? 1.0 : hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;\n#endif\nfloat alpha=max(max(edge.x,edge.y),visibilityFactor);\n#ifdef ALPHA\noutputColor=vec4(color,alpha);\n#else\noutputColor=vec4(color,max(alpha,inputColor.a));\n#endif\n}";
  var vertexShader$7 = "uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}";

  var OutlineEffect = function (_Effect14) {
    _inherits(OutlineEffect, _Effect14);

    function OutlineEffect(scene, camera) {
      var _this39;

      var _ref21 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref21$blendFunction = _ref21.blendFunction,
          blendFunction = _ref21$blendFunction === void 0 ? BlendFunction.SCREEN : _ref21$blendFunction,
          _ref21$patternTexture = _ref21.patternTexture,
          patternTexture = _ref21$patternTexture === void 0 ? null : _ref21$patternTexture,
          _ref21$edgeStrength = _ref21.edgeStrength,
          edgeStrength = _ref21$edgeStrength === void 0 ? 1.0 : _ref21$edgeStrength,
          _ref21$pulseSpeed = _ref21.pulseSpeed,
          pulseSpeed = _ref21$pulseSpeed === void 0 ? 0.0 : _ref21$pulseSpeed,
          _ref21$visibleEdgeCol = _ref21.visibleEdgeColor,
          visibleEdgeColor = _ref21$visibleEdgeCol === void 0 ? 0xffffff : _ref21$visibleEdgeCol,
          _ref21$hiddenEdgeColo = _ref21.hiddenEdgeColor,
          hiddenEdgeColor = _ref21$hiddenEdgeColo === void 0 ? 0x22090a : _ref21$hiddenEdgeColo,
          _ref21$resolutionScal = _ref21.resolutionScale,
          resolutionScale = _ref21$resolutionScal === void 0 ? 0.5 : _ref21$resolutionScal,
          _ref21$width = _ref21.width,
          width = _ref21$width === void 0 ? Resizer.AUTO_SIZE : _ref21$width,
          _ref21$height = _ref21.height,
          height = _ref21$height === void 0 ? Resizer.AUTO_SIZE : _ref21$height,
          _ref21$kernelSize = _ref21.kernelSize,
          kernelSize = _ref21$kernelSize === void 0 ? KernelSize.VERY_SMALL : _ref21$kernelSize,
          _ref21$blur = _ref21.blur,
          blur = _ref21$blur === void 0 ? false : _ref21$blur,
          _ref21$xRay = _ref21.xRay,
          xRay = _ref21$xRay === void 0 ? true : _ref21$xRay;

      _classCallCheck(this, OutlineEffect);

      _this39 = _possibleConstructorReturn(this, _getPrototypeOf(OutlineEffect).call(this, "OutlineEffect", fragmentShader$o, {
        uniforms: new Map([["maskTexture", new Uniform(null)], ["edgeTexture", new Uniform(null)], ["edgeStrength", new Uniform(edgeStrength)], ["visibleEdgeColor", new Uniform(new Color(visibleEdgeColor))], ["hiddenEdgeColor", new Uniform(new Color(hiddenEdgeColor))], ["pulse", new Uniform(1.0)]])
      }));

      _this39.blendMode = function (defines) {
        return new Proxy(_this39.blendMode, {
          set: function set(target, name, value) {
            if (value === BlendFunction.ALPHA) {
              defines.set("ALPHA", "1");
            } else {
              defines["delete"]("ALPHA");
            }

            target[name] = value;
            return true;
          }
        });
      }(_this39.defines);

      _this39.blendMode.blendFunction = blendFunction;

      _this39.setPatternTexture(patternTexture);

      _this39.xRay = xRay;
      _this39.scene = scene;
      _this39.camera = camera;
      _this39.renderTargetMask = new WebGLRenderTarget(1, 1, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        stencilBuffer: false,
        format: RGBFormat
      });
      _this39.renderTargetMask.texture.name = "Outline.Mask";
      _this39.uniforms.get("maskTexture").value = _this39.renderTargetMask.texture;
      _this39.renderTargetOutline = _this39.renderTargetMask.clone();
      _this39.renderTargetOutline.texture.name = "Outline.Edges";
      _this39.renderTargetOutline.depthBuffer = false;
      _this39.renderTargetBlurredOutline = _this39.renderTargetOutline.clone();
      _this39.renderTargetBlurredOutline.texture.name = "Outline.BlurredEdges";
      _this39.clearPass = new ClearPass();
      _this39.clearPass.overrideClearColor = new Color(0x000000);
      _this39.clearPass.overrideClearAlpha = 1.0;
      _this39.depthPass = new DepthPass(scene, camera);
      _this39.maskPass = new RenderPass(scene, camera, new DepthComparisonMaterial(_this39.depthPass.renderTarget.texture, camera));

      var clearPass = _this39.maskPass.getClearPass();

      clearPass.overrideClearColor = new Color(0xffffff);
      clearPass.overrideClearAlpha = 1.0;
      _this39.blurPass = new BlurPass({
        resolutionScale: resolutionScale,
        width: width,
        height: height,
        kernelSize: kernelSize
      });
      _this39.blurPass.resolution.resizable = _assertThisInitialized(_this39);
      _this39.blur = blur;
      _this39.outlinePass = new ShaderPass(new OutlineMaterial());
      _this39.outlinePass.getFullscreenMaterial().uniforms.inputBuffer.value = _this39.renderTargetMask.texture;
      _this39.time = 0.0;
      _this39.selection = new Selection();
      _this39.pulseSpeed = pulseSpeed;
      return _this39;
    }

    _createClass(OutlineEffect, [{
      key: "setPatternTexture",
      value: function setPatternTexture(texture) {
        if (texture !== null) {
          texture.wrapS = texture.wrapT = RepeatWrapping;
          this.defines.set("USE_PATTERN", "1");
          this.uniforms.set("patternScale", new Uniform(1.0));
          this.uniforms.set("patternTexture", new Uniform(texture));
          this.vertexShader = vertexShader$7;
        } else {
          this.defines["delete"]("USE_PATTERN");
          this.uniforms["delete"]("patternScale");
          this.uniforms["delete"]("patternTexture");
          this.vertexShader = null;
        }
      }
    }, {
      key: "getResolutionScale",
      value: function getResolutionScale() {
        return this.resolution.scale;
      }
    }, {
      key: "setResolutionScale",
      value: function setResolutionScale(scale) {
        this.resolution.scale = scale;
        this.setSize(this.resolution.base.x, this.resolution.base.y);
      }
    }, {
      key: "setSelection",
      value: function setSelection(objects) {
        this.selection.set(objects);
        return this;
      }
    }, {
      key: "clearSelection",
      value: function clearSelection() {
        this.selection.clear();
        return this;
      }
    }, {
      key: "selectObject",
      value: function selectObject(object) {
        this.selection.add(object);
        return this;
      }
    }, {
      key: "deselectObject",
      value: function deselectObject(object) {
        this.selection["delete"](object);
        return this;
      }
    }, {
      key: "update",
      value: function update(renderer, inputBuffer, deltaTime) {
        var scene = this.scene;
        var camera = this.camera;
        var selection = this.selection;
        var pulse = this.uniforms.get("pulse");
        var background = scene.background;
        var mask = camera.layers.mask;

        if (selection.size > 0) {
          scene.background = null;
          pulse.value = 1.0;

          if (this.pulseSpeed > 0.0) {
            pulse.value = 0.625 + Math.cos(this.time * this.pulseSpeed * 10.0) * 0.375;
          }

          this.time += deltaTime;
          selection.setVisible(false);
          this.depthPass.render(renderer);
          selection.setVisible(true);
          camera.layers.set(selection.layer);
          this.maskPass.render(renderer, this.renderTargetMask);
          camera.layers.mask = mask;
          scene.background = background;
          this.outlinePass.render(renderer, null, this.renderTargetOutline);

          if (this.blur) {
            this.blurPass.render(renderer, this.renderTargetOutline, this.renderTargetBlurredOutline);
          }
        } else if (this.time > 0.0) {
          this.clearPass.render(renderer, this.renderTargetMask);
          this.time = 0.0;
        }
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.blurPass.setSize(width, height);
        this.renderTargetMask.setSize(width, height);
        width = this.resolution.width;
        height = this.resolution.height;
        this.depthPass.setSize(width, height);
        this.renderTargetOutline.setSize(width, height);
        this.renderTargetBlurredOutline.setSize(width, height);
        this.outlinePass.getFullscreenMaterial().setTexelSize(1.0 / width, 1.0 / height);
      }
    }, {
      key: "initialize",
      value: function initialize(renderer, alpha, frameBufferType) {
        this.blurPass.initialize(renderer, alpha, UnsignedByteType);

        if (frameBufferType !== undefined) {
          this.depthPass.initialize(renderer, alpha, frameBufferType);
          this.maskPass.initialize(renderer, alpha, frameBufferType);
          this.outlinePass.initialize(renderer, alpha, frameBufferType);
        }
      }
    }, {
      key: "resolution",
      get: function get() {
        return this.blurPass.resolution;
      }
    }, {
      key: "width",
      get: function get() {
        return this.resolution.width;
      },
      set: function set(value) {
        this.resolution.width = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this.resolution.height;
      },
      set: function set(value) {
        this.resolution.height = value;
      }
    }, {
      key: "selectionLayer",
      get: function get() {
        return this.selection.layer;
      },
      set: function set(value) {
        this.selection.layer = value;
      }
    }, {
      key: "dithering",
      get: function get() {
        return this.blurPass.dithering;
      },
      set: function set(value) {
        this.blurPass.dithering = value;
      }
    }, {
      key: "kernelSize",
      get: function get() {
        return this.blurPass.kernelSize;
      },
      set: function set(value) {
        this.blurPass.kernelSize = value;
      }
    }, {
      key: "blur",
      get: function get() {
        return this.blurPass.enabled;
      },
      set: function set(value) {
        this.blurPass.enabled = value;
        this.uniforms.get("edgeTexture").value = value ? this.renderTargetBlurredOutline.texture : this.renderTargetOutline.texture;
      }
    }, {
      key: "xRay",
      get: function get() {
        return this.defines.has("X_RAY");
      },
      set: function set(value) {
        value ? this.defines.set("X_RAY", "1") : this.defines["delete"]("X_RAY");
      }
    }]);

    return OutlineEffect;
  }(Effect);

  var fragmentShader$p = "uniform bool active;uniform vec2 d;void mainUv(inout vec2 uv){if(active){uv=vec2(d.x*(floor(uv.x/d.x)+0.5),d.y*(floor(uv.y/d.y)+0.5));}}";

  var PixelationEffect = function (_Effect15) {
    _inherits(PixelationEffect, _Effect15);

    function PixelationEffect() {
      var _this40;

      var granularity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30.0;

      _classCallCheck(this, PixelationEffect);

      _this40 = _possibleConstructorReturn(this, _getPrototypeOf(PixelationEffect).call(this, "PixelationEffect", fragmentShader$p, {
        uniforms: new Map([["active", new Uniform(false)], ["d", new Uniform(new Vector2())]])
      }));
      _this40.resolution = new Vector2();
      _this40.granularity = granularity;
      return _this40;
    }

    _createClass(PixelationEffect, [{
      key: "getGranularity",
      value: function getGranularity() {
        return this.granularity;
      }
    }, {
      key: "setGranularity",
      value: function setGranularity(granularity) {
        granularity = Math.floor(granularity);

        if (granularity % 2 > 0) {
          granularity += 1;
        }

        var uniforms = this.uniforms;
        uniforms.get("active").value = granularity > 0.0;
        uniforms.get("d").value.set(granularity, granularity).divide(this.resolution);
        this.granularity = granularity;
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.resolution.set(width, height);
        this.setGranularity(this.granularity);
      }
    }]);

    return PixelationEffect;
  }(Effect);

  var fragmentShader$q = "uniform float count;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 sl=vec2(sin(uv.y*count),cos(uv.y*count));vec3 scanlines=vec3(sl.x,sl.y,sl.x);outputColor=vec4(scanlines,inputColor.a);}";

  var ScanlineEffect = function (_Effect16) {
    _inherits(ScanlineEffect, _Effect16);

    function ScanlineEffect() {
      var _this41;

      var _ref22 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref22$blendFunction = _ref22.blendFunction,
          blendFunction = _ref22$blendFunction === void 0 ? BlendFunction.OVERLAY : _ref22$blendFunction,
          _ref22$density = _ref22.density,
          density = _ref22$density === void 0 ? 1.25 : _ref22$density;

      _classCallCheck(this, ScanlineEffect);

      _this41 = _possibleConstructorReturn(this, _getPrototypeOf(ScanlineEffect).call(this, "ScanlineEffect", fragmentShader$q, {
        blendFunction: blendFunction,
        uniforms: new Map([["count", new Uniform(0.0)]])
      }));
      _this41.resolution = new Vector2();
      _this41.density = density;
      return _this41;
    }

    _createClass(ScanlineEffect, [{
      key: "getDensity",
      value: function getDensity() {
        return this.density;
      }
    }, {
      key: "setDensity",
      value: function setDensity(density) {
        this.density = density;
        this.setSize(this.resolution.x, this.resolution.y);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.resolution.set(width, height);
        this.uniforms.get("count").value = Math.round(height * this.density);
      }
    }]);

    return ScanlineEffect;
  }(Effect);

  var fragmentShader$r = "uniform bool active;uniform vec2 center;uniform float waveSize;uniform float radius;uniform float maxRadius;uniform float amplitude;varying float vSize;void mainUv(inout vec2 uv){if(active){vec2 aspectCorrection=vec2(aspect,1.0);vec2 difference=uv*aspectCorrection-center*aspectCorrection;float distance=sqrt(dot(difference,difference))*vSize;if(distance>radius){if(distance<radius+waveSize){float angle=(distance-radius)*PI2/waveSize;float cosSin=(1.0-cos(angle))*0.5;float extent=maxRadius+waveSize;float decay=max(extent-distance*distance,0.0)/extent;uv-=((cosSin*amplitude*difference)/distance)*decay;}}}}";
  var vertexShader$8 = "uniform float size;uniform float cameraDistance;varying float vSize;void mainSupport(){vSize=(0.1*cameraDistance)/size;}";
  var HALF_PI = Math.PI * 0.5;
  var v$1 = new Vector3();
  var ab = new Vector3();

  var ShockWaveEffect = function (_Effect17) {
    _inherits(ShockWaveEffect, _Effect17);

    function ShockWaveEffect(camera) {
      var _this42;

      var epicenter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();

      var _ref23 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref23$speed = _ref23.speed,
          speed = _ref23$speed === void 0 ? 2.0 : _ref23$speed,
          _ref23$maxRadius = _ref23.maxRadius,
          maxRadius = _ref23$maxRadius === void 0 ? 1.0 : _ref23$maxRadius,
          _ref23$waveSize = _ref23.waveSize,
          waveSize = _ref23$waveSize === void 0 ? 0.2 : _ref23$waveSize,
          _ref23$amplitude = _ref23.amplitude,
          amplitude = _ref23$amplitude === void 0 ? 0.05 : _ref23$amplitude;

      _classCallCheck(this, ShockWaveEffect);

      _this42 = _possibleConstructorReturn(this, _getPrototypeOf(ShockWaveEffect).call(this, "ShockWaveEffect", fragmentShader$r, {
        vertexShader: vertexShader$8,
        uniforms: new Map([["active", new Uniform(false)], ["center", new Uniform(new Vector2(0.5, 0.5))], ["cameraDistance", new Uniform(1.0)], ["size", new Uniform(1.0)], ["radius", new Uniform(-waveSize)], ["maxRadius", new Uniform(maxRadius)], ["waveSize", new Uniform(waveSize)], ["amplitude", new Uniform(amplitude)]])
      }));
      _this42.camera = camera;
      _this42.epicenter = epicenter;
      _this42.screenPosition = _this42.uniforms.get("center").value;
      _this42.speed = speed;
      _this42.time = 0.0;
      _this42.active = false;
      return _this42;
    }

    _createClass(ShockWaveEffect, [{
      key: "explode",
      value: function explode() {
        this.time = 0.0;
        this.active = true;
        this.uniforms.get("active").value = true;
      }
    }, {
      key: "update",
      value: function update(renderer, inputBuffer, delta) {
        var epicenter = this.epicenter;
        var camera = this.camera;
        var uniforms = this.uniforms;
        var uniformActive = uniforms.get("active");

        if (this.active) {
          var waveSize = uniforms.get("waveSize").value;
          camera.getWorldDirection(v$1);
          ab.copy(camera.position).sub(epicenter);
          uniformActive.value = v$1.angleTo(ab) > HALF_PI;

          if (uniformActive.value) {
            uniforms.get("cameraDistance").value = camera.position.distanceTo(epicenter);
            v$1.copy(epicenter).project(camera);
            this.screenPosition.set((v$1.x + 1.0) * 0.5, (v$1.y + 1.0) * 0.5);
          }

          this.time += delta * this.speed;
          var radius = this.time - waveSize;
          uniforms.get("radius").value = radius;

          if (radius >= (uniforms.get("maxRadius").value + waveSize) * 2.0) {
            this.active = false;
            uniformActive.value = false;
          }
        }
      }
    }]);

    return ShockWaveEffect;
  }(Effect);

  var SelectiveBloomEffect = function (_BloomEffect) {
    _inherits(SelectiveBloomEffect, _BloomEffect);

    function SelectiveBloomEffect(scene, camera, options) {
      var _this43;

      _classCallCheck(this, SelectiveBloomEffect);

      _this43 = _possibleConstructorReturn(this, _getPrototypeOf(SelectiveBloomEffect).call(this, options));
      _this43.scene = scene;
      _this43.camera = camera;
      _this43.clearPass = new ClearPass(true, true, false);
      _this43.clearPass.overrideClearColor = new Color(0x000000);
      _this43.renderPass = new RenderPass(scene, camera);
      _this43.renderPass.clear = false;
      _this43.blackoutPass = new RenderPass(scene, camera, new MeshBasicMaterial({
        color: 0x000000
      }));
      _this43.blackoutPass.clear = false;

      _this43.backgroundPass = function () {
        var backgroundScene = new Scene();
        var pass = new RenderPass(backgroundScene, camera);
        backgroundScene.background = scene.background;
        pass.clear = false;
        return pass;
      }();

      _this43.renderTargetSelection = new WebGLRenderTarget(1, 1, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        stencilBuffer: false,
        depthBuffer: true
      });
      _this43.renderTargetSelection.texture.name = "Bloom.Selection";
      _this43.renderTargetSelection.texture.generateMipmaps = false;
      _this43.selection = new Selection();
      _this43.inverted = false;
      return _this43;
    }

    _createClass(SelectiveBloomEffect, [{
      key: "update",
      value: function update(renderer, inputBuffer, deltaTime) {
        var scene = this.scene;
        var camera = this.camera;
        var selection = this.selection;
        var renderTarget = this.renderTargetSelection;
        var background = scene.background;
        var mask = camera.layers.mask;
        this.clearPass.render(renderer, renderTarget);

        if (!this.ignoreBackground) {
          this.backgroundPass.render(renderer, renderTarget);
        }

        scene.background = null;

        if (this.inverted) {
          camera.layers.set(selection.layer);
          this.blackoutPass.render(renderer, renderTarget);
          camera.layers.mask = mask;
          selection.setVisible(false);
          this.renderPass.render(renderer, renderTarget);
          selection.setVisible(true);
        } else {
          selection.setVisible(false);
          this.blackoutPass.render(renderer, renderTarget);
          selection.setVisible(true);
          camera.layers.set(selection.layer);
          this.renderPass.render(renderer, renderTarget);
          camera.layers.mask = mask;
        }

        scene.background = background;

        _get(_getPrototypeOf(SelectiveBloomEffect.prototype), "update", this).call(this, renderer, renderTarget, deltaTime);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        _get(_getPrototypeOf(SelectiveBloomEffect.prototype), "setSize", this).call(this, width, height);

        this.backgroundPass.setSize(width, height);
        this.blackoutPass.setSize(width, height);
        this.renderPass.setSize(width, height);
        this.renderTargetSelection.setSize(this.resolution.width, this.resolution.height);
      }
    }, {
      key: "initialize",
      value: function initialize(renderer, alpha, frameBufferType) {
        _get(_getPrototypeOf(SelectiveBloomEffect.prototype), "initialize", this).call(this, renderer, alpha, frameBufferType);

        this.backgroundPass.initialize(renderer, alpha, frameBufferType);
        this.blackoutPass.initialize(renderer, alpha, frameBufferType);
        this.renderPass.initialize(renderer, alpha, frameBufferType);

        if (!alpha) {
          this.renderTargetSelection.texture.format = RGBFormat;
        }

        if (frameBufferType !== undefined) {
          this.renderTargetSelection.texture.type = frameBufferType;
        }
      }
    }, {
      key: "ignoreBackground",
      get: function get() {
        return !this.backgroundPass.enabled;
      },
      set: function set(value) {
        this.backgroundPass.enabled = !value;
      }
    }]);

    return SelectiveBloomEffect;
  }(BloomEffect);

  var fragmentShader$s = "uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,vec3(1.0-0.607*intensity,0.769*intensity,0.189*intensity)),dot(inputColor.rgb,vec3(0.349*intensity,1.0-0.314*intensity,0.168*intensity)),dot(inputColor.rgb,vec3(0.272*intensity,0.534*intensity,1.0-0.869*intensity)));outputColor=vec4(color,inputColor.a);}";

  var SepiaEffect = function (_Effect18) {
    _inherits(SepiaEffect, _Effect18);

    function SepiaEffect() {
      var _ref24 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref24$blendFunction = _ref24.blendFunction,
          blendFunction = _ref24$blendFunction === void 0 ? BlendFunction.NORMAL : _ref24$blendFunction,
          _ref24$intensity = _ref24.intensity,
          intensity = _ref24$intensity === void 0 ? 1.0 : _ref24$intensity;

      _classCallCheck(this, SepiaEffect);

      return _possibleConstructorReturn(this, _getPrototypeOf(SepiaEffect).call(this, "SepiaEffect", fragmentShader$s, {
        blendFunction: blendFunction,
        uniforms: new Map([["intensity", new Uniform(intensity)]])
      }));
    }

    return SepiaEffect;
  }(Effect);

  var searchImageDataURL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC";
  var areaImageDataURL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC";
  var fragmentShader$t = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;/***Moves values to a target vector based on a given conditional vector.*/void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}";
  var vertexShader$9 = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}";

  var SMAAEffect = function (_Effect19) {
    _inherits(SMAAEffect, _Effect19);

    function SMAAEffect(searchImage, areaImage) {
      var _this44;

      var preset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : SMAAPreset.HIGH;
      var edgeDetectionMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EdgeDetectionMode.COLOR;

      _classCallCheck(this, SMAAEffect);

      _this44 = _possibleConstructorReturn(this, _getPrototypeOf(SMAAEffect).call(this, "SMAAEffect", fragmentShader$t, {
        vertexShader: vertexShader$9,
        blendFunction: BlendFunction.NORMAL,
        attributes: EffectAttribute.CONVOLUTION,
        uniforms: new Map([["weightMap", new Uniform(null)]])
      }));
      _this44.renderTargetEdges = new WebGLRenderTarget(1, 1, {
        minFilter: LinearFilter,
        stencilBuffer: false,
        depthBuffer: false,
        format: RGBFormat
      });
      _this44.renderTargetEdges.texture.name = "SMAA.Edges";
      _this44.renderTargetWeights = _this44.renderTargetEdges.clone();
      _this44.renderTargetWeights.texture.name = "SMAA.Weights";
      _this44.renderTargetWeights.texture.format = RGBAFormat;
      _this44.uniforms.get("weightMap").value = _this44.renderTargetWeights.texture;
      _this44.clearPass = new ClearPass(true, false, false);
      _this44.clearPass.overrideClearColor = new Color(0x000000);
      _this44.clearPass.overrideClearAlpha = 1.0;
      _this44.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial(new Vector2(), edgeDetectionMode));

      if (edgeDetectionMode === EdgeDetectionMode.DEPTH) {
        _this44.attributes |= EffectAttribute.DEPTH;
      }

      _this44.weightsPass = new ShaderPass(new SMAAWeightsMaterial());

      _this44.weightsPass.getFullscreenMaterial().uniforms.searchTexture.value = function () {
        var searchTexture = new Texture(searchImage);
        searchTexture.name = "SMAA.Search";
        searchTexture.magFilter = NearestFilter;
        searchTexture.minFilter = NearestFilter;
        searchTexture.format = RGBAFormat;
        searchTexture.generateMipmaps = false;
        searchTexture.needsUpdate = true;
        searchTexture.flipY = true;
        return searchTexture;
      }();

      _this44.weightsPass.getFullscreenMaterial().uniforms.areaTexture.value = function () {
        var areaTexture = new Texture(areaImage);
        areaTexture.name = "SMAA.Area";
        areaTexture.minFilter = LinearFilter;
        areaTexture.format = RGBAFormat;
        areaTexture.generateMipmaps = false;
        areaTexture.needsUpdate = true;
        areaTexture.flipY = false;
        return areaTexture;
      }();

      _this44.applyPreset(preset);

      return _this44;
    }

    _createClass(SMAAEffect, [{
      key: "setEdgeDetectionThreshold",
      value: function setEdgeDetectionThreshold(threshold) {
        this.edgeDetectionPass.getFullscreenMaterial().setEdgeDetectionThreshold(threshold);
      }
    }, {
      key: "setOrthogonalSearchSteps",
      value: function setOrthogonalSearchSteps(steps) {
        this.weightsPass.getFullscreenMaterial().setOrthogonalSearchSteps(steps);
      }
    }, {
      key: "applyPreset",
      value: function applyPreset(preset) {
        var edgeDetectionMaterial = this.edgeDetectionMaterial;
        var weightsMaterial = this.weightsMaterial;

        switch (preset) {
          case SMAAPreset.LOW:
            edgeDetectionMaterial.setEdgeDetectionThreshold(0.15);
            weightsMaterial.setOrthogonalSearchSteps(4);
            weightsMaterial.diagonalDetection = false;
            weightsMaterial.cornerRounding = false;
            break;

          case SMAAPreset.MEDIUM:
            edgeDetectionMaterial.setEdgeDetectionThreshold(0.1);
            weightsMaterial.setOrthogonalSearchSteps(8);
            weightsMaterial.diagonalDetection = false;
            weightsMaterial.cornerRounding = false;
            break;

          case SMAAPreset.HIGH:
            edgeDetectionMaterial.setEdgeDetectionThreshold(0.1);
            weightsMaterial.setOrthogonalSearchSteps(16);
            weightsMaterial.setDiagonalSearchSteps(8);
            weightsMaterial.setCornerRounding(25);
            weightsMaterial.diagonalDetection = true;
            weightsMaterial.cornerRounding = true;
            break;

          case SMAAPreset.ULTRA:
            edgeDetectionMaterial.setEdgeDetectionThreshold(0.05);
            weightsMaterial.setOrthogonalSearchSteps(32);
            weightsMaterial.setDiagonalSearchSteps(16);
            weightsMaterial.setCornerRounding(25);
            weightsMaterial.diagonalDetection = true;
            weightsMaterial.cornerRounding = true;
            break;
        }
      }
    }, {
      key: "setDepthTexture",
      value: function setDepthTexture(depthTexture) {
        var depthPacking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var material = this.edgeDetectionMaterial;
        material.uniforms.depthBuffer.value = depthTexture;
        material.depthPacking = depthPacking;
      }
    }, {
      key: "update",
      value: function update(renderer, inputBuffer, deltaTime) {
        this.clearPass.render(renderer, this.renderTargetEdges);
        this.edgeDetectionPass.render(renderer, inputBuffer, this.renderTargetEdges);
        this.weightsPass.render(renderer, this.renderTargetEdges, this.renderTargetWeights);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        var edgeDetectionMaterial = this.edgeDetectionPass.getFullscreenMaterial();
        var weightsMaterial = this.weightsPass.getFullscreenMaterial();
        this.renderTargetEdges.setSize(width, height);
        this.renderTargetWeights.setSize(width, height);
        weightsMaterial.uniforms.resolution.value.set(width, height);
        weightsMaterial.uniforms.texelSize.value.set(1.0 / width, 1.0 / height);
        edgeDetectionMaterial.uniforms.texelSize.value.copy(weightsMaterial.uniforms.texelSize.value);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        var uniforms = this.weightsPass.getFullscreenMaterial().uniforms;
        uniforms.searchTexture.value.dispose();
        uniforms.areaTexture.value.dispose();

        _get(_getPrototypeOf(SMAAEffect.prototype), "dispose", this).call(this);
      }
    }, {
      key: "edgeDetectionMaterial",
      get: function get() {
        return this.edgeDetectionPass.getFullscreenMaterial();
      }
    }, {
      key: "colorEdgesMaterial",
      get: function get() {
        return this.edgeDetectionMaterial;
      }
    }, {
      key: "weightsMaterial",
      get: function get() {
        return this.weightsPass.getFullscreenMaterial();
      }
    }], [{
      key: "searchImageDataURL",
      get: function get() {
        return searchImageDataURL;
      }
    }, {
      key: "areaImageDataURL",
      get: function get() {
        return areaImageDataURL;
      }
    }]);

    return SMAAEffect;
  }(Effect);

  var SMAAPreset = {
    LOW: 0,
    MEDIUM: 1,
    HIGH: 2,
    ULTRA: 3
  };
  var fragmentShader$u = "uniform sampler2D normalBuffer;uniform mat4 cameraProjectionMatrix;uniform mat4 cameraInverseProjectionMatrix;uniform vec2 radiusStep;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;uniform float seed;uniform float luminanceInfluence;uniform float scale;uniform float bias;vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){float clipW=cameraProjectionMatrix[2][3]*viewZ+cameraProjectionMatrix[3][3];vec4 clipPosition=vec4((vec3(screenPosition,depth)-0.5)*2.0,1.0);clipPosition*=clipW;return(cameraInverseProjectionMatrix*clipPosition).xyz;}float getOcclusion(const in vec3 p,const in vec3 n,const in vec3 sampleViewPosition){vec3 viewDelta=sampleViewPosition-p;float d=length(viewDelta)*scale;return max(0.0,dot(n,viewDelta)/d-bias)/(1.0+pow2(d));}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){vec2 radius=radiusStep;float angle=rand(uv+seed)*PI2;float occlusionSum=0.0;for(int i=0;i<SAMPLES_INT;++i){vec2 coord=uv+vec2(cos(angle),sin(angle))*radius;radius+=radiusStep;angle+=ANGLE_STEP;float sampleDepth=readDepth(coord);float viewZ=getViewZ(sampleDepth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearSampleDepth=sampleDepth;\n#endif\nfloat proximity=abs(depth-linearSampleDepth);if(linearSampleDepth<distanceCutoff.y&&proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 sampleViewPosition=getViewPosition(coord,sampleDepth,viewZ);occlusionSum+=getOcclusion(p,n,sampleViewPosition)*falloff;}}return occlusionSum/SAMPLES_FLOAT;}void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float ao=1.0;float viewZ=getViewZ(depth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(uv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(texture2D(normalBuffer,uv).xyz);ao-=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,uv);float l=linearToRelativeLuminance(inputColor.rgb);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);float f=max(l*luminanceInfluence,d);ao=mix(ao,1.0,f);}outputColor=vec4(vec3(ao),inputColor.a);}";

  var SSAOEffect = function (_Effect20) {
    _inherits(SSAOEffect, _Effect20);

    function SSAOEffect(camera, normalBuffer) {
      var _this45;

      var _ref25 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref25$blendFunction = _ref25.blendFunction,
          blendFunction = _ref25$blendFunction === void 0 ? BlendFunction.MULTIPLY : _ref25$blendFunction,
          _ref25$samples = _ref25.samples,
          samples = _ref25$samples === void 0 ? 11 : _ref25$samples,
          _ref25$rings = _ref25.rings,
          rings = _ref25$rings === void 0 ? 4 : _ref25$rings,
          _ref25$distanceThresh = _ref25.distanceThreshold,
          distanceThreshold = _ref25$distanceThresh === void 0 ? 0.97 : _ref25$distanceThresh,
          _ref25$distanceFallof = _ref25.distanceFalloff,
          distanceFalloff = _ref25$distanceFallof === void 0 ? 0.03 : _ref25$distanceFallof,
          _ref25$rangeThreshold = _ref25.rangeThreshold,
          rangeThreshold = _ref25$rangeThreshold === void 0 ? 0.0005 : _ref25$rangeThreshold,
          _ref25$rangeFalloff = _ref25.rangeFalloff,
          rangeFalloff = _ref25$rangeFalloff === void 0 ? 0.001 : _ref25$rangeFalloff,
          _ref25$luminanceInflu = _ref25.luminanceInfluence,
          luminanceInfluence = _ref25$luminanceInflu === void 0 ? 0.7 : _ref25$luminanceInflu,
          _ref25$radius = _ref25.radius,
          radius = _ref25$radius === void 0 ? 18.25 : _ref25$radius,
          _ref25$scale = _ref25.scale,
          scale = _ref25$scale === void 0 ? 1.0 : _ref25$scale,
          _ref25$bias = _ref25.bias,
          bias = _ref25$bias === void 0 ? 0.0 : _ref25$bias;

      _classCallCheck(this, SSAOEffect);

      _this45 = _possibleConstructorReturn(this, _getPrototypeOf(SSAOEffect).call(this, "SSAOEffect", fragmentShader$u, {
        blendFunction: blendFunction,
        attributes: EffectAttribute.DEPTH,
        defines: new Map([["RINGS_INT", "0"], ["SAMPLES_INT", "0"], ["SAMPLES_FLOAT", "0.0"]]),
        uniforms: new Map([["normalBuffer", new Uniform(normalBuffer)], ["cameraInverseProjectionMatrix", new Uniform(new Matrix4())], ["cameraProjectionMatrix", new Uniform(new Matrix4())], ["radiusStep", new Uniform(new Vector2())], ["distanceCutoff", new Uniform(new Vector2())], ["proximityCutoff", new Uniform(new Vector2())], ["seed", new Uniform(Math.random())], ["luminanceInfluence", new Uniform(luminanceInfluence)], ["scale", new Uniform(scale)], ["bias", new Uniform(bias)]])
      }));
      _this45.r = 0.0;
      _this45.resolution = new Vector2(1, 1);
      _this45.camera = camera;
      _this45.samples = samples;
      _this45.rings = rings;
      _this45.radius = radius;

      _this45.setDistanceCutoff(distanceThreshold, distanceFalloff);

      _this45.setProximityCutoff(rangeThreshold, rangeFalloff);

      return _this45;
    }

    _createClass(SSAOEffect, [{
      key: "updateAngleStep",
      value: function updateAngleStep() {
        this.defines.set("ANGLE_STEP", (Math.PI * 2.0 * this.rings / this.samples).toFixed(11));
      }
    }, {
      key: "updateRadiusStep",
      value: function updateRadiusStep() {
        var r = this.r / this.samples;
        this.uniforms.get("radiusStep").value.set(r, r).divide(this.resolution);
      }
    }, {
      key: "setDistanceCutoff",
      value: function setDistanceCutoff(threshold, falloff) {
        this.uniforms.get("distanceCutoff").value.set(Math.min(Math.max(threshold, 0.0), 1.0), Math.min(Math.max(threshold + falloff, 0.0), 1.0));
      }
    }, {
      key: "setProximityCutoff",
      value: function setProximityCutoff(threshold, falloff) {
        this.uniforms.get("proximityCutoff").value.set(Math.min(Math.max(threshold, 0.0), 1.0), Math.min(Math.max(threshold + falloff, 0.0), 1.0));
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.resolution.set(width, height);
        this.updateRadiusStep();
        this.uniforms.get("cameraInverseProjectionMatrix").value.getInverse(this.camera.projectionMatrix);
        this.uniforms.get("cameraProjectionMatrix").value.copy(this.camera.projectionMatrix);
      }
    }, {
      key: "samples",
      get: function get() {
        return Number(this.defines.get("SAMPLES_INT"));
      },
      set: function set(value) {
        value = Math.floor(value);
        this.defines.set("SAMPLES_INT", value.toFixed(0));
        this.defines.set("SAMPLES_FLOAT", value.toFixed(1));
        this.updateAngleStep();
        this.updateRadiusStep();
      }
    }, {
      key: "rings",
      get: function get() {
        return Number(this.defines.get("RINGS_INT"));
      },
      set: function set(value) {
        value = Math.floor(value);
        this.defines.set("RINGS_INT", value.toFixed(0));
        this.updateAngleStep();
      }
    }, {
      key: "radius",
      get: function get() {
        return this.r;
      },
      set: function set(value) {
        this.r = value;
        this.updateRadiusStep();
      }
    }]);

    return SSAOEffect;
  }(Effect);

  var vertexShader$a = "uniform float scale;varying vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=uv*vec2(aspect,1.0)*scale;}";

  var TextureEffect = function (_Effect21) {
    _inherits(TextureEffect, _Effect21);

    function TextureEffect() {
      var _this46;

      var _ref26 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref26$blendFunction = _ref26.blendFunction,
          blendFunction = _ref26$blendFunction === void 0 ? BlendFunction.NORMAL : _ref26$blendFunction,
          _ref26$texture = _ref26.texture,
          texture = _ref26$texture === void 0 ? null : _ref26$texture,
          _ref26$aspectCorrecti = _ref26.aspectCorrection,
          aspectCorrection = _ref26$aspectCorrecti === void 0 ? false : _ref26$aspectCorrecti;

      _classCallCheck(this, TextureEffect);

      _this46 = _possibleConstructorReturn(this, _getPrototypeOf(TextureEffect).call(this, "TextureEffect", fragmentShader$c, {
        blendFunction: blendFunction,
        uniforms: new Map([["texture", new Uniform(texture)]])
      }));
      _this46.aspectCorrection = aspectCorrection;
      return _this46;
    }

    _createClass(TextureEffect, [{
      key: "texture",
      get: function get() {
        return this.uniforms.get("texture").value;
      },
      set: function set(value) {
        this.uniforms.get("texture").value = value;
      }
    }, {
      key: "aspectCorrection",
      get: function get() {
        return this.defines.has("ASPECT_CORRECTION");
      },
      set: function set(value) {
        if (value) {
          this.defines.set("ASPECT_CORRECTION", "1");
          this.uniforms.set("scale", new Uniform(1.0));
          this.vertexShader = vertexShader$a;
        } else {
          this.defines["delete"]("ASPECT_CORRECTION");
          this.uniforms["delete"]("scale");
          this.vertexShader = null;
        }
      }
    }]);

    return TextureEffect;
  }(Effect);

  var fragmentShader$v = "uniform sampler2D luminanceMap;uniform float middleGrey;uniform float maxLuminance;uniform float averageLuminance;vec3 toneMap(vec3 c){\n#ifdef ADAPTED_LUMINANCE\nfloat lumAvg=texture2D(luminanceMap,vec2(0.5)).r;\n#else\nfloat lumAvg=averageLuminance;\n#endif\nfloat lumPixel=linearToRelativeLuminance(c);float lumScaled=(lumPixel*middleGrey)/lumAvg;float lumCompressed=(lumScaled*(1.0+(lumScaled/(maxLuminance*maxLuminance))))/(1.0+lumScaled);return lumCompressed*c;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(toneMap(inputColor.rgb),inputColor.a);}";

  var ToneMappingEffect = function (_Effect22) {
    _inherits(ToneMappingEffect, _Effect22);

    function ToneMappingEffect() {
      var _this47;

      var _ref27 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref27$blendFunction = _ref27.blendFunction,
          blendFunction = _ref27$blendFunction === void 0 ? BlendFunction.NORMAL : _ref27$blendFunction,
          _ref27$adaptive = _ref27.adaptive,
          adaptive = _ref27$adaptive === void 0 ? true : _ref27$adaptive,
          _ref27$resolution = _ref27.resolution,
          resolution = _ref27$resolution === void 0 ? 256 : _ref27$resolution,
          _ref27$middleGrey = _ref27.middleGrey,
          middleGrey = _ref27$middleGrey === void 0 ? 0.6 : _ref27$middleGrey,
          _ref27$maxLuminance = _ref27.maxLuminance,
          maxLuminance = _ref27$maxLuminance === void 0 ? 16.0 : _ref27$maxLuminance,
          _ref27$averageLuminan = _ref27.averageLuminance,
          averageLuminance = _ref27$averageLuminan === void 0 ? 1.0 : _ref27$averageLuminan,
          _ref27$adaptationRate = _ref27.adaptationRate,
          adaptationRate = _ref27$adaptationRate === void 0 ? 2.0 : _ref27$adaptationRate;

      _classCallCheck(this, ToneMappingEffect);

      _this47 = _possibleConstructorReturn(this, _getPrototypeOf(ToneMappingEffect).call(this, "ToneMappingEffect", fragmentShader$v, {
        blendFunction: blendFunction,
        uniforms: new Map([["luminanceMap", new Uniform(null)], ["middleGrey", new Uniform(middleGrey)], ["maxLuminance", new Uniform(maxLuminance)], ["averageLuminance", new Uniform(averageLuminance)]])
      }));
      _this47.renderTargetLuminance = new WebGLRenderTarget(1, 1, {
        minFilter: LinearMipmapLinearFilter,
        magFilter: LinearFilter,
        stencilBuffer: false,
        depthBuffer: false,
        format: RGBFormat
      });
      _this47.renderTargetLuminance.texture.name = "ToneMapping.Luminance";
      _this47.renderTargetLuminance.texture.generateMipmaps = true;
      _this47.renderTargetAdapted = _this47.renderTargetLuminance.clone();
      _this47.renderTargetAdapted.texture.name = "ToneMapping.AdaptedLuminance";
      _this47.renderTargetAdapted.texture.generateMipmaps = false;
      _this47.renderTargetAdapted.texture.minFilter = LinearFilter;
      _this47.renderTargetPrevious = _this47.renderTargetAdapted.clone();
      _this47.renderTargetPrevious.texture.name = "ToneMapping.PreviousLuminance";
      _this47.savePass = new SavePass(_this47.renderTargetPrevious, false);
      _this47.luminancePass = new ShaderPass(new LuminanceMaterial());

      var luminanceMaterial = _this47.luminancePass.getFullscreenMaterial();

      luminanceMaterial.useThreshold = false;
      _this47.adaptiveLuminancePass = new ShaderPass(new AdaptiveLuminanceMaterial());

      var uniforms = _this47.adaptiveLuminancePass.getFullscreenMaterial().uniforms;

      uniforms.previousLuminanceBuffer.value = _this47.renderTargetPrevious.texture;
      uniforms.currentLuminanceBuffer.value = _this47.renderTargetLuminance.texture;
      _this47.adaptationRate = adaptationRate;
      _this47.resolution = resolution;
      _this47.adaptive = adaptive;
      return _this47;
    }

    _createClass(ToneMappingEffect, [{
      key: "update",
      value: function update(renderer, inputBuffer, deltaTime) {
        if (this.adaptive) {
          this.luminancePass.render(renderer, inputBuffer, this.renderTargetLuminance);
          var uniforms = this.adaptiveLuminancePass.getFullscreenMaterial().uniforms;
          uniforms.deltaTime.value = deltaTime;
          this.adaptiveLuminancePass.render(renderer, null, this.renderTargetAdapted);
          this.savePass.render(renderer, this.renderTargetAdapted);
        }
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.savePass.setSize(width, height);
      }
    }, {
      key: "initialize",
      value: function initialize(renderer, alpha, frameBufferType) {
        var clearPass = new ClearPass(true, false, false);
        clearPass.overrideClearColor = new Color(0x7fffff);
        clearPass.render(renderer, this.renderTargetPrevious);
        clearPass.dispose();
      }
    }, {
      key: "resolution",
      get: function get() {
        return this.renderTargetLuminance.width;
      },
      set: function set(value) {
        var exponent = Math.max(0, Math.ceil(Math.log2(value)));
        value = Math.pow(2, exponent);
        this.renderTargetLuminance.setSize(value, value);
        this.renderTargetPrevious.setSize(value, value);
        this.renderTargetAdapted.setSize(value, value);
        this.adaptiveLuminancePass.getFullscreenMaterial().defines.MIP_LEVEL_1X1 = exponent.toFixed(1);
      }
    }, {
      key: "adaptive",
      get: function get() {
        return this.defines.has("ADAPTED_LUMINANCE");
      },
      set: function set(value) {
        if (value) {
          this.defines.set("ADAPTED_LUMINANCE", "1");
          this.uniforms.get("luminanceMap").value = this.renderTargetAdapted.texture;
        } else {
          this.defines["delete"]("ADAPTED_LUMINANCE");
          this.uniforms.get("luminanceMap").value = null;
        }
      }
    }, {
      key: "adaptationRate",
      get: function get() {
        return this.adaptiveLuminancePass.getFullscreenMaterial().uniforms.tau.value;
      },
      set: function set(value) {
        this.adaptiveLuminancePass.getFullscreenMaterial().uniforms.tau.value = value;
      }
    }, {
      key: "distinction",
      get: function get() {
        console.warn(this.name, "The distinction field has been removed.");
        return 1.0;
      },
      set: function set(value) {
        console.warn(this.name, "The distinction field has been removed.");
      }
    }]);

    return ToneMappingEffect;
  }(Effect);

  var fragmentShader$w = "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#ifdef ESKIL\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#else\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#endif\noutputColor=vec4(color,inputColor.a);}";

  var VignetteEffect = function (_Effect23) {
    _inherits(VignetteEffect, _Effect23);

    function VignetteEffect() {
      var _this48;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, VignetteEffect);

      var settings = Object.assign({
        blendFunction: BlendFunction.NORMAL,
        eskil: false,
        offset: 0.5,
        darkness: 0.5
      }, options);
      _this48 = _possibleConstructorReturn(this, _getPrototypeOf(VignetteEffect).call(this, "VignetteEffect", fragmentShader$w, {
        blendFunction: settings.blendFunction,
        uniforms: new Map([["offset", new Uniform(settings.offset)], ["darkness", new Uniform(settings.darkness)]])
      }));
      _this48.eskil = settings.eskil;
      return _this48;
    }

    _createClass(VignetteEffect, [{
      key: "eskil",
      get: function get() {
        return this.defines.has("ESKIL");
      },
      set: function set(value) {
        value ? this.defines.set("ESKIL", "1") : this.defines["delete"]("ESKIL");
      }
    }]);

    return VignetteEffect;
  }(Effect);

  function createCanvas(width, height, data) {
    var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    var context = canvas.getContext("2d");
    var imageData = context.createImageData(width, height);
    imageData.data.set(data);
    canvas.width = width;
    canvas.height = height;
    context.putImageData(imageData, 0, 0);
    return canvas;
  }

  var RawImageData = function () {
    function RawImageData() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      _classCallCheck(this, RawImageData);

      this.width = width;
      this.height = height;
      this.data = data;
    }

    _createClass(RawImageData, [{
      key: "toCanvas",
      value: function toCanvas() {
        return typeof document === "undefined" ? null : createCanvas(this.width, this.height, this.data);
      }
    }], [{
      key: "from",
      value: function from(data) {
        return new RawImageData(data.width, data.height, data.data);
      }
    }]);

    return RawImageData;
  }();

  var workerProgram = "!function(){\"use strict\";function e(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function t(e,t){for(var a=0;a<t.length;a++){var n=t[a];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function a(e,a,n){return a&&t(e.prototype,a),n&&t(e,n),e}var n=function(){function t(){var a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;e(this,t),this.width=a,this.height=n,this.data=s}return a(t,[{key:\"toCanvas\",value:function(){return\"undefined\"==typeof document?null:(e=this.width,t=this.height,a=this.data,n=document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"canvas\"),s=n.getContext(\"2d\"),(r=s.createImageData(e,t)).data.set(a),n.width=e,n.height=t,s.putImageData(r,0,0),n);var e,t,a,n,s,r}}],[{key:\"from\",value:function(e){return new t(e.width,e.height,e.data)}}]),t}(),s=function(){function t(){var a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;e(this,t),this.x=a,this.y=n}return a(t,[{key:\"set\",value:function(e,t){return this.x=e,this.y=t,this}},{key:\"equals\",value:function(e){return this===e||this.x===e.x&&this.y===e.y}}]),t}(),r=function t(){e(this,t),this.min=new s,this.max=new s},i=new r,y=new r,c=new Float32Array([0,-.25,.25,-.125,.125,-.375,.375]),u=[new Float32Array([0,0]),new Float32Array([.25,-.25]),new Float32Array([-.25,.25]),new Float32Array([.125,-.125]),new Float32Array([-.125,.125])],h=[new Uint8Array([0,0]),new Uint8Array([3,0]),new Uint8Array([0,3]),new Uint8Array([3,3]),new Uint8Array([1,0]),new Uint8Array([4,0]),new Uint8Array([1,3]),new Uint8Array([4,3]),new Uint8Array([0,1]),new Uint8Array([3,1]),new Uint8Array([0,4]),new Uint8Array([3,4]),new Uint8Array([1,1]),new Uint8Array([4,1]),new Uint8Array([1,4]),new Uint8Array([4,4])],o=[new Uint8Array([0,0]),new Uint8Array([1,0]),new Uint8Array([0,2]),new Uint8Array([1,2]),new Uint8Array([2,0]),new Uint8Array([3,0]),new Uint8Array([2,2]),new Uint8Array([3,2]),new Uint8Array([0,1]),new Uint8Array([1,1]),new Uint8Array([0,3]),new Uint8Array([1,3]),new Uint8Array([2,1]),new Uint8Array([3,1]),new Uint8Array([2,3]),new Uint8Array([3,3])];function w(e,t,a){return e+(t-e)*a}function x(e,t){var a,n=t.min,s=t.max,r=.5*Math.sqrt(2*n.x),i=.5*Math.sqrt(2*n.y),y=.5*Math.sqrt(2*s.x),c=.5*Math.sqrt(2*s.y),u=(a=e/32,Math.min(Math.max(a,0),1));return n.set(w(r,n.x,u),w(i,n.y,u)),s.set(w(y,s.x,u),w(c,s.y,u)),t}function f(e,t,a,n){var s,r,i,y,c=t.x-e.x,u=t.y-e.y,h=a,o=a+1,w=e.y+u*(h-e.x)/c,x=e.y+u*(o-e.x)/c;return h>=e.x&&h<t.x||o>e.x&&o<=t.x?Math.sign(w)===Math.sign(x)||Math.abs(w)<1e-4||Math.abs(x)<1e-4?(s=(w+x)/2)<0?n.set(Math.abs(s),0):n.set(0,Math.abs(s)):(r=(y=-e.y*c/u+e.x)>e.x?w*(y-Math.trunc(y))/2:0,i=y<t.x?x*(1-(y-Math.trunc(y)))/2:0,(s=Math.abs(r)>Math.abs(i)?r:-i)<0?n.set(Math.abs(r),Math.abs(i)):n.set(Math.abs(i),Math.abs(r))):n.set(0,0),n}function l(e,t,a,n,s){var r=i.min,c=i.max,u=y.min,h=y.max,o=y,w=.5+n,l=.5+n-1,b=t+a+1;switch(e){case 0:s.set(0,0);break;case 1:t<=a?f(r.set(0,l),c.set(b/2,0),t,s):s.set(0,0);break;case 2:t>=a?f(r.set(b/2,0),c.set(b,l),t,s):s.set(0,0);break;case 3:f(r.set(0,l),c.set(b/2,0),t,u),f(r.set(b/2,0),c.set(b,l),t,h),x(b,o),s.set(u.x+h.x,u.y+h.y);break;case 4:t<=a?f(r.set(0,w),c.set(b/2,0),t,s):s.set(0,0);break;case 5:s.set(0,0);break;case 6:Math.abs(n)>0?(f(r.set(0,w),c.set(b,l),t,u),f(r.set(0,w),c.set(b/2,0),t,h),f(r.set(b/2,0),c.set(b,l),t,s),h.set(h.x+s.x,h.y+s.y),s.set((u.x+h.x)/2,(u.y+h.y)/2)):f(r.set(0,w),c.set(b,l),t,s);break;case 7:f(r.set(0,w),c.set(b,l),t,s);break;case 8:t>=a?f(r.set(b/2,0),c.set(b,w),t,s):s.set(0,0);break;case 9:Math.abs(n)>0?(f(r.set(0,l),c.set(b,w),t,u),f(r.set(0,l),c.set(b/2,0),t,h),f(r.set(b/2,0),c.set(b,w),t,s),h.set(h.x+s.x,h.y+s.y),s.set((u.x+h.x)/2,(u.y+h.y)/2)):f(r.set(0,l),c.set(b,w),t,s);break;case 10:s.set(0,0);break;case 11:f(r.set(0,l),c.set(b,w),t,s);break;case 12:f(r.set(0,w),c.set(b/2,0),t,u),f(r.set(b/2,0),c.set(b,w),t,h),x(b,o),s.set(u.x+h.x,u.y+h.y);break;case 13:f(r.set(0,l),c.set(b,w),t,s);break;case 14:f(r.set(0,w),c.set(b,l),t,s);break;case 15:s.set(0,0)}return s}function b(e,t,a,n){var s=e.equals(t);if(!s){var r=(e.x+t.x)/2,i=(e.y+t.y)/2;s=(t.y-e.y)*(a-r)+(e.x-t.x)*(n-i)>0}return s}function A(e,t,a,n){var s,r,i;for(s=0,i=0;i<30;++i)for(r=0;r<30;++r)b(e,t,a+r/29,n+i/29)&&++s;return s/900}function v(e,t,a,n,s,r){var i=o[e],y=i[0],c=i[1];return y>0&&(t.x+=s[0],t.y+=s[1]),c>0&&(a.x+=s[0],a.y+=s[1]),r.set(1-A(t,a,1+n,0+n),A(t,a,1+n,1+n))}function k(e,t,a,n,s){var r=i.min,c=i.max,u=y.min,h=y.max,o=t+a+1;switch(e){case 0:v(e,r.set(1,1),c.set(1+o,1+o),t,n,u),v(e,r.set(1,0),c.set(1+o,0+o),t,n,h),s.set((u.x+h.x)/2,(u.y+h.y)/2);break;case 1:v(e,r.set(1,0),c.set(0+o,0+o),t,n,u),v(e,r.set(1,0),c.set(1+o,0+o),t,n,h),s.set((u.x+h.x)/2,(u.y+h.y)/2);break;case 2:v(e,r.set(0,0),c.set(1+o,0+o),t,n,u),v(e,r.set(1,0),c.set(1+o,0+o),t,n,h),s.set((u.x+h.x)/2,(u.y+h.y)/2);break;case 3:v(e,r.set(1,0),c.set(1+o,0+o),t,n,s);break;case 4:v(e,r.set(1,1),c.set(0+o,0+o),t,n,u),v(e,r.set(1,1),c.set(1+o,0+o),t,n,h),s.set((u.x+h.x)/2,(u.y+h.y)/2);break;case 5:v(e,r.set(1,1),c.set(0+o,0+o),t,n,u),v(e,r.set(1,0),c.set(1+o,0+o),t,n,h),s.set((u.x+h.x)/2,(u.y+h.y)/2);break;case 6:v(e,r.set(1,1),c.set(1+o,0+o),t,n,s);break;case 7:v(e,r.set(1,1),c.set(1+o,0+o),t,n,u),v(e,r.set(1,0),c.set(1+o,0+o),t,n,h),s.set((u.x+h.x)/2,(u.y+h.y)/2);break;case 8:v(e,r.set(0,0),c.set(1+o,1+o),t,n,u),v(e,r.set(1,0),c.set(1+o,1+o),t,n,h),s.set((u.x+h.x)/2,(u.y+h.y)/2);break;case 9:v(e,r.set(1,0),c.set(1+o,1+o),t,n,s);break;case 10:v(e,r.set(0,0),c.set(1+o,1+o),t,n,u),v(e,r.set(1,0),c.set(1+o,0+o),t,n,h),s.set((u.x+h.x)/2,(u.y+h.y)/2);break;case 11:v(e,r.set(1,0),c.set(1+o,1+o),t,n,u),v(e,r.set(1,0),c.set(1+o,0+o),t,n,h),s.set((u.x+h.x)/2,(u.y+h.y)/2);break;case 12:v(e,r.set(1,1),c.set(1+o,1+o),t,n,s);break;case 13:v(e,r.set(1,1),c.set(1+o,1+o),t,n,u),v(e,r.set(1,0),c.set(1+o,1+o),t,n,h),s.set((u.x+h.x)/2,(u.y+h.y)/2);break;case 14:v(e,r.set(1,1),c.set(1+o,1+o),t,n,u),v(e,r.set(1,1),c.set(1+o,0+o),t,n,h),s.set((u.x+h.x)/2,(u.y+h.y)/2);break;case 15:v(e,r.set(1,1),c.set(1+o,1+o),t,n,u),v(e,r.set(1,0),c.set(1+o,0+o),t,n,h),s.set((u.x+h.x)/2,(u.y+h.y)/2)}return s}function U(e,t,a){var n,r,i,y,c,u,h,o,w=new s;for(n=0,r=e.length;n<r;++n)for(h=(u=e[n]).data,o=u.width,y=0;y<o;++y)for(i=0;i<o;++i)a?l(n,i,y,t,w):k(n,i,y,t,w),h[c=2*(y*o+i)]=255*w.x,h[c+1]=255*w.y}function d(e,t,a,n,r,i){var y,c,u,h,o,w,x,f,l,b,A=new s,v=i.data,k=i.width;for(y=0,c=t.length;y<c;++y)for(x=a[y],l=(f=t[y]).data,b=f.width,h=0;h<n;++h)for(u=0;u<n;++u)A.set(x[0]*n+e.x+u,x[1]*n+e.y+h),w=r?2*(h*h*b+u*u):2*(h*b+u),v[o=4*(A.y*k+A.x)]=l[w],v[o+1]=l[w+1],v[o+2]=0,v[o+3]=255}var g=function(){function t(){e(this,t)}return a(t,null,[{key:\"generate\",value:function(){var e,t,a=5*c.length*16,r=new Uint8ClampedArray(160*a*4),i=new n(160,a,r),y=Math.pow(15,2)+1,w=[],x=[],f=new s;for(e=0;e<16;++e)w.push(new n(y,y,new Uint8ClampedArray(y*y*2),2)),x.push(new n(20,20,new Uint8ClampedArray(800),2));for(e=0,t=c.length;e<t;++e)U(w,c[e],!0),f.set(0,80*e),d(f,w,h,16,!0,i);for(e=0,t=u.length;e<t;++e)U(x,u[e],!1),f.set(80,80*e),d(f,x,o,20,!1,i);return i}}]),t}(),m=new Map([[p([0,0,0,0]),[0,0,0,0]],[p([0,0,0,1]),[0,0,0,1]],[p([0,0,1,0]),[0,0,1,0]],[p([0,0,1,1]),[0,0,1,1]],[p([0,1,0,0]),[0,1,0,0]],[p([0,1,0,1]),[0,1,0,1]],[p([0,1,1,0]),[0,1,1,0]],[p([0,1,1,1]),[0,1,1,1]],[p([1,0,0,0]),[1,0,0,0]],[p([1,0,0,1]),[1,0,0,1]],[p([1,0,1,0]),[1,0,1,0]],[p([1,0,1,1]),[1,0,1,1]],[p([1,1,0,0]),[1,1,0,0]],[p([1,1,0,1]),[1,1,0,1]],[p([1,1,1,0]),[1,1,1,0]],[p([1,1,1,1]),[1,1,1,1]]]);function M(e,t,a){return e+(t-e)*a}function p(e){var t=M(e[0],e[1],.75),a=M(e[2],e[3],.75);return M(t,a,.875)}function C(e,t){var a=0;return 1===t[3]&&1!==e[1]&&1!==e[3]&&(a+=1),1===a&&1===t[2]&&1!==e[0]&&1!==e[2]&&(a+=1),a}var q=function(){function t(){e(this,t)}return a(t,null,[{key:\"generate\",value:function(){var e,t,a,s,r,i,y,c,u,h,o=new Uint8ClampedArray(2178),w=new Uint8ClampedArray(4096);for(t=0;t<33;++t)for(e=0;e<66;++e)a=.03125*e,s=.03125*t,m.has(a)&&m.has(s)&&(i=m.get(a),y=m.get(s),o[r=66*t+e]=127*(c=i,h=void 0,h=0,1===(u=y)[3]&&(h+=1),1===h&&1===u[2]&&1!==c[1]&&1!==c[3]&&(h+=1),h),o[r+33]=127*C(i,y));for(r=0,t=17;t<33;++t)for(e=0;e<64;++e,r+=4)w[r]=o[66*t+e],w[r+3]=255;return new n(64,16,w)}}]),t}();self.addEventListener(\"message\",(function(e){var t=g.generate(),a=q.generate();postMessage({areaImageData:t,searchImageData:a},[t.data.buffer,a.data.buffer]),close()}))}();\n";

  function generate() {
    var disableCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var workerURL = URL.createObjectURL(new Blob([workerProgram], {
      type: "text/javascript"
    }));
    var worker = new Worker(workerURL);
    return new Promise(function (resolve, reject) {
      worker.addEventListener("error", function (event) {
        return reject(event.error);
      });
      worker.addEventListener("message", function (event) {
        var searchImageData = RawImageData.from(event.data.searchImageData);
        var areaImageData = RawImageData.from(event.data.areaImageData);
        var urls = [searchImageData.toCanvas().toDataURL(), areaImageData.toCanvas().toDataURL()];

        if (!disableCache && window.localStorage !== undefined) {
          localStorage.setItem("smaa-search", urls[0]);
          localStorage.setItem("smaa-area", urls[1]);
        }

        URL.revokeObjectURL(workerURL);
        resolve(urls);
      });
      worker.postMessage(null);
    });
  }

  var SMAAImageLoader = function (_Loader) {
    _inherits(SMAAImageLoader, _Loader);

    function SMAAImageLoader(manager) {
      var _this49;

      _classCallCheck(this, SMAAImageLoader);

      _this49 = _possibleConstructorReturn(this, _getPrototypeOf(SMAAImageLoader).call(this, manager));
      _this49.disableCache = false;
      return _this49;
    }

    _createClass(SMAAImageLoader, [{
      key: "load",
      value: function load() {
        var _this50 = this;

        var onLoad = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
        var onError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

        if (arguments.length === 4) {
          onLoad = arguments[1];
          onError = arguments[3];
        } else if (arguments.length === 3 || typeof arguments[0] !== "function") {
          onLoad = arguments[1];

          onError = function onError() {};
        }

        var externalManager = this.manager;
        var internalManager = new LoadingManager();
        externalManager.itemStart("smaa-search");
        externalManager.itemStart("smaa-area");
        internalManager.itemStart("smaa-search");
        internalManager.itemStart("smaa-area");
        return new Promise(function (resolve, reject) {
          var cachedURLs = !_this50.disableCache && window.localStorage !== undefined ? [localStorage.getItem("smaa-search"), localStorage.getItem("smaa-area")] : [null, null];
          var promise = cachedURLs[0] !== null && cachedURLs[1] !== null ? Promise.resolve(cachedURLs) : generate(_this50.disableCache);
          promise.then(function (urls) {
            var result = [new Image(), new Image()];

            internalManager.onLoad = function () {
              onLoad(result);
              resolve(result);
            };

            result[0].addEventListener("load", function () {
              externalManager.itemEnd("smaa-search");
              internalManager.itemEnd("smaa-search");
            });
            result[1].addEventListener("load", function () {
              externalManager.itemEnd("smaa-area");
              internalManager.itemEnd("smaa-area");
            });
            result[0].src = urls[0];
            result[1].src = urls[1];
          })["catch"](function (error) {
            externalManager.itemError("smaa-search");
            externalManager.itemError("smaa-area");
            onError(error);
            reject(error);
          });
        });
      }
    }]);

    return SMAAImageLoader;
  }(Loader);
  /**
   * math-ds v1.1.4 build Thu Jan 23 2020
   * https://github.com/vanruesc/math-ds
   * Copyright 2020 Raoul van Rschen
   * @license Zlib
   */


  var Vector3$1 = function () {
    function Vector3$1() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      _classCallCheck(this, Vector3$1);

      this.x = x;
      this.y = y;
      this.z = z;
    }

    _createClass(Vector3$1, [{
      key: "set",
      value: function set(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      }
    }, {
      key: "copy",
      value: function copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
      }
    }, {
      key: "setFromSpherical",
      value: function setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
      }
    }, {
      key: "setFromSphericalCoords",
      value: function setFromSphericalCoords(radius, phi, theta) {
        var sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
      }
    }, {
      key: "setFromCylindrical",
      value: function setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
      }
    }, {
      key: "setFromCylindricalCoords",
      value: function setFromCylindricalCoords(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
      }
    }, {
      key: "setFromMatrix3Column",
      value: function setFromMatrix3Column(m, index) {
        return this.fromArray(m.elements, index * 3);
      }
    }, {
      key: "setFromMatrixColumn",
      value: function setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
      }
    }, {
      key: "setFromMatrixPosition",
      value: function setFromMatrixPosition(m) {
        var me = m.elements;
        this.x = me[12];
        this.y = me[13];
        this.z = me[14];
        return this;
      }
    }, {
      key: "setFromMatrixScale",
      value: function setFromMatrixScale(m) {
        var sx = this.setFromMatrixColumn(m, 0).length();
        var sy = this.setFromMatrixColumn(m, 1).length();
        var sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      }
    }, {
      key: "add",
      value: function add(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      }
    }, {
      key: "addScalar",
      value: function addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
      }
    }, {
      key: "addVectors",
      value: function addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
      }
    }, {
      key: "addScaledVector",
      value: function addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
      }
    }, {
      key: "sub",
      value: function sub(v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      }
    }, {
      key: "subScalar",
      value: function subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
      }
    }, {
      key: "subVectors",
      value: function subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
      }
    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        this.x *= s;
        this.y *= s;
        this.z *= s;
        return this;
      }
    }, {
      key: "multiplyVectors",
      value: function multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
      }
    }, {
      key: "divide",
      value: function divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
      }
    }, {
      key: "divideScalar",
      value: function divideScalar(s) {
        this.x /= s;
        this.y /= s;
        this.z /= s;
        return this;
      }
    }, {
      key: "crossVectors",
      value: function crossVectors(a, b) {
        var ax = a.x,
            ay = a.y,
            az = a.z;
        var bx = b.x,
            by = b.y,
            bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      }
    }, {
      key: "cross",
      value: function cross(v) {
        return this.crossVectors(this, v);
      }
    }, {
      key: "transformDirection",
      value: function transformDirection(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
      }
    }, {
      key: "applyMatrix3",
      value: function applyMatrix3(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
      }
    }, {
      key: "applyNormalMatrix",
      value: function applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
      }
    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        return this;
      }
    }, {
      key: "applyQuaternion",
      value: function applyQuaternion(q) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var qx = q.x,
            qy = q.y,
            qz = q.z,
            qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
      }
    }, {
      key: "negate",
      value: function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      }
    }, {
      key: "dot",
      value: function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      }
    }, {
      key: "reflect",
      value: function reflect(n) {
        var nx = n.x;
        var ny = n.y;
        var nz = n.z;
        this.sub(n.multiplyScalar(2 * this.dot(n)));
        n.set(nx, ny, nz);
        return this;
      }
    }, {
      key: "angleTo",
      value: function angleTo(v) {
        var theta = this.dot(v) / Math.sqrt(this.lengthSquared() * v.lengthSquared());
        return Math.acos(Math.min(Math.max(theta, -1), 1));
      }
    }, {
      key: "manhattanLength",
      value: function manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
    }, {
      key: "lengthSquared",
      value: function lengthSquared() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
    }, {
      key: "length",
      value: function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
    }, {
      key: "manhattanDistanceTo",
      value: function manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
      }
    }, {
      key: "distanceToSquared",
      value: function distanceToSquared(v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
      }
    }, {
      key: "distanceTo",
      value: function distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
    }, {
      key: "normalize",
      value: function normalize() {
        return this.divideScalar(this.length());
      }
    }, {
      key: "setLength",
      value: function setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
    }, {
      key: "min",
      value: function min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
      }
    }, {
      key: "max",
      value: function max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
      }
    }, {
      key: "clamp",
      value: function clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
      }
    }, {
      key: "floor",
      value: function floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      }
    }, {
      key: "ceil",
      value: function ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      }
    }, {
      key: "round",
      value: function round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      }
    }, {
      key: "lerp",
      value: function lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
      }
    }, {
      key: "lerpVectors",
      value: function lerpVectors(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
      }
    }, {
      key: "equals",
      value: function equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
      }
    }]);

    return Vector3$1;
  }();

  var Vector2$1 = function () {
    function Vector2$1() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      _classCallCheck(this, Vector2$1);

      this.x = x;
      this.y = y;
    }

    _createClass(Vector2$1, [{
      key: "set",
      value: function set(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "copy",
      value: function copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor(this.x, this.y);
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
      }
    }, {
      key: "add",
      value: function add(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
      }
    }, {
      key: "addScalar",
      value: function addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
      }
    }, {
      key: "addVectors",
      value: function addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      }
    }, {
      key: "addScaledVector",
      value: function addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
      }
    }, {
      key: "sub",
      value: function sub(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
      }
    }, {
      key: "subScalar",
      value: function subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
      }
    }, {
      key: "subVectors",
      value: function subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      }
    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        this.x *= s;
        this.y *= s;
        return this;
      }
    }, {
      key: "divide",
      value: function divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      }
    }, {
      key: "divideScalar",
      value: function divideScalar(s) {
        this.x /= s;
        this.y /= s;
        return this;
      }
    }, {
      key: "applyMatrix3",
      value: function applyMatrix3(m) {
        var x = this.x,
            y = this.y;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6];
        this.y = e[1] * x + e[4] * y + e[7];
        return this;
      }
    }, {
      key: "dot",
      value: function dot(v) {
        return this.x * v.x + this.y * v.y;
      }
    }, {
      key: "cross",
      value: function cross(v) {
        return this.x * v.y - this.y * v.x;
      }
    }, {
      key: "manhattanLength",
      value: function manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
    }, {
      key: "lengthSquared",
      value: function lengthSquared() {
        return this.x * this.x + this.y * this.y;
      }
    }, {
      key: "length",
      value: function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
    }, {
      key: "manhattanDistanceTo",
      value: function manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
      }
    }, {
      key: "distanceToSquared",
      value: function distanceToSquared(v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        return dx * dx + dy * dy;
      }
    }, {
      key: "distanceTo",
      value: function distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
    }, {
      key: "normalize",
      value: function normalize() {
        return this.divideScalar(this.length());
      }
    }, {
      key: "setLength",
      value: function setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
    }, {
      key: "min",
      value: function min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
      }
    }, {
      key: "max",
      value: function max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
      }
    }, {
      key: "clamp",
      value: function clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
      }
    }, {
      key: "floor",
      value: function floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      }
    }, {
      key: "ceil",
      value: function ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      }
    }, {
      key: "round",
      value: function round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      }
    }, {
      key: "negate",
      value: function negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      }
    }, {
      key: "angle",
      value: function angle() {
        var angle = Math.atan2(this.y, this.x);

        if (angle < 0) {
          angle += 2 * Math.PI;
        }

        return angle;
      }
    }, {
      key: "lerp",
      value: function lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      }
    }, {
      key: "lerpVectors",
      value: function lerpVectors(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
      }
    }, {
      key: "rotateAround",
      value: function rotateAround(center, angle) {
        var c = Math.cos(angle),
            s = Math.sin(angle);
        var x = this.x - center.x;
        var y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
      }
    }, {
      key: "equals",
      value: function equals(v) {
        return v.x === this.x && v.y === this.y;
      }
    }, {
      key: "width",
      get: function get() {
        return this.x;
      },
      set: function set(value) {
        return this.x = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this.y;
      },
      set: function set(value) {
        return this.y = value;
      }
    }]);

    return Vector2$1;
  }();

  var RotationOrder = {
    XYZ: "XYZ",
    YZX: "YZX",
    ZXY: "ZXY",
    XZY: "XZY",
    YXZ: "YXZ",
    ZYX: "ZYX"
  };
  var a$2 = new Vector3$1();
  var b$2 = new Vector3$1();
  var c = new Vector3$1();

  var Matrix4$1 = function () {
    function Matrix4$1() {
      _classCallCheck(this, Matrix4$1);

      this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    }

    _createClass(Matrix4$1, [{
      key: "set",
      value: function set(n00, n01, n02, n03, n10, n11, n12, n13, n20, n21, n22, n23, n30, n31, n32, n33) {
        var te = this.elements;
        te[0] = n00;
        te[4] = n01;
        te[8] = n02;
        te[12] = n03;
        te[1] = n10;
        te[5] = n11;
        te[9] = n12;
        te[13] = n13;
        te[2] = n20;
        te[6] = n21;
        te[10] = n22;
        te[14] = n23;
        te[3] = n30;
        te[7] = n31;
        te[11] = n32;
        te[15] = n33;
        return this;
      }
    }, {
      key: "identity",
      value: function identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "copy",
      value: function copy(matrix) {
        var me = matrix.elements;
        var te = this.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().fromArray(this.elements);
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var te = this.elements;
        var i;

        for (i = 0; i < 16; ++i) {
          te[i] = array[i + offset];
        }

        return this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var te = this.elements;
        var i;

        for (i = 0; i < 16; ++i) {
          array[i + offset] = te[i];
        }

        return array;
      }
    }, {
      key: "getMaxScaleOnAxis",
      value: function getMaxScaleOnAxis() {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      }
    }, {
      key: "copyPosition",
      value: function copyPosition(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
      }
    }, {
      key: "setPosition",
      value: function setPosition(p) {
        var te = this.elements;
        te[12] = p.x;
        te[13] = p.y;
        te[14] = p.z;
        return this;
      }
    }, {
      key: "extractBasis",
      value: function extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
      }
    }, {
      key: "makeBasis",
      value: function makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "extractRotation",
      value: function extractRotation(m) {
        var te = this.elements;
        var me = m.elements;
        var scaleX = 1.0 / a$2.setFromMatrixColumn(m, 0).length();
        var scaleY = 1.0 / a$2.setFromMatrixColumn(m, 1).length();
        var scaleZ = 1.0 / a$2.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      }
    }, {
      key: "makeRotationFromEuler",
      value: function makeRotationFromEuler(euler) {
        var te = this.elements;
        var x = euler.x;
        var y = euler.y;
        var z = euler.z;
        var a = Math.cos(x),
            b = Math.sin(x);
        var c = Math.cos(y),
            d = Math.sin(y);
        var e = Math.cos(z),
            f = Math.sin(z);
        var ae, af, be, bf;
        var ce, cf, de, df;
        var ac, ad, bc, bd;

        switch (euler.order) {
          case RotationOrder.XYZ:
            {
              ae = a * e, af = a * f, be = b * e, bf = b * f;
              te[0] = c * e;
              te[4] = -c * f;
              te[8] = d;
              te[1] = af + be * d;
              te[5] = ae - bf * d;
              te[9] = -b * c;
              te[2] = bf - ae * d;
              te[6] = be + af * d;
              te[10] = a * c;
              break;
            }

          case RotationOrder.YXZ:
            {
              ce = c * e, cf = c * f, de = d * e, df = d * f;
              te[0] = ce + df * b;
              te[4] = de * b - cf;
              te[8] = a * d;
              te[1] = a * f;
              te[5] = a * e;
              te[9] = -b;
              te[2] = cf * b - de;
              te[6] = df + ce * b;
              te[10] = a * c;
              break;
            }

          case RotationOrder.ZXY:
            {
              ce = c * e, cf = c * f, de = d * e, df = d * f;
              te[0] = ce - df * b;
              te[4] = -a * f;
              te[8] = de + cf * b;
              te[1] = cf + de * b;
              te[5] = a * e;
              te[9] = df - ce * b;
              te[2] = -a * d;
              te[6] = b;
              te[10] = a * c;
              break;
            }

          case RotationOrder.ZYX:
            {
              ae = a * e, af = a * f, be = b * e, bf = b * f;
              te[0] = c * e;
              te[4] = be * d - af;
              te[8] = ae * d + bf;
              te[1] = c * f;
              te[5] = bf * d + ae;
              te[9] = af * d - be;
              te[2] = -d;
              te[6] = b * c;
              te[10] = a * c;
              break;
            }

          case RotationOrder.YZX:
            {
              ac = a * c, ad = a * d, bc = b * c, bd = b * d;
              te[0] = c * e;
              te[4] = bd - ac * f;
              te[8] = bc * f + ad;
              te[1] = f;
              te[5] = a * e;
              te[9] = -b * e;
              te[2] = -d * e;
              te[6] = ad * f + bc;
              te[10] = ac - bd * f;
              break;
            }

          case RotationOrder.XZY:
            {
              ac = a * c, ad = a * d, bc = b * c, bd = b * d;
              te[0] = c * e;
              te[4] = -f;
              te[8] = d * e;
              te[1] = ac * f + bd;
              te[5] = a * e;
              te[9] = ad * f - bc;
              te[2] = bc * f - ad;
              te[6] = b * e;
              te[10] = bd * f + ac;
              break;
            }
        }

        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      }
    }, {
      key: "makeRotationFromQuaternion",
      value: function makeRotationFromQuaternion(q) {
        return this.compose(a$2.set(0, 0, 0), q, b$2.set(1, 1, 1));
      }
    }, {
      key: "lookAt",
      value: function lookAt(eye, target, up) {
        var te = this.elements;
        var x = a$2,
            y = b$2,
            z = c;
        z.subVectors(eye, target);

        if (z.lengthSquared() === 0) {
          z.z = 1;
        }

        z.normalize();
        x.crossVectors(up, z);

        if (x.lengthSquared() === 0) {
          if (Math.abs(up.z) === 1) {
            z.x += 1e-4;
          } else {
            z.z += 1e-4;
          }

          z.normalize();
          x.crossVectors(up, z);
        }

        x.normalize();
        y.crossVectors(z, x);
        te[0] = x.x;
        te[4] = y.x;
        te[8] = z.x;
        te[1] = x.y;
        te[5] = y.y;
        te[9] = z.y;
        te[2] = x.z;
        te[6] = y.z;
        te[10] = z.z;
        return this;
      }
    }, {
      key: "multiplyMatrices",
      value: function multiplyMatrices(a, b) {
        var te = this.elements;
        var ae = a.elements;
        var be = b.elements;
        var a00 = ae[0],
            a01 = ae[4],
            a02 = ae[8],
            a03 = ae[12];
        var a10 = ae[1],
            a11 = ae[5],
            a12 = ae[9],
            a13 = ae[13];
        var a20 = ae[2],
            a21 = ae[6],
            a22 = ae[10],
            a23 = ae[14];
        var a30 = ae[3],
            a31 = ae[7],
            a32 = ae[11],
            a33 = ae[15];
        var b00 = be[0],
            b01 = be[4],
            b02 = be[8],
            b03 = be[12];
        var b10 = be[1],
            b11 = be[5],
            b12 = be[9],
            b13 = be[13];
        var b20 = be[2],
            b21 = be[6],
            b22 = be[10],
            b23 = be[14];
        var b30 = be[3],
            b31 = be[7],
            b32 = be[11],
            b33 = be[15];
        te[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;
        te[4] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;
        te[8] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;
        te[12] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;
        te[1] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;
        te[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;
        te[9] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;
        te[13] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;
        te[2] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;
        te[6] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;
        te[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;
        te[14] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;
        te[3] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;
        te[7] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;
        te[11] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;
        te[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(m) {
        return this.multiplyMatrices(this, m);
      }
    }, {
      key: "premultiply",
      value: function premultiply(m) {
        return this.multiplyMatrices(m, this);
      }
    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        var te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
      }
    }, {
      key: "determinant",
      value: function determinant() {
        var te = this.elements;
        var n00 = te[0],
            n01 = te[4],
            n02 = te[8],
            n03 = te[12];
        var n10 = te[1],
            n11 = te[5],
            n12 = te[9],
            n13 = te[13];
        var n20 = te[2],
            n21 = te[6],
            n22 = te[10],
            n23 = te[14];
        var n30 = te[3],
            n31 = te[7],
            n32 = te[11],
            n33 = te[15];
        var n00n11 = n00 * n11,
            n00n12 = n00 * n12,
            n00n13 = n00 * n13;
        var n01n10 = n01 * n10,
            n01n12 = n01 * n12,
            n01n13 = n01 * n13;
        var n02n10 = n02 * n10,
            n02n11 = n02 * n11,
            n02n13 = n02 * n13;
        var n03n10 = n03 * n10,
            n03n11 = n03 * n11,
            n03n12 = n03 * n12;
        return n30 * (n03n12 * n21 - n02n13 * n21 - n03n11 * n22 + n01n13 * n22 + n02n11 * n23 - n01n12 * n23) + n31 * (n00n12 * n23 - n00n13 * n22 + n03n10 * n22 - n02n10 * n23 + n02n13 * n20 - n03n12 * n20) + n32 * (n00n13 * n21 - n00n11 * n23 - n03n10 * n21 + n01n10 * n23 + n03n11 * n20 - n01n13 * n20) + n33 * (-n02n11 * n20 - n00n12 * n21 + n00n11 * n22 + n02n10 * n21 - n01n10 * n22 + n01n12 * n20);
      }
    }, {
      key: "getInverse",
      value: function getInverse(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        var n00 = me[0],
            n10 = me[1],
            n20 = me[2],
            n30 = me[3];
        var n01 = me[4],
            n11 = me[5],
            n21 = me[6],
            n31 = me[7];
        var n02 = me[8],
            n12 = me[9],
            n22 = me[10],
            n32 = me[11];
        var n03 = me[12],
            n13 = me[13],
            n23 = me[14],
            n33 = me[15];
        var t00 = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
        var t01 = n03 * n22 * n31 - n02 * n23 * n31 - n03 * n21 * n32 + n01 * n23 * n32 + n02 * n21 * n33 - n01 * n22 * n33;
        var t02 = n02 * n13 * n31 - n03 * n12 * n31 + n03 * n11 * n32 - n01 * n13 * n32 - n02 * n11 * n33 + n01 * n12 * n33;
        var t03 = n03 * n12 * n21 - n02 * n13 * n21 - n03 * n11 * n22 + n01 * n13 * n22 + n02 * n11 * n23 - n01 * n12 * n23;
        var det = n00 * t00 + n10 * t01 + n20 * t02 + n30 * t03;
        var invDet;

        if (det !== 0) {
          invDet = 1.0 / det;
          te[0] = t00 * invDet;
          te[1] = (n13 * n22 * n30 - n12 * n23 * n30 - n13 * n20 * n32 + n10 * n23 * n32 + n12 * n20 * n33 - n10 * n22 * n33) * invDet;
          te[2] = (n11 * n23 * n30 - n13 * n21 * n30 + n13 * n20 * n31 - n10 * n23 * n31 - n11 * n20 * n33 + n10 * n21 * n33) * invDet;
          te[3] = (n12 * n21 * n30 - n11 * n22 * n30 - n12 * n20 * n31 + n10 * n22 * n31 + n11 * n20 * n32 - n10 * n21 * n32) * invDet;
          te[4] = t01 * invDet;
          te[5] = (n02 * n23 * n30 - n03 * n22 * n30 + n03 * n20 * n32 - n00 * n23 * n32 - n02 * n20 * n33 + n00 * n22 * n33) * invDet;
          te[6] = (n03 * n21 * n30 - n01 * n23 * n30 - n03 * n20 * n31 + n00 * n23 * n31 + n01 * n20 * n33 - n00 * n21 * n33) * invDet;
          te[7] = (n01 * n22 * n30 - n02 * n21 * n30 + n02 * n20 * n31 - n00 * n22 * n31 - n01 * n20 * n32 + n00 * n21 * n32) * invDet;
          te[8] = t02 * invDet;
          te[9] = (n03 * n12 * n30 - n02 * n13 * n30 - n03 * n10 * n32 + n00 * n13 * n32 + n02 * n10 * n33 - n00 * n12 * n33) * invDet;
          te[10] = (n01 * n13 * n30 - n03 * n11 * n30 + n03 * n10 * n31 - n00 * n13 * n31 - n01 * n10 * n33 + n00 * n11 * n33) * invDet;
          te[11] = (n02 * n11 * n30 - n01 * n12 * n30 - n02 * n10 * n31 + n00 * n12 * n31 + n01 * n10 * n32 - n00 * n11 * n32) * invDet;
          te[12] = t03 * invDet;
          te[13] = (n02 * n13 * n20 - n03 * n12 * n20 + n03 * n10 * n22 - n00 * n13 * n22 - n02 * n10 * n23 + n00 * n12 * n23) * invDet;
          te[14] = (n03 * n11 * n20 - n01 * n13 * n20 - n03 * n10 * n21 + n00 * n13 * n21 + n01 * n10 * n23 - n00 * n11 * n23) * invDet;
          te[15] = (n01 * n12 * n20 - n02 * n11 * n20 + n02 * n10 * n21 - n00 * n12 * n21 - n01 * n10 * n22 + n00 * n11 * n22) * invDet;
        } else {
          console.error("Can't invert matrix, determinant is zero", matrix);
          this.identity();
        }

        return this;
      }
    }, {
      key: "transpose",
      value: function transpose() {
        var te = this.elements;
        var t;
        t = te[1];
        te[1] = te[4];
        te[4] = t;
        t = te[2];
        te[2] = te[8];
        te[8] = t;
        t = te[6];
        te[6] = te[9];
        te[9] = t;
        t = te[3];
        te[3] = te[12];
        te[12] = t;
        t = te[7];
        te[7] = te[13];
        te[13] = t;
        t = te[11];
        te[11] = te[14];
        te[14] = t;
        return this;
      }
    }, {
      key: "scale",
      value: function scale(sx, sy, sz) {
        var te = this.elements;
        te[0] *= sx;
        te[4] *= sy;
        te[8] *= sz;
        te[1] *= sx;
        te[5] *= sy;
        te[9] *= sz;
        te[2] *= sx;
        te[6] *= sy;
        te[10] *= sz;
        te[3] *= sx;
        te[7] *= sy;
        te[11] *= sz;
        return this;
      }
    }, {
      key: "makeScale",
      value: function makeScale(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "makeTranslation",
      value: function makeTranslation(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "makeRotationX",
      value: function makeRotationX(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "makeRotationY",
      value: function makeRotationY(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "makeRotationZ",
      value: function makeRotationZ(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "makeRotationAxis",
      value: function makeRotationAxis(axis, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1.0 - c;
        var x = axis.x,
            y = axis.y,
            z = axis.z;
        var tx = t * x,
            ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "makeShear",
      value: function makeShear(x, y, z) {
        this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "compose",
      value: function compose(position, quaternion, scale) {
        var te = this.elements;
        var x = quaternion.x,
            y = quaternion.y,
            z = quaternion.z,
            w = quaternion.w;
        var x2 = x + x,
            y2 = y + y,
            z2 = z + z;
        var xx = x * x2,
            xy = x * y2,
            xz = x * z2;
        var yy = y * y2,
            yz = y * z2,
            zz = z * z2;
        var wx = w * x2,
            wy = w * y2,
            wz = w * z2;
        var sx = scale.x,
            sy = scale.y,
            sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
      }
    }, {
      key: "decompose",
      value: function decompose(position, quaternion, scale) {
        var te = this.elements;
        var n00 = te[0],
            n10 = te[1],
            n20 = te[2];
        var n01 = te[4],
            n11 = te[5],
            n21 = te[6];
        var n02 = te[8],
            n12 = te[9],
            n22 = te[10];
        var det = this.determinant();
        var sx = a$2.set(n00, n10, n20).length() * (det < 0 ? -1 : 1);
        var sy = a$2.set(n01, n11, n21).length();
        var sz = a$2.set(n02, n12, n22).length();
        var invSX = 1.0 / sx;
        var invSY = 1.0 / sy;
        var invSZ = 1.0 / sz;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        te[0] *= invSX;
        te[1] *= invSX;
        te[2] *= invSX;
        te[4] *= invSY;
        te[5] *= invSY;
        te[6] *= invSY;
        te[8] *= invSZ;
        te[9] *= invSZ;
        te[10] *= invSZ;
        quaternion.setFromRotationMatrix(this);
        te[0] = n00;
        te[1] = n10;
        te[2] = n20;
        te[4] = n01;
        te[5] = n11;
        te[6] = n21;
        te[8] = n02;
        te[9] = n12;
        te[10] = n22;
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
      }
    }, {
      key: "makePerspective",
      value: function makePerspective(left, right, top, bottom, near, far) {
        var te = this.elements;
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
      }
    }, {
      key: "makeOrthographic",
      value: function makeOrthographic(left, right, top, bottom, near, far) {
        var te = this.elements;
        var w = 1.0 / (right - left);
        var h = 1.0 / (top - bottom);
        var p = 1.0 / (far - near);
        var x = (right + left) * w;
        var y = (top + bottom) * h;
        var z = (far + near) * p;
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
      }
    }, {
      key: "equals",
      value: function equals(m) {
        var te = this.elements;
        var me = m.elements;
        var result = true;
        var i;

        for (i = 0; result && i < 16; ++i) {
          if (te[i] !== me[i]) {
            result = false;
          }
        }

        return result;
      }
    }]);

    return Matrix4$1;
  }();

  var Spherical$1 = function () {
    function Spherical$1() {
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var phi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var theta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      _classCallCheck(this, Spherical$1);

      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
    }

    _createClass(Spherical$1, [{
      key: "set",
      value: function set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
    }, {
      key: "copy",
      value: function copy(s) {
        this.radius = s.radius;
        this.phi = s.phi;
        this.theta = s.theta;
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "makeSafe",
      value: function makeSafe() {
        this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi));
        return this;
      }
    }, {
      key: "setFromVector3",
      value: function setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
      }
    }, {
      key: "setFromCartesianCoords",
      value: function setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);

        if (this.radius === 0) {
          this.theta = 0;
          this.phi = 0;
        } else {
          this.theta = Math.atan2(x, z);
          this.phi = Math.acos(Math.min(Math.max(y / this.radius, -1), 1));
        }

        return this;
      }
    }]);

    return Spherical$1;
  }();
  /**
   * delta-controls v2.1.0 build Thu Jan 23 2020
   * https://github.com/vanruesc/delta-controls
   * Copyright 2020 Raoul van Rschen
   * @license Zlib
   */


  var Action = {
    MOVE_FORWARD: 0,
    MOVE_LEFT: 1,
    MOVE_BACKWARD: 2,
    MOVE_RIGHT: 3,
    MOVE_DOWN: 4,
    MOVE_UP: 5,
    ZOOM_OUT: 6,
    ZOOM_IN: 7
  };
  var PointerButton = {
    MAIN: 0,
    AUXILIARY: 1,
    SECONDARY: 2
  };
  var TWO_PI = Math.PI * 2;
  var v$2 = new Vector3$1();
  var m$1 = new Matrix4$1();

  var RotationManager = function () {
    function RotationManager(position, quaternion, target, settings) {
      _classCallCheck(this, RotationManager);

      this.position = position;
      this.quaternion = quaternion;
      this.target = target;
      this.settings = settings;
      this.spherical = new Spherical$1();
    }

    _createClass(RotationManager, [{
      key: "setPosition",
      value: function setPosition(position) {
        this.position = position;
        return this;
      }
    }, {
      key: "setQuaternion",
      value: function setQuaternion(quaternion) {
        this.quaternion = quaternion;
        return this;
      }
    }, {
      key: "setTarget",
      value: function setTarget(target) {
        this.target = target;
        return this;
      }
    }, {
      key: "updateQuaternion",
      value: function updateQuaternion() {
        var settings = this.settings;
        var rotation = settings.rotation;

        if (settings.general.orbit) {
          m$1.lookAt(v$2.subVectors(this.position, this.target), rotation.pivotOffset, rotation.up);
        } else {
          m$1.lookAt(v$2.set(0, 0, 0), this.target.setFromSpherical(this.spherical), rotation.up);
        }

        this.quaternion.setFromRotationMatrix(m$1);
        return this;
      }
    }, {
      key: "adjustSpherical",
      value: function adjustSpherical(theta, phi) {
        var settings = this.settings;
        var orbit = settings.general.orbit;
        var rotation = settings.rotation;
        var s = this.spherical;
        s.theta = !rotation.invertX ? s.theta - theta : s.theta + theta;
        s.phi = (orbit || rotation.invertY) && !(orbit && rotation.invertY) ? s.phi - phi : s.phi + phi;
        s.theta = Math.min(Math.max(s.theta, rotation.minAzimuthalAngle), rotation.maxAzimuthalAngle);
        s.phi = Math.min(Math.max(s.phi, rotation.minPolarAngle), rotation.maxPolarAngle);
        s.theta %= TWO_PI;
        s.makeSafe();

        if (orbit) {
          this.position.setFromSpherical(s).add(this.target);
        }

        return this;
      }
    }, {
      key: "zoom",
      value: function zoom(sign) {
        var settings = this.settings;
        var general = settings.general;
        var sensitivity = settings.sensitivity;
        var zoom = settings.zoom;
        var s = this.spherical;
        var amount, min, max;

        if (general.orbit && zoom.enabled) {
          amount = sign * sensitivity.zoom;

          if (zoom.invert) {
            amount = -amount;
          }

          min = Math.max(zoom.minDistance, 1e-6);
          max = Math.min(zoom.maxDistance, Infinity);
          s.radius = Math.min(Math.max(s.radius + amount, min), max);
          this.position.setFromSpherical(s).add(this.target);
        }

        return this;
      }
    }, {
      key: "update",
      value: function update(delta) {}
    }, {
      key: "lookAt",
      value: function lookAt(point) {
        var spherical = this.spherical;
        var position = this.position;
        var target = this.target;
        target.copy(point);

        if (this.settings.general.orbit) {
          v$2.subVectors(position, target);
        } else {
          v$2.subVectors(target, position).normalize();
        }

        spherical.setFromVector3(v$2);
        spherical.radius = Math.max(spherical.radius, 1e-6);
        this.updateQuaternion();
        return this;
      }
    }, {
      key: "getViewDirection",
      value: function getViewDirection() {
        var view = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3$1();
        view.setFromSpherical(this.spherical).normalize();

        if (this.settings.general.orbit) {
          view.negate();
        }

        return view;
      }
    }]);

    return RotationManager;
  }();

  var MovementState = function () {
    function MovementState() {
      _classCallCheck(this, MovementState);

      this.left = false;
      this.right = false;
      this.forward = false;
      this.backward = false;
      this.up = false;
      this.down = false;
    }

    _createClass(MovementState, [{
      key: "reset",
      value: function reset() {
        this.left = false;
        this.right = false;
        this.forward = false;
        this.backward = false;
        this.up = false;
        this.down = false;
        return this;
      }
    }]);

    return MovementState;
  }();

  var x = new Vector3$1(1, 0, 0);
  var y = new Vector3$1(0, 1, 0);
  var z = new Vector3$1(0, 0, 1);
  var v$1$1 = new Vector3$1();

  var TranslationManager = function () {
    function TranslationManager(position, quaternion, target, settings) {
      _classCallCheck(this, TranslationManager);

      this.position = position;
      this.quaternion = quaternion;
      this.target = target;
      this.settings = settings;
      this.movementState = new MovementState();
    }

    _createClass(TranslationManager, [{
      key: "setPosition",
      value: function setPosition(position) {
        this.position = position;
        return this;
      }
    }, {
      key: "setQuaternion",
      value: function setQuaternion(quaternion) {
        this.quaternion = quaternion;
        return this;
      }
    }, {
      key: "setTarget",
      value: function setTarget(target) {
        this.target = target;
        return this;
      }
    }, {
      key: "translateOnAxis",
      value: function translateOnAxis(axis, distance) {
        v$1$1.copy(axis).applyQuaternion(this.quaternion).multiplyScalar(distance);
        this.position.add(v$1$1);

        if (this.settings.general.orbit) {
          this.target.add(v$1$1);
        }
      }
    }, {
      key: "translate",
      value: function translate(delta) {
        var sensitivity = this.settings.sensitivity;
        var state = this.movementState;
        var step = delta * sensitivity.translation;

        if (state.backward) {
          this.translateOnAxis(z, step);
        } else if (state.forward) {
          this.translateOnAxis(z, -step);
        }

        if (state.right) {
          this.translateOnAxis(x, step);
        } else if (state.left) {
          this.translateOnAxis(x, -step);
        }

        if (state.up) {
          this.translateOnAxis(y, step);
        } else if (state.down) {
          this.translateOnAxis(y, -step);
        }
      }
    }, {
      key: "update",
      value: function update(delta) {
        if (this.settings.translation.enabled) {
          this.translate(delta);
        }
      }
    }, {
      key: "moveTo",
      value: function moveTo(position) {
        if (this.settings.general.orbit) {
          this.target.copy(position);
        } else {
          this.position.copy(position);
        }

        return this;
      }
    }]);

    return TranslationManager;
  }();

  var KeyCodeHandler = {
    get: function get(target, name) {
      return name in target ? target[name] : name.length === 1 ? name.toUpperCase().charCodeAt(0) : undefined;
    }
  };
  var KeyCode = new Proxy({
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    CAPS_LOCK: 20,
    ESCAPE: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    INSERT: 45,
    DELETE: 46,
    META_LEFT: 91,
    META_RIGHT: 92,
    SELECT: 93,
    NUMPAD_0: 96,
    NUMPAD_1: 97,
    NUMPAD_2: 98,
    NUMPAD_3: 99,
    NUMPAD_4: 100,
    NUMPAD_5: 101,
    NUMPAD_6: 102,
    NUMPAD_7: 103,
    NUMPAD_8: 104,
    NUMPAD_9: 105,
    MULTIPLY: 106,
    ADD: 107,
    SUBTRACT: 109,
    DECIMAL_POINT: 110,
    DIVIDE: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    NUM_LOCK: 144,
    SCROLL_LOCK: 145,
    SEMICOLON: 186,
    EQUAL_SIGN: 187,
    COMMA: 188,
    DASH: 189,
    PERIOD: 190,
    FORWARD_SLASH: 191,
    GRAVE_ACCENT: 192,
    OPEN_BRACKET: 219,
    BACK_SLASH: 220,
    CLOSE_BRACKET: 221,
    SINGLE_QUOTE: 222
  }, KeyCodeHandler);

  var GeneralSettings = function () {
    function GeneralSettings() {
      _classCallCheck(this, GeneralSettings);

      this.orbit = true;
    }

    _createClass(GeneralSettings, [{
      key: "copy",
      value: function copy(settings) {
        this.orbit = settings.orbit;
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);

    return GeneralSettings;
  }();

  var KeyBindings = function () {
    function KeyBindings() {
      _classCallCheck(this, KeyBindings);

      this.defaultActions = new Map();
      this.actions = new Map();
    }

    _createClass(KeyBindings, [{
      key: "reset",
      value: function reset() {
        this.actions = new Map(this.defaultActions);
        return this;
      }
    }, {
      key: "setDefault",
      value: function setDefault(actions) {
        this.defaultActions = actions;
        return this.reset();
      }
    }, {
      key: "copy",
      value: function copy(keyBindings) {
        this.defaultActions = new Map(keyBindings.defaultActions);
        this.actions = new Map(keyBindings.actions);
        return this;
      }
    }, {
      key: "clearDefault",
      value: function clearDefault() {
        this.defaultActions.clear();
        return this;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.actions.clear();
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "has",
      value: function has(keyCode) {
        return this.actions.has(keyCode);
      }
    }, {
      key: "get",
      value: function get(keyCode) {
        return this.actions.get(keyCode);
      }
    }, {
      key: "set",
      value: function set(keyCode, action) {
        this.actions.set(keyCode, action);
        return this;
      }
    }, {
      key: "delete",
      value: function _delete(keyCode) {
        return this.actions["delete"](keyCode);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          defaultActions: _toConsumableArray(this.defaultActions),
          actions: _toConsumableArray(this.actions)
        };
      }
    }]);

    return KeyBindings;
  }();

  var PointerSettings = function () {
    function PointerSettings() {
      _classCallCheck(this, PointerSettings);

      this.hold = false;
      this.lock = true;
    }

    _createClass(PointerSettings, [{
      key: "copy",
      value: function copy(settings) {
        this.hold = settings.hold;
        this.lock = settings.lock;
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);

    return PointerSettings;
  }();

  var RotationSettings = function () {
    function RotationSettings() {
      _classCallCheck(this, RotationSettings);

      this.up = new Vector3$1();
      this.up.copy(y);
      this.pivotOffset = new Vector3$1();
      this.minAzimuthalAngle = -Infinity;
      this.maxAzimuthalAngle = Infinity;
      this.minPolarAngle = 0.0;
      this.maxPolarAngle = Math.PI;
      this.invertX = false;
      this.invertY = false;
    }

    _createClass(RotationSettings, [{
      key: "copy",
      value: function copy(settings) {
        this.up.copy(settings.up);
        this.pivotOffset.copy(settings.pivotOffset);
        this.minAzimuthalAngle = settings.minAzimuthalAngle !== null ? settings.minAzimuthalAngle : -Infinity;
        this.maxAzimuthalAngle = settings.maxAzimuthalAngle !== null ? settings.maxAzimuthalAngle : Infinity;
        this.minPolarAngle = settings.minPolarAngle;
        this.maxPolarAngle = settings.maxPolarAngle;
        this.invertX = settings.invertX;
        this.invertY = settings.invertY;
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);

    return RotationSettings;
  }();

  var SensitivitySettings = function () {
    function SensitivitySettings() {
      _classCallCheck(this, SensitivitySettings);

      this.rotation = 0.0025;
      this.translation = 1.0;
      this.zoom = 0.1;
    }

    _createClass(SensitivitySettings, [{
      key: "copy",
      value: function copy(settings) {
        this.rotation = settings.rotation;
        this.translation = settings.translation;
        this.zoom = settings.zoom;
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);

    return SensitivitySettings;
  }();

  var TranslationSettings = function () {
    function TranslationSettings() {
      _classCallCheck(this, TranslationSettings);

      this.enabled = true;
    }

    _createClass(TranslationSettings, [{
      key: "copy",
      value: function copy(settings) {
        this.enabled = settings.enabled;
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);

    return TranslationSettings;
  }();

  var ZoomSettings = function () {
    function ZoomSettings() {
      _classCallCheck(this, ZoomSettings);

      this.enabled = true;
      this.invert = false;
      this.minDistance = 1e-6;
      this.maxDistance = Infinity;
    }

    _createClass(ZoomSettings, [{
      key: "copy",
      value: function copy(settings) {
        this.enabled = settings.enabled;
        this.invert = settings.invert;
        this.minDistance = settings.minDistance;
        this.maxDistance = settings.maxDistance;
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);

    return ZoomSettings;
  }();

  var Settings = function () {
    function Settings() {
      _classCallCheck(this, Settings);

      this.general = new GeneralSettings();
      this.keyBindings = new KeyBindings();
      this.keyBindings.setDefault(new Map([[KeyCode.W, Action.MOVE_FORWARD], [KeyCode.UP, Action.MOVE_FORWARD], [KeyCode.A, Action.MOVE_LEFT], [KeyCode.LEFT, Action.MOVE_LEFT], [KeyCode.S, Action.MOVE_BACKWARD], [KeyCode.DOWN, Action.MOVE_BACKWARD], [KeyCode.D, Action.MOVE_RIGHT], [KeyCode.RIGHT, Action.MOVE_RIGHT], [KeyCode.X, Action.MOVE_DOWN], [KeyCode.SPACE, Action.MOVE_UP], [KeyCode.PAGE_DOWN, Action.ZOOM_OUT], [KeyCode.PAGE_UP, Action.ZOOM_IN]]));
      this.pointer = new PointerSettings();
      this.rotation = new RotationSettings();
      this.sensitivity = new SensitivitySettings();
      this.translation = new TranslationSettings();
      this.zoom = new ZoomSettings();
    }

    _createClass(Settings, [{
      key: "copy",
      value: function copy(settings) {
        this.general.copy(settings.general);
        this.keyBindings.copy(settings.keyBindings);
        this.pointer.copy(settings.pointer);
        this.rotation.copy(settings.rotation);
        this.sensitivity.copy(settings.sensitivity);
        this.translation.copy(settings.translation);
        this.zoom.copy(settings.zoom);
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "toDataURL",
      value: function toDataURL() {
        return URL.createObjectURL(new Blob([JSON.stringify(this)], {
          type: "text/json"
        }));
      }
    }]);

    return Settings;
  }();

  var Strategy = function () {
    function Strategy() {
      _classCallCheck(this, Strategy);
    }

    _createClass(Strategy, [{
      key: "execute",
      value: function execute(flag) {
        throw new Error("Strategy#execute method not implemented!");
      }
    }]);

    return Strategy;
  }();

  var MovementStrategy = function (_Strategy) {
    _inherits(MovementStrategy, _Strategy);

    function MovementStrategy(movementState, direction) {
      var _this51;

      _classCallCheck(this, MovementStrategy);

      _this51 = _possibleConstructorReturn(this, _getPrototypeOf(MovementStrategy).call(this));
      _this51.movementState = movementState;
      _this51.direction = direction;
      return _this51;
    }

    _createClass(MovementStrategy, [{
      key: "execute",
      value: function execute(flag) {
        var state = this.movementState;

        switch (this.direction) {
          case Direction.FORWARD:
            state.forward = flag;
            break;

          case Direction.LEFT:
            state.left = flag;
            break;

          case Direction.BACKWARD:
            state.backward = flag;
            break;

          case Direction.RIGHT:
            state.right = flag;
            break;

          case Direction.DOWN:
            state.down = flag;
            break;

          case Direction.UP:
            state.up = flag;
            break;
        }
      }
    }]);

    return MovementStrategy;
  }(Strategy);

  var Direction = {
    FORWARD: 0,
    LEFT: 1,
    BACKWARD: 2,
    RIGHT: 3,
    DOWN: 4,
    UP: 5
  };

  var ZoomStrategy = function (_Strategy2) {
    _inherits(ZoomStrategy, _Strategy2);

    function ZoomStrategy(rotationManager, zoomIn) {
      var _this52;

      _classCallCheck(this, ZoomStrategy);

      _this52 = _possibleConstructorReturn(this, _getPrototypeOf(ZoomStrategy).call(this));
      _this52.rotationManager = rotationManager;
      _this52.zoomIn = zoomIn;
      return _this52;
    }

    _createClass(ZoomStrategy, [{
      key: "execute",
      value: function execute(flag) {
        if (flag) {
          this.rotationManager.zoom(this.zoomIn ? -1 : 1);
        }
      }
    }]);

    return ZoomStrategy;
  }(Strategy);

  var DeltaControls = function () {
    function DeltaControls() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var quaternion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var dom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document.body;

      _classCallCheck(this, DeltaControls);

      this.dom = dom;
      this.position = position;
      this.quaternion = quaternion;
      this.target = new Vector3$1();
      this.settings = new Settings();
      this.rotationManager = new RotationManager(position, quaternion, this.target, this.settings);
      this.translationManager = new TranslationManager(position, quaternion, this.target, this.settings);

      this.strategies = function (rotationManager, translationManager) {
        var state = translationManager.movementState;
        return new Map([[Action.MOVE_FORWARD, new MovementStrategy(state, Direction.FORWARD)], [Action.MOVE_LEFT, new MovementStrategy(state, Direction.LEFT)], [Action.MOVE_BACKWARD, new MovementStrategy(state, Direction.BACKWARD)], [Action.MOVE_RIGHT, new MovementStrategy(state, Direction.RIGHT)], [Action.MOVE_DOWN, new MovementStrategy(state, Direction.DOWN)], [Action.MOVE_UP, new MovementStrategy(state, Direction.UP)], [Action.ZOOM_OUT, new ZoomStrategy(rotationManager, false)], [Action.ZOOM_IN, new ZoomStrategy(rotationManager, true)]]);
      }(this.rotationManager, this.translationManager);

      this.lastScreenPosition = new Vector2$1();
      this.dragging = false;
      this.enabled = false;

      if (position !== null && quaternion !== null) {
        this.lookAt(this.target);

        if (dom !== null) {
          this.setEnabled();
        }
      }
    }

    _createClass(DeltaControls, [{
      key: "getDom",
      value: function getDom() {
        return this.dom;
      }
    }, {
      key: "getPosition",
      value: function getPosition() {
        return this.position;
      }
    }, {
      key: "getQuaternion",
      value: function getQuaternion() {
        return this.quaternion;
      }
    }, {
      key: "getTarget",
      value: function getTarget() {
        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3$1();
        target.copy(this.target);

        if (!this.settings.general.orbit) {
          target.add(this.position);
        }

        return target;
      }
    }, {
      key: "getViewDirection",
      value: function getViewDirection() {
        var view = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3$1();
        return this.rotationManager.getViewDirection(view);
      }
    }, {
      key: "setDom",
      value: function setDom(dom) {
        var enabled = this.enabled;

        if (dom !== null) {
          if (enabled) {
            this.setEnabled(false);
          }

          this.dom = dom;
          this.setEnabled(enabled);
        }

        return this;
      }
    }, {
      key: "setPosition",
      value: function setPosition(position) {
        this.position = position;
        this.rotationManager.setPosition(position);
        this.translationManager.setPosition(position);
        return this.lookAt(this.target);
      }
    }, {
      key: "setQuaternion",
      value: function setQuaternion(quaternion) {
        this.quaternion = quaternion;
        this.rotationManager.setQuaternion(quaternion);
        this.translationManager.setQuaternion(quaternion);
        return this.lookAt(this.target);
      }
    }, {
      key: "setTarget",
      value: function setTarget(target) {
        this.target = target;
        this.rotationManager.setTarget(target);
        this.translationManager.setTarget(target);
        return this.lookAt(this.target);
      }
    }, {
      key: "setOrbitEnabled",
      value: function setOrbitEnabled(orbit) {
        var general = this.settings.general;

        if (general.orbit !== orbit) {
          this.getTarget(this.target);
          general.orbit = orbit;
          this.lookAt(this.target);
        }

        return this;
      }
    }, {
      key: "copy",
      value: function copy(controls) {
        this.dom = controls.getDom();
        this.position = controls.getPosition();
        this.quaternion = controls.getQuaternion();
        this.target = controls.getTarget();
        this.settings.copy(controls.settings);
        this.rotationManager.setPosition(this.position).setQuaternion(this.quaternion).setTarget(this.target);
        this.translationManager.setPosition(this.position).setQuaternion(this.quaternion).setTarget(this.target);
        return this.lookAt(this.target);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "handlePointerMoveEvent",
      value: function handlePointerMoveEvent(event) {
        var settings = this.settings;
        var pointer = settings.pointer;
        var sensitivity = settings.sensitivity;
        var rotationManager = this.rotationManager;
        var lastScreenPosition = this.lastScreenPosition;
        var movementX, movementY;

        if (document.pointerLockElement === this.dom) {
          if (!pointer.hold || this.dragging) {
            rotationManager.adjustSpherical(event.movementX * sensitivity.rotation, event.movementY * sensitivity.rotation).updateQuaternion();
          }
        } else {
          movementX = event.screenX - lastScreenPosition.x;
          movementY = event.screenY - lastScreenPosition.y;
          lastScreenPosition.set(event.screenX, event.screenY);
          rotationManager.adjustSpherical(movementX * sensitivity.rotation, movementY * sensitivity.rotation).updateQuaternion();
        }
      }
    }, {
      key: "handleTouchMoveEvent",
      value: function handleTouchMoveEvent(event) {
        var sensitivity = this.settings.sensitivity;
        var rotationManager = this.rotationManager;
        var lastScreenPosition = this.lastScreenPosition;
        var touch = event.touches[0];
        var movementX = touch.screenX - lastScreenPosition.x;
        var movementY = touch.screenY - lastScreenPosition.y;
        lastScreenPosition.set(touch.screenX, touch.screenY);
        event.preventDefault();
        rotationManager.adjustSpherical(movementX * sensitivity.rotation, movementY * sensitivity.rotation).updateQuaternion();
      }
    }, {
      key: "handleMainPointerButton",
      value: function handleMainPointerButton(event, pressed) {
        this.dragging = pressed;

        if (this.settings.pointer.lock) {
          this.setPointerLocked();
        } else {
          if (pressed) {
            this.lastScreenPosition.set(event.screenX, event.screenY);
            this.dom.addEventListener("mousemove", this);
          } else {
            this.dom.removeEventListener("mousemove", this);
          }
        }
      }
    }, {
      key: "handleAuxiliaryPointerButton",
      value: function handleAuxiliaryPointerButton(event, pressed) {}
    }, {
      key: "handleSecondaryPointerButton",
      value: function handleSecondaryPointerButton(event, pressed) {}
    }, {
      key: "handlePointerButtonEvent",
      value: function handlePointerButtonEvent(event, pressed) {
        event.preventDefault();

        switch (event.button) {
          case PointerButton.MAIN:
            this.handleMainPointerButton(event, pressed);
            break;

          case PointerButton.AUXILIARY:
            this.handleAuxiliaryPointerButton(event, pressed);
            break;

          case PointerButton.SECONDARY:
            this.handleSecondaryPointerButton(event, pressed);
            break;
        }
      }
    }, {
      key: "handleTouchEvent",
      value: function handleTouchEvent(event, start) {
        var touch = event.touches[0];
        event.preventDefault();

        if (start) {
          this.lastScreenPosition.set(touch.screenX, touch.screenY);
          this.dom.addEventListener("touchmove", this);
        } else {
          this.dom.removeEventListener("touchmove", this);
        }
      }
    }, {
      key: "handleKeyboardEvent",
      value: function handleKeyboardEvent(event, pressed) {
        var keyBindings = this.settings.keyBindings;

        if (keyBindings.has(event.keyCode)) {
          event.preventDefault();
          this.strategies.get(keyBindings.get(event.keyCode)).execute(pressed);
        }
      }
    }, {
      key: "handleWheelEvent",
      value: function handleWheelEvent(event) {
        this.rotationManager.zoom(Math.sign(event.deltaY));
      }
    }, {
      key: "handlePointerLockEvent",
      value: function handlePointerLockEvent() {
        if (document.pointerLockElement === this.dom) {
          this.dom.addEventListener("mousemove", this);
        } else {
          this.dom.removeEventListener("mousemove", this);
        }
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        switch (event.type) {
          case "mousemove":
            this.handlePointerMoveEvent(event);
            break;

          case "touchmove":
            this.handleTouchMoveEvent(event);
            break;

          case "mousedown":
            this.handlePointerButtonEvent(event, true);
            break;

          case "mouseup":
            this.handlePointerButtonEvent(event, false);
            break;

          case "touchstart":
            this.handleTouchEvent(event, true);
            break;

          case "touchend":
            this.handleTouchEvent(event, false);
            break;

          case "keydown":
            this.handleKeyboardEvent(event, true);
            break;

          case "keyup":
            this.handleKeyboardEvent(event, false);
            break;

          case "wheel":
            this.handleWheelEvent(event);
            break;

          case "pointerlockchange":
            this.handlePointerLockEvent();
            break;
        }
      }
    }, {
      key: "update",
      value: function update(delta) {
        this.rotationManager.update(delta);
        this.translationManager.update(delta);
      }
    }, {
      key: "moveTo",
      value: function moveTo(position) {
        this.rotationManager.moveTo(position);
        return this;
      }
    }, {
      key: "lookAt",
      value: function lookAt(point) {
        this.rotationManager.lookAt(point);
        return this;
      }
    }, {
      key: "setPointerLocked",
      value: function setPointerLocked() {
        var locked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (locked) {
          if (document.pointerLockElement !== this.dom && this.dom.requestPointerLock !== undefined) {
            this.dom.requestPointerLock();
          }
        } else if (document.exitPointerLock !== undefined) {
          document.exitPointerLock();
        }
      }
    }, {
      key: "setEnabled",
      value: function setEnabled() {
        var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var dom = this.dom;
        this.translationManager.movementState.reset();

        if (enabled && !this.enabled) {
          document.addEventListener("pointerlockchange", this);
          document.body.addEventListener("keyup", this);
          document.body.addEventListener("keydown", this);
          dom.addEventListener("mousedown", this);
          dom.addEventListener("mouseup", this);
          dom.addEventListener("touchstart", this);
          dom.addEventListener("touchend", this);
          dom.addEventListener("wheel", this);
        } else if (!enabled && this.enabled) {
          document.removeEventListener("pointerlockchange", this);
          document.body.removeEventListener("keyup", this);
          document.body.removeEventListener("keydown", this);
          dom.removeEventListener("mousedown", this);
          dom.removeEventListener("mouseup", this);
          dom.removeEventListener("touchstart", this);
          dom.removeEventListener("touchend", this);
          dom.removeEventListener("wheel", this);
          dom.removeEventListener("mousemove", this);
          dom.removeEventListener("touchmove", this);
        }

        this.setPointerLocked(false);
        this.enabled = enabled;
        return this;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.setEnabled(false);
      }
    }]);

    return DeltaControls;
  }();

  var progressBar = null;

  var ProgressManager = function () {
    function ProgressManager() {
      _classCallCheck(this, ProgressManager);
    }

    _createClass(ProgressManager, null, [{
      key: "initialize",
      value: function initialize() {
        progressBar = document.querySelector(".progress-bar > div");
      }
    }, {
      key: "updateProgress",
      value: function updateProgress(url, loaded, total) {
        var progress = loaded / total * 100.0;
        progressBar.style.width = progress.toFixed(0) + "%";
      }
    }, {
      key: "reset",
      value: function reset() {
        progressBar.removeAttribute("style");
      }
    }]);

    return ProgressManager;
  }();

  function _create(color, size, thickness) {
    var group = new Group();
    var halfSize = size * 0.5;
    var mesh = new Mesh(new BoxBufferGeometry(thickness, size + thickness, thickness), new MeshBasicMaterial({
      color: color
    }));
    var clone0 = group.clone();
    var clone = mesh.clone();
    clone.position.set(-halfSize, 0, halfSize);
    clone0.add(clone);
    clone = mesh.clone();
    clone.position.set(halfSize, 0, halfSize);
    clone0.add(clone);
    clone = mesh.clone();
    clone.position.set(-halfSize, 0, -halfSize);
    clone0.add(clone);
    clone = mesh.clone();
    clone.position.set(halfSize, 0, -halfSize);
    clone0.add(clone);
    var clone1 = clone0.clone();
    clone1.rotation.set(Math.PI / 2, 0, 0);
    var clone2 = clone0.clone();
    clone2.rotation.set(0, 0, Math.PI / 2);
    group.add(clone0);
    group.add(clone1);
    group.add(clone2);
    return group;
  }

  var Cage = function () {
    function Cage() {
      _classCallCheck(this, Cage);
    }

    _createClass(Cage, null, [{
      key: "create",
      value: function create() {
        var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0x000000;
        var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8.0;
        var thickness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.25;
        return _create(color, size, thickness);
      }
    }]);

    return Cage;
  }();

  function create$1(amount, range) {
    var group = new Group();
    var geometry = new SphereBufferGeometry(1, 5, 5);
    var twoPI = 2 * Math.PI;

    for (var _i4 = 0; _i4 < amount; ++_i4) {
      var material = new MeshPhongMaterial({
        color: 0xffffff * Math.random(),
        flatShading: true
      });
      var mesh = new Mesh(geometry, material);
      mesh.position.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
      mesh.position.multiplyScalar(Math.random() * range);
      mesh.rotation.set(Math.random() * twoPI, Math.random() * twoPI, Math.random() * twoPI);
      mesh.scale.multiplyScalar(Math.random());
      group.add(mesh);
    }

    return group;
  }

  var SphereCloud = function () {
    function SphereCloud() {
      _classCallCheck(this, SphereCloud);
    }

    _createClass(SphereCloud, null, [{
      key: "create",
      value: function create() {
        var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
        var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10.0;
        return create$1(amount, range);
      }
    }]);

    return SphereCloud;
  }();

  var PostProcessingDemo = function (_Demo) {
    _inherits(PostProcessingDemo, _Demo);

    function PostProcessingDemo(id, composer) {
      var _this53;

      _classCallCheck(this, PostProcessingDemo);

      _this53 = _possibleConstructorReturn(this, _getPrototypeOf(PostProcessingDemo).call(this, id));
      _this53.composer = composer;
      _this53.renderPass = new RenderPass(_this53.scene, null);
      return _this53;
    }

    _createClass(PostProcessingDemo, [{
      key: "render",
      value: function render(deltaTime) {
        if (this.controls !== null) {
          this.controls.update(deltaTime);
        }

        this.composer.render(deltaTime);
      }
    }, {
      key: "reset",
      value: function reset() {
        _get(_getPrototypeOf(PostProcessingDemo.prototype), "reset", this).call(this);

        var renderPass = new RenderPass(this.scene, null);
        renderPass.enabled = this.renderPass.enabled;
        this.renderPass = renderPass;
        return this;
      }
    }]);

    return PostProcessingDemo;
  }(Demo);

  var mouse = new Vector2();

  var BloomDemo = function (_PostProcessingDemo) {
    _inherits(BloomDemo, _PostProcessingDemo);

    function BloomDemo(composer) {
      var _this54;

      _classCallCheck(this, BloomDemo);

      _this54 = _possibleConstructorReturn(this, _getPrototypeOf(BloomDemo).call(this, "bloom", composer));
      _this54.raycaster = null;
      _this54.selectedObject = null;
      _this54.effectA = null;
      _this54.effectB = null;
      _this54.passA = null;
      _this54.passB = null;
      _this54.object = null;
      return _this54;
    }

    _createClass(BloomDemo, [{
      key: "raycast",
      value: function raycast(event) {
        var raycaster = this.raycaster;
        mouse.x = event.clientX / window.innerWidth * 2.0 - 1.0;
        mouse.y = -(event.clientY / window.innerHeight) * 2.0 + 1.0;
        raycaster.setFromCamera(mouse, this.camera);
        var intersects = raycaster.intersectObjects(this.object.children);
        this.selectedObject = null;

        if (intersects.length > 0) {
          var _x2 = intersects[0];

          if (_x2.object !== undefined) {
            this.selectedObject = _x2.object;
          } else {
            console.warn("Encountered an undefined object", intersects);
          }
        }
      }
    }, {
      key: "handleSelection",
      value: function handleSelection() {
        var selection = this.effectB.selection;
        var selectedObject = this.selectedObject;

        if (selectedObject !== null) {
          if (selection.has(selectedObject)) {
            selection["delete"](selectedObject);
          } else {
            selection.add(selectedObject);
          }
        }
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        switch (event.type) {
          case "mousemove":
            this.raycast(event);
            break;

          case "mousedown":
            this.handleSelection();
            break;
        }
      }
    }, {
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var cubeTextureLoader = new CubeTextureLoader(loadingManager);
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var path = "textures/skies/space-green/";
        var format = ".jpg";
        var urls = [path + "px" + format, path + "nx" + format, path + "py" + format, path + "ny" + format, path + "pz" + format, path + "nz" + format];
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            cubeTextureLoader.load(urls, function (t) {
              t.encoding = sRGBEncoding;
              assets.set("sky", t);
            });
            smaaImageLoader.load(function (_ref28) {
              var _ref29 = _slicedToArray(_ref28, 2),
                  search = _ref29[0],
                  area = _ref29[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 1, 2000);
        camera.position.set(-10, 6, 15);
        camera.lookAt(scene.position);
        this.camera = camera;
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = false;
        controls.settings.sensitivity.zoom = 1.0;
        controls.lookAt(scene.position);
        this.controls = controls;
        scene.background = assets.get("sky");
        var ambientLight = new AmbientLight(0x212121);
        var mainLight = new DirectionalLight(0xffffff, 1.0);
        var backLight = new DirectionalLight(0xff7e66, 0.1);
        mainLight.position.set(-1, 1, 1);
        backLight.position.copy(mainLight.position).negate();
        scene.add(ambientLight, mainLight, backLight);
        var cloud = SphereCloud.create();
        cloud.scale.setScalar(0.4);
        this.object = cloud;
        scene.add(cloud);
        scene.add(Cage.create());
        this.raycaster = new Raycaster();
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(0.05);
        var bloomOptions = {
          blendFunction: BlendFunction.SCREEN,
          kernelSize: KernelSize.MEDIUM,
          luminanceThreshold: 0.8,
          luminanceSmoothing: 0.075,
          height: 480
        };
        var bloomEffect = new BloomEffect(bloomOptions);
        var selectiveBloomEffect = new SelectiveBloomEffect(scene, camera, bloomOptions);
        selectiveBloomEffect.inverted = true;
        this.effectA = bloomEffect;
        this.effectB = selectiveBloomEffect;
        var effectPassA = new EffectPass(camera, smaaEffect, bloomEffect);
        var effectPassB = new EffectPass(camera, smaaEffect, selectiveBloomEffect);
        this.passA = effectPassA;
        this.passB = effectPassB;
        effectPassA.renderToScreen = true;
        effectPassB.renderToScreen = true;
        effectPassB.enabled = false;
        composer.addPass(effectPassA);
        composer.addPass(effectPassB);
        ambientLight.layers.enable(selectiveBloomEffect.selection.layer);
        mainLight.layers.enable(selectiveBloomEffect.selection.layer);
        backLight.layers.enable(selectiveBloomEffect.selection.layer);
      }
    }, {
      key: "render",
      value: function render(delta) {
        var object = this.object;
        var PI2 = 2.0 * Math.PI;
        object.rotation.x += 0.05 * delta;
        object.rotation.y += 0.25 * delta;

        if (object.rotation.x >= PI2) {
          object.rotation.x -= PI2;
        }

        if (object.rotation.y >= PI2) {
          object.rotation.y -= PI2;
        }

        _get(_getPrototypeOf(BloomDemo.prototype), "render", this).call(this, delta);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var _this55 = this;

        var renderer = this.composer.getRenderer();
        var passA = this.passA;
        var passB = this.passB;
        var effectA = this.effectA;
        var effectB = this.effectB;
        var blendModeA = effectA.blendMode;
        var blendModeB = effectB.blendMode;
        var params = {
          "resolution": effectA.resolution.height,
          "kernel size": effectA.blurPass.kernelSize,
          "scale": effectA.blurPass.scale,
          "luminance": {
            "filter": effectA.luminancePass.enabled,
            "threshold": effectA.luminanceMaterial.threshold,
            "smoothing": effectA.luminanceMaterial.smoothing
          },
          "selection": {
            "enabled": false,
            "inverted": effectB.inverted,
            "ignore bg": effectB.ignoreBackground
          },
          "opacity": blendModeA.opacity.value,
          "blend mode": blendModeA.blendFunction
        };
        menu.add(params, "resolution", [240, 360, 480, 720, 1080]).onChange(function () {
          effectA.resolution.height = effectB.resolution.height = Number(params.resolution);
        });
        menu.add(params, "kernel size", KernelSize).onChange(function () {
          effectA.blurPass.kernelSize = effectB.blurPass.kernelSize = Number(params["kernel size"]);
        });
        menu.add(params, "scale").min(0.0).max(1.0).step(0.01).onChange(function () {
          effectA.blurPass.scale = effectB.blurPass.scale = Number(params.scale);
        });
        var folder = menu.addFolder("Luminance");
        folder.add(params.luminance, "filter").onChange(function () {
          effectA.luminancePass.enabled = effectB.luminancePass.enabled = params.luminance.filter;
        });
        folder.add(params.luminance, "threshold").min(0.0).max(1.0).step(0.001).onChange(function () {
          effectA.luminanceMaterial.threshold = effectB.luminanceMaterial.threshold = Number(params.luminance.threshold);
        });
        folder.add(params.luminance, "smoothing").min(0.0).max(1.0).step(0.001).onChange(function () {
          effectA.luminanceMaterial.smoothing = effectB.luminanceMaterial.smoothing = Number(params.luminance.smoothing);
        });
        folder.open();
        folder = menu.addFolder("Selection");
        folder.add(params.selection, "enabled").onChange(function () {
          passB.enabled = params.selection.enabled;
          passA.enabled = !passB.enabled;

          if (passB.enabled) {
            renderer.domElement.addEventListener("mousemove", _this55);
            renderer.domElement.addEventListener("mousedown", _this55);
          } else {
            renderer.domElement.removeEventListener("mousemove", _this55);
            renderer.domElement.removeEventListener("mousedown", _this55);
          }
        });
        folder.add(params.selection, "inverted").onChange(function () {
          effectB.inverted = params.selection.inverted;
        });
        folder.add(params.selection, "ignore bg").onChange(function () {
          effectB.ignoreBackground = params.selection["ignore bg"];
        });
        menu.add(params, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          blendModeA.opacity.value = blendModeB.opacity.value = params.opacity;
        });
        menu.add(params, "blend mode", BlendFunction).onChange(function () {
          blendModeA.blendFunction = blendModeB.blendFunction = Number(params["blend mode"]);
          passA.recompile();
          passB.recompile();
        });
        menu.add(passA, "dithering").onChange(function () {
          passB.dithering = passA.dithering;
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        _get(_getPrototypeOf(BloomDemo.prototype), "reset", this).call(this);

        var dom = this.composer.getRenderer().domElement;
        dom.removeEventListener("mousemove", this);
        dom.removeEventListener("mousedown", this);
        return this;
      }
    }]);

    return BloomDemo;
  }(PostProcessingDemo);

  var BlurDemo = function (_PostProcessingDemo2) {
    _inherits(BlurDemo, _PostProcessingDemo2);

    function BlurDemo(composer) {
      var _this56;

      _classCallCheck(this, BlurDemo);

      _this56 = _possibleConstructorReturn(this, _getPrototypeOf(BlurDemo).call(this, "blur", composer));
      _this56.blurPass = null;
      _this56.texturePass = null;
      _this56.textureEffect = null;
      _this56.object = null;
      return _this56;
    }

    _createClass(BlurDemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var cubeTextureLoader = new CubeTextureLoader(loadingManager);
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var path = "textures/skies/sunset/";
        var format = ".png";
        var urls = [path + "px" + format, path + "nx" + format, path + "py" + format, path + "ny" + format, path + "pz" + format, path + "nz" + format];
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            cubeTextureLoader.load(urls, function (t) {
              t.encoding = sRGBEncoding;
              assets.set("sky", t);
            });
            smaaImageLoader.load(function (_ref30) {
              var _ref31 = _slicedToArray(_ref30, 2),
                  search = _ref31[0],
                  area = _ref31[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 1, 2000);
        camera.position.set(-15, 0, -15);
        camera.lookAt(scene.position);
        this.camera = camera;
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = false;
        controls.settings.sensitivity.zoom = 1.0;
        controls.lookAt(scene.position);
        this.controls = controls;
        scene.background = assets.get("sky");
        var ambientLight = new AmbientLight(0x212121);
        var mainLight = new DirectionalLight(0xff7e66, 1.0);
        var backLight = new DirectionalLight(0xff7e66, 0.1);
        mainLight.position.set(1.44, 0.2, 2.0);
        backLight.position.copy(mainLight.position).negate();
        scene.add(ambientLight);
        scene.add(mainLight);
        scene.add(backLight);
        this.object = SphereCloud.create();
        scene.add(this.object);
        var savePass = new SavePass();
        var blurPass = new BlurPass({
          height: 480
        });
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.LUMA);
        var textureEffect = new TextureEffect({
          texture: savePass.renderTarget.texture
        });
        var smaaPass = new EffectPass(camera, smaaEffect);
        var texturePass = new EffectPass(camera, textureEffect);
        textureEffect.blendMode.opacity.value = 0.0;
        this.blurPass = blurPass;
        this.texturePass = texturePass;
        this.textureEffect = textureEffect;
        composer.addPass(smaaPass);
        composer.addPass(savePass);
        composer.addPass(blurPass);
        composer.addPass(texturePass);
      }
    }, {
      key: "render",
      value: function render(delta) {
        var object = this.object;
        var PI2 = 2.0 * Math.PI;
        object.rotation.x += 0.05 * delta;
        object.rotation.y += 0.25 * delta;

        if (object.rotation.x >= PI2) {
          object.rotation.x -= PI2;
        }

        if (object.rotation.y >= PI2) {
          object.rotation.y -= PI2;
        }

        _get(_getPrototypeOf(BlurDemo.prototype), "render", this).call(this, delta);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var textureEffect = this.textureEffect;
        var texturePass = this.texturePass;
        var blurPass = this.blurPass;
        var blendMode = textureEffect.blendMode;
        var params = {
          "resolution": blurPass.height,
          "kernel size": blurPass.kernelSize,
          "scale": blurPass.scale,
          "opacity": 1.0 - blendMode.opacity.value,
          "blend mode": blendMode.blendFunction
        };
        menu.add(params, "resolution", [240, 360, 480, 720, 1080]).onChange(function () {
          blurPass.resolution.height = Number(params.resolution);
        });
        menu.add(params, "kernel size", KernelSize).onChange(function () {
          blurPass.kernelSize = Number(params["kernel size"]);
        });
        menu.add(params, "scale").min(0.0).max(1.0).step(0.01).onChange(function () {
          blurPass.scale = Number(params.scale);
        });
        menu.add(blurPass, "enabled");
        menu.add(texturePass, "dithering");
        menu.add(params, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          blendMode.opacity.value = 1.0 - params.opacity;
        });
        menu.add(params, "blend mode", BlendFunction).onChange(function () {
          blendMode.blendFunction = Number(params["blend mode"]);
          texturePass.recompile();
        });
      }
    }]);

    return BlurDemo;
  }(PostProcessingDemo);

  var GLTFLoader = function () {
    function GLTFLoader(manager) {
      Loader.call(this, manager);
      this.dracoLoader = null;
      this.ddsLoader = null;
    }

    GLTFLoader.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: GLTFLoader,
      load: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var resourcePath;

        if (this.resourcePath !== '') {
          resourcePath = this.resourcePath;
        } else if (this.path !== '') {
          resourcePath = this.path;
        } else {
          resourcePath = LoaderUtils.extractUrlBase(url);
        }

        scope.manager.itemStart(url);

        var _onError = function _onError(e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }

          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        };

        var loader = new FileLoader(scope.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');

        if (scope.crossOrigin === 'use-credentials') {
          loader.setWithCredentials(true);
        }

        loader.load(url, function (data) {
          try {
            scope.parse(data, resourcePath, function (gltf) {
              onLoad(gltf);
              scope.manager.itemEnd(url);
            }, _onError);
          } catch (e) {
            _onError(e);
          }
        }, onProgress, _onError);
      },
      setDRACOLoader: function setDRACOLoader(dracoLoader) {
        this.dracoLoader = dracoLoader;
        return this;
      },
      setDDSLoader: function setDDSLoader(ddsLoader) {
        this.ddsLoader = ddsLoader;
        return this;
      },
      parse: function parse(data, path, onLoad, onError) {
        var content;
        var extensions = {};

        if (typeof data === 'string') {
          content = data;
        } else {
          var magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));

          if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
            try {
              extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
            } catch (error) {
              if (onError) onError(error);
              return;
            }

            content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
          } else {
            content = LoaderUtils.decodeText(new Uint8Array(data));
          }
        }

        var json = JSON.parse(content);

        if (json.asset === undefined || json.asset.version[0] < 2) {
          if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
          return;
        }

        if (json.extensionsUsed) {
          for (var i = 0; i < json.extensionsUsed.length; ++i) {
            var extensionName = json.extensionsUsed[i];
            var extensionsRequired = json.extensionsRequired || [];

            switch (extensionName) {
              case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:
                extensions[extensionName] = new GLTFLightsExtension(json);
                break;

              case EXTENSIONS.KHR_MATERIALS_UNLIT:
                extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                break;

              case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
                break;

              case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                break;

              case EXTENSIONS.MSFT_TEXTURE_DDS:
                extensions[extensionName] = new GLTFTextureDDSExtension(this.ddsLoader);
                break;

              case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                extensions[extensionName] = new GLTFTextureTransformExtension();
                break;

              case EXTENSIONS.KHR_MESH_QUANTIZATION:
                extensions[extensionName] = new GLTFMeshQuantizationExtension();
                break;

              default:
                if (extensionsRequired.indexOf(extensionName) >= 0) {
                  console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
                }

            }
          }
        }

        var parser = new GLTFParser(json, extensions, {
          path: path || this.resourcePath || '',
          crossOrigin: this.crossOrigin,
          manager: this.manager
        });
        parser.parse(onLoad, onError);
      }
    });

    function GLTFRegistry() {
      var objects = {};
      return {
        get: function get(key) {
          return objects[key];
        },
        add: function add(key, object) {
          objects[key] = object;
        },
        remove: function remove(key) {
          delete objects[key];
        },
        removeAll: function removeAll() {
          objects = {};
        }
      };
    }

    var EXTENSIONS = {
      KHR_BINARY_GLTF: 'KHR_binary_glTF',
      KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
      KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
      KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
      KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
      KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
      KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
      MSFT_TEXTURE_DDS: 'MSFT_texture_dds'
    };

    function GLTFTextureDDSExtension(ddsLoader) {
      if (!ddsLoader) {
        throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader');
      }

      this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
      this.ddsLoader = ddsLoader;
    }

    function GLTFLightsExtension(json) {
      this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
      var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};
      this.lightDefs = extension.lights || [];
    }

    GLTFLightsExtension.prototype.loadLight = function (lightIndex) {
      var lightDef = this.lightDefs[lightIndex];
      var lightNode;
      var color = new Color(0xffffff);
      if (lightDef.color !== undefined) color.fromArray(lightDef.color);
      var range = lightDef.range !== undefined ? lightDef.range : 0;

      switch (lightDef.type) {
        case 'directional':
          lightNode = new DirectionalLight(color);
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;

        case 'point':
          lightNode = new PointLight(color);
          lightNode.distance = range;
          break;

        case 'spot':
          lightNode = new SpotLight(color);
          lightNode.distance = range;
          lightDef.spot = lightDef.spot || {};
          lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
          lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
          lightNode.angle = lightDef.spot.outerConeAngle;
          lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;

        default:
          throw new Error('THREE.GLTFLoader: Unexpected light type, "' + lightDef.type + '".');
      }

      lightNode.position.set(0, 0, 0);
      lightNode.decay = 2;
      if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;
      lightNode.name = lightDef.name || 'light_' + lightIndex;
      return Promise.resolve(lightNode);
    };

    function GLTFMaterialsUnlitExtension() {
      this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
    }

    GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {
      return MeshBasicMaterial;
    };

    GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {
      var pending = [];
      materialParams.color = new Color(1.0, 1.0, 1.0);
      materialParams.opacity = 1.0;
      var metallicRoughness = materialDef.pbrMetallicRoughness;

      if (metallicRoughness) {
        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          var array = metallicRoughness.baseColorFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }

        if (metallicRoughness.baseColorTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
        }
      }

      return Promise.all(pending);
    };

    var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
    var BINARY_EXTENSION_HEADER_LENGTH = 12;
    var BINARY_EXTENSION_CHUNK_TYPES = {
      JSON: 0x4E4F534A,
      BIN: 0x004E4942
    };

    function GLTFBinaryExtension(data) {
      this.name = EXTENSIONS.KHR_BINARY_GLTF;
      this.content = null;
      this.body = null;
      var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
      this.header = {
        magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
        version: headerView.getUint32(4, true),
        length: headerView.getUint32(8, true)
      };

      if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
        throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
      } else if (this.header.version < 2.0) {
        throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
      }

      var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
      var chunkIndex = 0;

      while (chunkIndex < chunkView.byteLength) {
        var chunkLength = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;
        var chunkType = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;

        if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
          var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
          this.content = LoaderUtils.decodeText(contentArray);
        } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
          var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
          this.body = data.slice(byteOffset, byteOffset + chunkLength);
        }

        chunkIndex += chunkLength;
      }

      if (this.content === null) {
        throw new Error('THREE.GLTFLoader: JSON content not found.');
      }
    }

    function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
      if (!dracoLoader) {
        throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
      }

      this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
      this.json = json;
      this.dracoLoader = dracoLoader;
      this.dracoLoader.preload();
    }

    GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {
      var json = this.json;
      var dracoLoader = this.dracoLoader;
      var bufferViewIndex = primitive.extensions[this.name].bufferView;
      var gltfAttributeMap = primitive.extensions[this.name].attributes;
      var threeAttributeMap = {};
      var attributeNormalizedMap = {};
      var attributeTypeMap = {};

      for (var attributeName in gltfAttributeMap) {
        var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
        threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
      }

      for (attributeName in primitive.attributes) {
        var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();

        if (gltfAttributeMap[attributeName] !== undefined) {
          var accessorDef = json.accessors[primitive.attributes[attributeName]];
          var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
          attributeTypeMap[threeAttributeName] = componentType;
          attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
        }
      }

      return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {
        return new Promise(function (resolve) {
          dracoLoader.decodeDracoFile(bufferView, function (geometry) {
            for (var attributeName in geometry.attributes) {
              var attribute = geometry.attributes[attributeName];
              var normalized = attributeNormalizedMap[attributeName];
              if (normalized !== undefined) attribute.normalized = normalized;
            }

            resolve(geometry);
          }, threeAttributeMap, attributeTypeMap);
        });
      });
    };

    function GLTFTextureTransformExtension() {
      this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
    }

    GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {
      texture = texture.clone();

      if (transform.offset !== undefined) {
        texture.offset.fromArray(transform.offset);
      }

      if (transform.rotation !== undefined) {
        texture.rotation = transform.rotation;
      }

      if (transform.scale !== undefined) {
        texture.repeat.fromArray(transform.scale);
      }

      if (transform.texCoord !== undefined) {
        console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
      }

      texture.needsUpdate = true;
      return texture;
    };

    function GLTFMeshStandardSGMaterial(params) {
      MeshStandardMaterial.call(this);
      this.isGLTFSpecularGlossinessMaterial = true;
      var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif'].join('\n');
      var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif'].join('\n');
      var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif'].join('\n');
      var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif'].join('\n');
      var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.specularRoughness += geometryRoughness;', 'material.specularRoughness = min( material.specularRoughness, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\n');
      var uniforms = {
        specular: {
          value: new Color().setHex(0xffffff)
        },
        glossiness: {
          value: 1
        },
        specularMap: {
          value: null
        },
        glossinessMap: {
          value: null
        }
      };
      this._extraUniforms = uniforms;

      this.onBeforeCompile = function (shader) {
        for (var uniformName in uniforms) {
          shader.uniforms[uniformName] = uniforms[uniformName];
        }

        shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;');
        shader.fragmentShader = shader.fragmentShader.replace('uniform float metalness;', 'uniform float glossiness;');
        shader.fragmentShader = shader.fragmentShader.replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk);
        shader.fragmentShader = shader.fragmentShader.replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk);
        shader.fragmentShader = shader.fragmentShader.replace('#include <roughnessmap_fragment>', specularMapFragmentChunk);
        shader.fragmentShader = shader.fragmentShader.replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk);
        shader.fragmentShader = shader.fragmentShader.replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);
      };

      Object.defineProperties(this, {
        specular: {
          get: function get() {
            return uniforms.specular.value;
          },
          set: function set(v) {
            uniforms.specular.value = v;
          }
        },
        specularMap: {
          get: function get() {
            return uniforms.specularMap.value;
          },
          set: function set(v) {
            uniforms.specularMap.value = v;
          }
        },
        glossiness: {
          get: function get() {
            return uniforms.glossiness.value;
          },
          set: function set(v) {
            uniforms.glossiness.value = v;
          }
        },
        glossinessMap: {
          get: function get() {
            return uniforms.glossinessMap.value;
          },
          set: function set(v) {
            uniforms.glossinessMap.value = v;

            if (v) {
              this.defines.USE_GLOSSINESSMAP = '';
              this.defines.USE_ROUGHNESSMAP = '';
            } else {
              delete this.defines.USE_ROUGHNESSMAP;
              delete this.defines.USE_GLOSSINESSMAP;
            }
          }
        }
      });
      delete this.metalness;
      delete this.roughness;
      delete this.metalnessMap;
      delete this.roughnessMap;
      this.setValues(params);
    }

    GLTFMeshStandardSGMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
    GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;

    GLTFMeshStandardSGMaterial.prototype.copy = function (source) {
      MeshStandardMaterial.prototype.copy.call(this, source);
      this.specularMap = source.specularMap;
      this.specular.copy(source.specular);
      this.glossinessMap = source.glossinessMap;
      this.glossiness = source.glossiness;
      delete this.metalness;
      delete this.roughness;
      delete this.metalnessMap;
      delete this.roughnessMap;
      return this;
    };

    function GLTFMaterialsPbrSpecularGlossinessExtension() {
      return {
        name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
        specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],
        getMaterialType: function getMaterialType() {
          return GLTFMeshStandardSGMaterial;
        },
        extendParams: function extendParams(materialParams, materialDef, parser) {
          var pbrSpecularGlossiness = materialDef.extensions[this.name];
          materialParams.color = new Color(1.0, 1.0, 1.0);
          materialParams.opacity = 1.0;
          var pending = [];

          if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
            var array = pbrSpecularGlossiness.diffuseFactor;
            materialParams.color.fromArray(array);
            materialParams.opacity = array[3];
          }

          if (pbrSpecularGlossiness.diffuseTexture !== undefined) {
            pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));
          }

          materialParams.emissive = new Color(0.0, 0.0, 0.0);
          materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
          materialParams.specular = new Color(1.0, 1.0, 1.0);

          if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
            materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
          }

          if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
            var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
            pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));
            pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));
          }

          return Promise.all(pending);
        },
        createMaterial: function createMaterial(materialParams) {
          var material = new GLTFMeshStandardSGMaterial(materialParams);
          material.fog = true;
          material.color = materialParams.color;
          material.map = materialParams.map === undefined ? null : materialParams.map;
          material.lightMap = null;
          material.lightMapIntensity = 1.0;
          material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
          material.aoMapIntensity = 1.0;
          material.emissive = materialParams.emissive;
          material.emissiveIntensity = 1.0;
          material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;
          material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
          material.bumpScale = 1;
          material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
          material.normalMapType = TangentSpaceNormalMap;
          if (materialParams.normalScale) material.normalScale = materialParams.normalScale;
          material.displacementMap = null;
          material.displacementScale = 1;
          material.displacementBias = 0;
          material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
          material.specular = materialParams.specular;
          material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
          material.glossiness = materialParams.glossiness;
          material.alphaMap = null;
          material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
          material.envMapIntensity = 1.0;
          material.refractionRatio = 0.98;
          return material;
        }
      };
    }

    function GLTFMeshQuantizationExtension() {
      this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
    }

    function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }

    GLTFCubicSplineInterpolant.prototype = Object.create(Interpolant.prototype);
    GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

    GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {
      var result = this.resultBuffer,
          values = this.sampleValues,
          valueSize = this.valueSize,
          offset = index * valueSize * 3 + valueSize;

      for (var i = 0; i !== valueSize; i++) {
        result[i] = values[offset + i];
      }

      return result;
    };

    GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
    GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

    GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
      var result = this.resultBuffer;
      var values = this.sampleValues;
      var stride = this.valueSize;
      var stride2 = stride * 2;
      var stride3 = stride * 3;
      var td = t1 - t0;
      var p = (t - t0) / td;
      var pp = p * p;
      var ppp = pp * p;
      var offset1 = i1 * stride3;
      var offset0 = offset1 - stride3;
      var s2 = -2 * ppp + 3 * pp;
      var s3 = ppp - pp;
      var s0 = 1 - s2;
      var s1 = s3 - pp + p;

      for (var i = 0; i !== stride; i++) {
        var p0 = values[offset0 + i + stride];
        var m0 = values[offset0 + i + stride2] * td;
        var p1 = values[offset1 + i + stride];
        var m1 = values[offset1 + i] * td;
        result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
      }

      return result;
    };

    var WEBGL_CONSTANTS = {
      FLOAT: 5126,
      FLOAT_MAT3: 35675,
      FLOAT_MAT4: 35676,
      FLOAT_VEC2: 35664,
      FLOAT_VEC3: 35665,
      FLOAT_VEC4: 35666,
      LINEAR: 9729,
      REPEAT: 10497,
      SAMPLER_2D: 35678,
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6,
      UNSIGNED_BYTE: 5121,
      UNSIGNED_SHORT: 5123
    };
    var WEBGL_COMPONENT_TYPES = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array
    };
    var WEBGL_FILTERS = {
      9728: NearestFilter,
      9729: LinearFilter,
      9984: NearestMipmapNearestFilter,
      9985: LinearMipmapNearestFilter,
      9986: NearestMipmapLinearFilter,
      9987: LinearMipmapLinearFilter
    };
    var WEBGL_WRAPPINGS = {
      33071: ClampToEdgeWrapping,
      33648: MirroredRepeatWrapping,
      10497: RepeatWrapping
    };
    var WEBGL_TYPE_SIZES = {
      'SCALAR': 1,
      'VEC2': 2,
      'VEC3': 3,
      'VEC4': 4,
      'MAT2': 4,
      'MAT3': 9,
      'MAT4': 16
    };
    var ATTRIBUTES = {
      POSITION: 'position',
      NORMAL: 'normal',
      TANGENT: 'tangent',
      TEXCOORD_0: 'uv',
      TEXCOORD_1: 'uv2',
      COLOR_0: 'color',
      WEIGHTS_0: 'skinWeight',
      JOINTS_0: 'skinIndex'
    };
    var PATH_PROPERTIES = {
      scale: 'scale',
      translation: 'position',
      rotation: 'quaternion',
      weights: 'morphTargetInfluences'
    };
    var INTERPOLATION = {
      CUBICSPLINE: undefined,
      LINEAR: InterpolateLinear,
      STEP: InterpolateDiscrete
    };
    var ALPHA_MODES = {
      OPAQUE: 'OPAQUE',
      MASK: 'MASK',
      BLEND: 'BLEND'
    };
    var MIME_TYPE_FORMATS = {
      'image/png': RGBAFormat,
      'image/jpeg': RGBFormat
    };

    function resolveURL(url, path) {
      if (typeof url !== 'string' || url === '') return '';

      if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
        path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
      }

      if (/^(https?:)?\/\//i.test(url)) return url;
      if (/^data:.*,.*$/i.test(url)) return url;
      if (/^blob:.*$/i.test(url)) return url;
      return path + url;
    }

    function createDefaultMaterial(cache) {
      if (cache['DefaultMaterial'] === undefined) {
        cache['DefaultMaterial'] = new MeshStandardMaterial({
          color: 0xFFFFFF,
          emissive: 0x000000,
          metalness: 1,
          roughness: 1,
          transparent: false,
          depthTest: true,
          side: FrontSide
        });
      }

      return cache['DefaultMaterial'];
    }

    function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
      for (var name in objectDef.extensions) {
        if (knownExtensions[name] === undefined) {
          object.userData.gltfExtensions = object.userData.gltfExtensions || {};
          object.userData.gltfExtensions[name] = objectDef.extensions[name];
        }
      }
    }

    function assignExtrasToUserData(object, gltfDef) {
      if (gltfDef.extras !== undefined) {
        if (_typeof(gltfDef.extras) === 'object') {
          Object.assign(object.userData, gltfDef.extras);
        } else {
          console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);
        }
      }
    }

    function addMorphTargets(geometry, targets, parser) {
      var hasMorphPosition = false;
      var hasMorphNormal = false;

      for (var i = 0, il = targets.length; i < il; i++) {
        var target = targets[i];
        if (target.POSITION !== undefined) hasMorphPosition = true;
        if (target.NORMAL !== undefined) hasMorphNormal = true;
        if (hasMorphPosition && hasMorphNormal) break;
      }

      if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);
      var pendingPositionAccessors = [];
      var pendingNormalAccessors = [];

      for (var i = 0, il = targets.length; i < il; i++) {
        var target = targets[i];

        if (hasMorphPosition) {
          var pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;
          pendingPositionAccessors.push(pendingAccessor);
        }

        if (hasMorphNormal) {
          var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;
          pendingNormalAccessors.push(pendingAccessor);
        }
      }

      return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {
        var morphPositions = accessors[0];
        var morphNormals = accessors[1];
        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
        geometry.morphTargetsRelative = true;
        return geometry;
      });
    }

    function updateMorphTargets(mesh, meshDef) {
      mesh.updateMorphTargets();

      if (meshDef.weights !== undefined) {
        for (var i = 0, il = meshDef.weights.length; i < il; i++) {
          mesh.morphTargetInfluences[i] = meshDef.weights[i];
        }
      }

      if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
        var targetNames = meshDef.extras.targetNames;

        if (mesh.morphTargetInfluences.length === targetNames.length) {
          mesh.morphTargetDictionary = {};

          for (var i = 0, il = targetNames.length; i < il; i++) {
            mesh.morphTargetDictionary[targetNames[i]] = i;
          }
        } else {
          console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
        }
      }
    }

    function createPrimitiveKey(primitiveDef) {
      var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
      var geometryKey;

      if (dracoExtension) {
        geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);
      } else {
        geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;
      }

      return geometryKey;
    }

    function createAttributesKey(attributes) {
      var attributesKey = '';
      var keys = Object.keys(attributes).sort();

      for (var i = 0, il = keys.length; i < il; i++) {
        attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';
      }

      return attributesKey;
    }

    function GLTFParser(json, extensions, options) {
      this.json = json || {};
      this.extensions = extensions || {};
      this.options = options || {};
      this.cache = new GLTFRegistry();
      this.primitiveCache = {};
      this.textureLoader = new TextureLoader(this.options.manager);
      this.textureLoader.setCrossOrigin(this.options.crossOrigin);
      this.fileLoader = new FileLoader(this.options.manager);
      this.fileLoader.setResponseType('arraybuffer');

      if (this.options.crossOrigin === 'use-credentials') {
        this.fileLoader.setWithCredentials(true);
      }
    }

    GLTFParser.prototype.parse = function (onLoad, onError) {
      var parser = this;
      var json = this.json;
      var extensions = this.extensions;
      this.cache.removeAll();
      this.markDefs();
      Promise.all([this.getDependencies('scene'), this.getDependencies('animation'), this.getDependencies('camera')]).then(function (dependencies) {
        var result = {
          scene: dependencies[0][json.scene || 0],
          scenes: dependencies[0],
          animations: dependencies[1],
          cameras: dependencies[2],
          asset: json.asset,
          parser: parser,
          userData: {}
        };
        addUnknownExtensionsToUserData(extensions, result, json);
        assignExtrasToUserData(result, json);
        onLoad(result);
      })["catch"](onError);
    };

    GLTFParser.prototype.markDefs = function () {
      var nodeDefs = this.json.nodes || [];
      var skinDefs = this.json.skins || [];
      var meshDefs = this.json.meshes || [];
      var meshReferences = {};
      var meshUses = {};

      for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
        var joints = skinDefs[skinIndex].joints;

        for (var i = 0, il = joints.length; i < il; i++) {
          nodeDefs[joints[i]].isBone = true;
        }
      }

      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
        var nodeDef = nodeDefs[nodeIndex];

        if (nodeDef.mesh !== undefined) {
          if (meshReferences[nodeDef.mesh] === undefined) {
            meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;
          }

          meshReferences[nodeDef.mesh]++;

          if (nodeDef.skin !== undefined) {
            meshDefs[nodeDef.mesh].isSkinnedMesh = true;
          }
        }
      }

      this.json.meshReferences = meshReferences;
      this.json.meshUses = meshUses;
    };

    GLTFParser.prototype.getDependency = function (type, index) {
      var cacheKey = type + ':' + index;
      var dependency = this.cache.get(cacheKey);

      if (!dependency) {
        switch (type) {
          case 'scene':
            dependency = this.loadScene(index);
            break;

          case 'node':
            dependency = this.loadNode(index);
            break;

          case 'mesh':
            dependency = this.loadMesh(index);
            break;

          case 'accessor':
            dependency = this.loadAccessor(index);
            break;

          case 'bufferView':
            dependency = this.loadBufferView(index);
            break;

          case 'buffer':
            dependency = this.loadBuffer(index);
            break;

          case 'material':
            dependency = this.loadMaterial(index);
            break;

          case 'texture':
            dependency = this.loadTexture(index);
            break;

          case 'skin':
            dependency = this.loadSkin(index);
            break;

          case 'animation':
            dependency = this.loadAnimation(index);
            break;

          case 'camera':
            dependency = this.loadCamera(index);
            break;

          case 'light':
            dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);
            break;

          default:
            throw new Error('Unknown type: ' + type);
        }

        this.cache.add(cacheKey, dependency);
      }

      return dependency;
    };

    GLTFParser.prototype.getDependencies = function (type) {
      var dependencies = this.cache.get(type);

      if (!dependencies) {
        var parser = this;
        var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];
        dependencies = Promise.all(defs.map(function (def, index) {
          return parser.getDependency(type, index);
        }));
        this.cache.add(type, dependencies);
      }

      return dependencies;
    };

    GLTFParser.prototype.loadBuffer = function (bufferIndex) {
      var bufferDef = this.json.buffers[bufferIndex];
      var loader = this.fileLoader;

      if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
        throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');
      }

      if (bufferDef.uri === undefined && bufferIndex === 0) {
        return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
      }

      var options = this.options;
      return new Promise(function (resolve, reject) {
        loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {
          reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
        });
      });
    };

    GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {
      var bufferViewDef = this.json.bufferViews[bufferViewIndex];
      return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {
        var byteLength = bufferViewDef.byteLength || 0;
        var byteOffset = bufferViewDef.byteOffset || 0;
        return buffer.slice(byteOffset, byteOffset + byteLength);
      });
    };

    GLTFParser.prototype.loadAccessor = function (accessorIndex) {
      var parser = this;
      var json = this.json;
      var accessorDef = this.json.accessors[accessorIndex];

      if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {
        return Promise.resolve(null);
      }

      var pendingBufferViews = [];

      if (accessorDef.bufferView !== undefined) {
        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));
      } else {
        pendingBufferViews.push(null);
      }

      if (accessorDef.sparse !== undefined) {
        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));
      }

      return Promise.all(pendingBufferViews).then(function (bufferViews) {
        var bufferView = bufferViews[0];
        var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
        var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        var elementBytes = TypedArray.BYTES_PER_ELEMENT;
        var itemBytes = elementBytes * itemSize;
        var byteOffset = accessorDef.byteOffset || 0;
        var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
        var normalized = accessorDef.normalized === true;
        var array, bufferAttribute;

        if (byteStride && byteStride !== itemBytes) {
          var ibSlice = Math.floor(byteOffset / byteStride);
          var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
          var ib = parser.cache.get(ibCacheKey);

          if (!ib) {
            array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
            ib = new InterleavedBuffer(array, byteStride / elementBytes);
            parser.cache.add(ibCacheKey, ib);
          }

          bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
        } else {
          if (bufferView === null) {
            array = new TypedArray(accessorDef.count * itemSize);
          } else {
            array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
          }

          bufferAttribute = new BufferAttribute(array, itemSize, normalized);
        }

        if (accessorDef.sparse !== undefined) {
          var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
          var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
          var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
          var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
          var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
          var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);

          if (bufferView !== null) {
            bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
          }

          for (var i = 0, il = sparseIndices.length; i < il; i++) {
            var index = sparseIndices[i];
            bufferAttribute.setX(index, sparseValues[i * itemSize]);
            if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
            if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
            if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
            if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
          }
        }

        return bufferAttribute;
      });
    };

    GLTFParser.prototype.loadTexture = function (textureIndex) {
      var parser = this;
      var json = this.json;
      var options = this.options;
      var textureLoader = this.textureLoader;
      var URL = window.URL || window.webkitURL;
      var textureDef = json.textures[textureIndex];
      var textureExtensions = textureDef.extensions || {};
      var source;

      if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {
        source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];
      } else {
        source = json.images[textureDef.source];
      }

      var sourceURI = source.uri;
      var isObjectURL = false;

      if (source.bufferView !== undefined) {
        sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {
          isObjectURL = true;
          var blob = new Blob([bufferView], {
            type: source.mimeType
          });
          sourceURI = URL.createObjectURL(blob);
          return sourceURI;
        });
      }

      return Promise.resolve(sourceURI).then(function (sourceURI) {
        var loader = options.manager.getHandler(sourceURI);

        if (!loader) {
          loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;
        }

        return new Promise(function (resolve, reject) {
          loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);
        });
      }).then(function (texture) {
        if (isObjectURL === true) {
          URL.revokeObjectURL(sourceURI);
        }

        texture.flipY = false;
        if (textureDef.name !== undefined) texture.name = textureDef.name;

        if (source.mimeType in MIME_TYPE_FORMATS) {
          texture.format = MIME_TYPE_FORMATS[source.mimeType];
        }

        var samplers = json.samplers || {};
        var sampler = samplers[textureDef.sampler] || {};
        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
        return texture;
      });
    };

    GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {
      var parser = this;
      return this.getDependency('texture', mapDef.index).then(function (texture) {
        if (!texture.isCompressedTexture) {
          switch (mapName) {
            case 'aoMap':
            case 'emissiveMap':
            case 'metalnessMap':
            case 'normalMap':
            case 'roughnessMap':
              texture.format = RGBFormat;
              break;
          }
        }

        if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {
          console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');
        }

        if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
          var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;

          if (transform) {
            texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          }
        }

        materialParams[mapName] = texture;
      });
    };

    GLTFParser.prototype.assignFinalMaterial = function (mesh) {
      var geometry = mesh.geometry;
      var material = mesh.material;
      var extensions = this.extensions;
      var useVertexTangents = geometry.attributes.tangent !== undefined;
      var useVertexColors = geometry.attributes.color !== undefined;
      var useFlatShading = geometry.attributes.normal === undefined;
      var useSkinning = mesh.isSkinnedMesh === true;
      var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;
      var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

      if (mesh.isPoints) {
        var cacheKey = 'PointsMaterial:' + material.uuid;
        var pointsMaterial = this.cache.get(cacheKey);

        if (!pointsMaterial) {
          pointsMaterial = new PointsMaterial();
          Material.prototype.copy.call(pointsMaterial, material);
          pointsMaterial.color.copy(material.color);
          pointsMaterial.map = material.map;
          pointsMaterial.sizeAttenuation = false;
          this.cache.add(cacheKey, pointsMaterial);
        }

        material = pointsMaterial;
      } else if (mesh.isLine) {
        var cacheKey = 'LineBasicMaterial:' + material.uuid;
        var lineMaterial = this.cache.get(cacheKey);

        if (!lineMaterial) {
          lineMaterial = new LineBasicMaterial();
          Material.prototype.copy.call(lineMaterial, material);
          lineMaterial.color.copy(material.color);
          this.cache.add(cacheKey, lineMaterial);
        }

        material = lineMaterial;
      }

      if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {
        var cacheKey = 'ClonedMaterial:' + material.uuid + ':';
        if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';
        if (useSkinning) cacheKey += 'skinning:';
        if (useVertexTangents) cacheKey += 'vertex-tangents:';
        if (useVertexColors) cacheKey += 'vertex-colors:';
        if (useFlatShading) cacheKey += 'flat-shading:';
        if (useMorphTargets) cacheKey += 'morph-targets:';
        if (useMorphNormals) cacheKey += 'morph-normals:';
        var cachedMaterial = this.cache.get(cacheKey);

        if (!cachedMaterial) {
          cachedMaterial = material.clone();
          if (useSkinning) cachedMaterial.skinning = true;
          if (useVertexTangents) cachedMaterial.vertexTangents = true;
          if (useVertexColors) cachedMaterial.vertexColors = VertexColors;
          if (useFlatShading) cachedMaterial.flatShading = true;
          if (useMorphTargets) cachedMaterial.morphTargets = true;
          if (useMorphNormals) cachedMaterial.morphNormals = true;
          this.cache.add(cacheKey, cachedMaterial);
        }

        material = cachedMaterial;
      }

      if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {
        geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));
      }

      if (material.normalScale && !useVertexTangents) {
        material.normalScale.y = -material.normalScale.y;
      }

      mesh.material = material;
    };

    GLTFParser.prototype.loadMaterial = function (materialIndex) {
      var parser = this;
      var json = this.json;
      var extensions = this.extensions;
      var materialDef = json.materials[materialIndex];
      var materialType;
      var materialParams = {};
      var materialExtensions = materialDef.extensions || {};
      var pending = [];

      if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        materialType = sgExtension.getMaterialType();
        pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
      } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
        var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
        materialType = kmuExtension.getMaterialType();
        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
      } else {
        materialType = MeshStandardMaterial;
        var metallicRoughness = materialDef.pbrMetallicRoughness || {};
        materialParams.color = new Color(1.0, 1.0, 1.0);
        materialParams.opacity = 1.0;

        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          var array = metallicRoughness.baseColorFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }

        if (metallicRoughness.baseColorTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
        }

        materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
        materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

        if (metallicRoughness.metallicRoughnessTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
          pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));
        }
      }

      if (materialDef.doubleSided === true) {
        materialParams.side = DoubleSide;
      }

      var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

      if (alphaMode === ALPHA_MODES.BLEND) {
        materialParams.transparent = true;
      } else {
        materialParams.transparent = false;

        if (alphaMode === ALPHA_MODES.MASK) {
          materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
        }
      }

      if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));
        materialParams.normalScale = new Vector2(1, 1);

        if (materialDef.normalTexture.scale !== undefined) {
          materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);
        }
      }

      if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));

        if (materialDef.occlusionTexture.strength !== undefined) {
          materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
        }
      }

      if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {
        materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
      }

      if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));
      }

      return Promise.all(pending).then(function () {
        var material;

        if (materialType === GLTFMeshStandardSGMaterial) {
          material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
        } else {
          material = new materialType(materialParams);
        }

        if (materialDef.name !== undefined) material.name = materialDef.name;
        if (material.map) material.map.encoding = sRGBEncoding;
        if (material.emissiveMap) material.emissiveMap.encoding = sRGBEncoding;
        assignExtrasToUserData(material, materialDef);
        if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
        return material;
      });
    };

    function computeBounds(geometry, primitiveDef, parser) {
      var attributes = primitiveDef.attributes;
      var box = new Box3();

      if (attributes.POSITION !== undefined) {
        var accessor = parser.json.accessors[attributes.POSITION];
        var min = accessor.min;
        var max = accessor.max;

        if (min !== undefined && max !== undefined) {
          box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));
        } else {
          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
          return;
        }
      } else {
        return;
      }

      var targets = primitiveDef.targets;

      if (targets !== undefined) {
        var vector = new Vector3();

        for (var i = 0, il = targets.length; i < il; i++) {
          var target = targets[i];

          if (target.POSITION !== undefined) {
            var accessor = parser.json.accessors[target.POSITION];
            var min = accessor.min;
            var max = accessor.max;

            if (min !== undefined && max !== undefined) {
              vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
              vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
              vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
              box.expandByVector(vector);
            } else {
              console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
            }
          }
        }
      }

      geometry.boundingBox = box;
      var sphere = new Sphere();
      box.getCenter(sphere.center);
      sphere.radius = box.min.distanceTo(box.max) / 2;
      geometry.boundingSphere = sphere;
    }

    function addPrimitiveAttributes(geometry, primitiveDef, parser) {
      var attributes = primitiveDef.attributes;
      var pending = [];

      function assignAttributeAccessor(accessorIndex, attributeName) {
        return parser.getDependency('accessor', accessorIndex).then(function (accessor) {
          geometry.setAttribute(attributeName, accessor);
        });
      }

      for (var gltfAttributeName in attributes) {
        var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
        if (threeAttributeName in geometry.attributes) continue;
        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
      }

      if (primitiveDef.indices !== undefined && !geometry.index) {
        var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {
          geometry.setIndex(accessor);
        });
        pending.push(accessor);
      }

      assignExtrasToUserData(geometry, primitiveDef);
      computeBounds(geometry, primitiveDef, parser);
      return Promise.all(pending).then(function () {
        return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
      });
    }

    function toTrianglesDrawMode(geometry, drawMode) {
      var index = geometry.getIndex();

      if (index === null) {
        var indices = [];
        var position = geometry.getAttribute('position');

        if (position !== undefined) {
          for (var i = 0; i < position.count; i++) {
            indices.push(i);
          }

          geometry.setIndex(indices);
          index = geometry.getIndex();
        } else {
          console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
          return geometry;
        }
      }

      var numberOfTriangles = index.count - 2;
      var newIndices = [];

      if (drawMode === TriangleFanDrawMode) {
        for (var i = 1; i <= numberOfTriangles; i++) {
          newIndices.push(index.getX(0));
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
        }
      } else {
        for (var i = 0; i < numberOfTriangles; i++) {
          if (i % 2 === 0) {
            newIndices.push(index.getX(i));
            newIndices.push(index.getX(i + 1));
            newIndices.push(index.getX(i + 2));
          } else {
            newIndices.push(index.getX(i + 2));
            newIndices.push(index.getX(i + 1));
            newIndices.push(index.getX(i));
          }
        }
      }

      if (newIndices.length / 3 !== numberOfTriangles) {
        console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
      }

      var newGeometry = geometry.clone();
      newGeometry.setIndex(newIndices);
      return newGeometry;
    }

    GLTFParser.prototype.loadGeometries = function (primitives) {
      var parser = this;
      var extensions = this.extensions;
      var cache = this.primitiveCache;

      function createDracoPrimitive(primitive) {
        return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {
          return addPrimitiveAttributes(geometry, primitive, parser);
        });
      }

      var pending = [];

      for (var i = 0, il = primitives.length; i < il; i++) {
        var primitive = primitives[i];
        var cacheKey = createPrimitiveKey(primitive);
        var cached = cache[cacheKey];

        if (cached) {
          pending.push(cached.promise);
        } else {
          var geometryPromise;

          if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
            geometryPromise = createDracoPrimitive(primitive);
          } else {
            geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
          }

          cache[cacheKey] = {
            primitive: primitive,
            promise: geometryPromise
          };
          pending.push(geometryPromise);
        }
      }

      return Promise.all(pending);
    };

    GLTFParser.prototype.loadMesh = function (meshIndex) {
      var parser = this;
      var json = this.json;
      var meshDef = json.meshes[meshIndex];
      var primitives = meshDef.primitives;
      var pending = [];

      for (var i = 0, il = primitives.length; i < il; i++) {
        var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);
        pending.push(material);
      }

      pending.push(parser.loadGeometries(primitives));
      return Promise.all(pending).then(function (results) {
        var materials = results.slice(0, results.length - 1);
        var geometries = results[results.length - 1];
        var meshes = [];

        for (var i = 0, il = geometries.length; i < il; i++) {
          var geometry = geometries[i];
          var primitive = primitives[i];
          var mesh;
          var material = materials[i];

          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
            mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);

            if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
              mesh.normalizeSkinWeights();
            }

            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
            }
          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
            mesh = new LineSegments(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
            mesh = new Line(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
            mesh = new LineLoop(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
            mesh = new Points(geometry, material);
          } else {
            throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);
          }

          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
            updateMorphTargets(mesh, meshDef);
          }

          mesh.name = meshDef.name || 'mesh_' + meshIndex;
          if (geometries.length > 1) mesh.name += '_' + i;
          assignExtrasToUserData(mesh, meshDef);
          parser.assignFinalMaterial(mesh);
          meshes.push(mesh);
        }

        if (meshes.length === 1) {
          return meshes[0];
        }

        var group = new Group();

        for (var i = 0, il = meshes.length; i < il; i++) {
          group.add(meshes[i]);
        }

        return group;
      });
    };

    GLTFParser.prototype.loadCamera = function (cameraIndex) {
      var camera;
      var cameraDef = this.json.cameras[cameraIndex];
      var params = cameraDef[cameraDef.type];

      if (!params) {
        console.warn('THREE.GLTFLoader: Missing camera parameters.');
        return;
      }

      if (cameraDef.type === 'perspective') {
        camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
      } else if (cameraDef.type === 'orthographic') {
        camera = new OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);
      }

      if (cameraDef.name !== undefined) camera.name = cameraDef.name;
      assignExtrasToUserData(camera, cameraDef);
      return Promise.resolve(camera);
    };

    GLTFParser.prototype.loadSkin = function (skinIndex) {
      var skinDef = this.json.skins[skinIndex];
      var skinEntry = {
        joints: skinDef.joints
      };

      if (skinDef.inverseBindMatrices === undefined) {
        return Promise.resolve(skinEntry);
      }

      return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {
        skinEntry.inverseBindMatrices = accessor;
        return skinEntry;
      });
    };

    GLTFParser.prototype.loadAnimation = function (animationIndex) {
      var json = this.json;
      var animationDef = json.animations[animationIndex];
      var pendingNodes = [];
      var pendingInputAccessors = [];
      var pendingOutputAccessors = [];
      var pendingSamplers = [];
      var pendingTargets = [];

      for (var i = 0, il = animationDef.channels.length; i < il; i++) {
        var channel = animationDef.channels[i];
        var sampler = animationDef.samplers[channel.sampler];
        var target = channel.target;
        var name = target.node !== undefined ? target.node : target.id;
        var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
        var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;
        pendingNodes.push(this.getDependency('node', name));
        pendingInputAccessors.push(this.getDependency('accessor', input));
        pendingOutputAccessors.push(this.getDependency('accessor', output));
        pendingSamplers.push(sampler);
        pendingTargets.push(target);
      }

      return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {
        var nodes = dependencies[0];
        var inputAccessors = dependencies[1];
        var outputAccessors = dependencies[2];
        var samplers = dependencies[3];
        var targets = dependencies[4];
        var tracks = [];

        for (var i = 0, il = nodes.length; i < il; i++) {
          var node = nodes[i];
          var inputAccessor = inputAccessors[i];
          var outputAccessor = outputAccessors[i];
          var sampler = samplers[i];
          var target = targets[i];
          if (node === undefined) continue;
          node.updateMatrix();
          node.matrixAutoUpdate = true;
          var TypedKeyframeTrack;

          switch (PATH_PROPERTIES[target.path]) {
            case PATH_PROPERTIES.weights:
              TypedKeyframeTrack = NumberKeyframeTrack;
              break;

            case PATH_PROPERTIES.rotation:
              TypedKeyframeTrack = QuaternionKeyframeTrack;
              break;

            case PATH_PROPERTIES.position:
            case PATH_PROPERTIES.scale:
            default:
              TypedKeyframeTrack = VectorKeyframeTrack;
              break;
          }

          var targetName = node.name ? node.name : node.uuid;
          var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
          var targetNames = [];

          if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
            node.traverse(function (object) {
              if (object.isMesh === true && object.morphTargetInfluences) {
                targetNames.push(object.name ? object.name : object.uuid);
              }
            });
          } else {
            targetNames.push(targetName);
          }

          var outputArray = outputAccessor.array;

          if (outputAccessor.normalized) {
            var scale;

            if (outputArray.constructor === Int8Array) {
              scale = 1 / 127;
            } else if (outputArray.constructor === Uint8Array) {
              scale = 1 / 255;
            } else if (outputArray.constructor == Int16Array) {
              scale = 1 / 32767;
            } else if (outputArray.constructor === Uint16Array) {
              scale = 1 / 65535;
            } else {
              throw new Error('THREE.GLTFLoader: Unsupported output accessor component type.');
            }

            var scaled = new Float32Array(outputArray.length);

            for (var j = 0, jl = outputArray.length; j < jl; j++) {
              scaled[j] = outputArray[j] * scale;
            }

            outputArray = scaled;
          }

          for (var j = 0, jl = targetNames.length; j < jl; j++) {
            var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);

            if (sampler.interpolation === 'CUBICSPLINE') {
              track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
              };

              track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
            }

            tracks.push(track);
          }
        }

        var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;
        return new AnimationClip(name, undefined, tracks);
      });
    };

    GLTFParser.prototype.loadNode = function (nodeIndex) {
      var json = this.json;
      var extensions = this.extensions;
      var parser = this;
      var meshReferences = json.meshReferences;
      var meshUses = json.meshUses;
      var nodeDef = json.nodes[nodeIndex];
      return function () {
        var pending = [];

        if (nodeDef.mesh !== undefined) {
          pending.push(parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {
            var node;

            if (meshReferences[nodeDef.mesh] > 1) {
              var instanceNum = meshUses[nodeDef.mesh]++;
              node = mesh.clone();
              node.name += '_instance_' + instanceNum;
            } else {
              node = mesh;
            }

            if (nodeDef.weights !== undefined) {
              node.traverse(function (o) {
                if (!o.isMesh) return;

                for (var i = 0, il = nodeDef.weights.length; i < il; i++) {
                  o.morphTargetInfluences[i] = nodeDef.weights[i];
                }
              });
            }

            return node;
          }));
        }

        if (nodeDef.camera !== undefined) {
          pending.push(parser.getDependency('camera', nodeDef.camera));
        }

        if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {
          pending.push(parser.getDependency('light', nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));
        }

        return Promise.all(pending);
      }().then(function (objects) {
        var node;

        if (nodeDef.isBone === true) {
          node = new Bone();
        } else if (objects.length > 1) {
          node = new Group();
        } else if (objects.length === 1) {
          node = objects[0];
        } else {
          node = new Object3D();
        }

        if (node !== objects[0]) {
          for (var i = 0, il = objects.length; i < il; i++) {
            node.add(objects[i]);
          }
        }

        if (nodeDef.name !== undefined) {
          node.userData.name = nodeDef.name;
          node.name = PropertyBinding.sanitizeNodeName(nodeDef.name);
        }

        assignExtrasToUserData(node, nodeDef);
        if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);

        if (nodeDef.matrix !== undefined) {
          var matrix = new Matrix4();
          matrix.fromArray(nodeDef.matrix);
          node.applyMatrix4(matrix);
        } else {
          if (nodeDef.translation !== undefined) {
            node.position.fromArray(nodeDef.translation);
          }

          if (nodeDef.rotation !== undefined) {
            node.quaternion.fromArray(nodeDef.rotation);
          }

          if (nodeDef.scale !== undefined) {
            node.scale.fromArray(nodeDef.scale);
          }
        }

        return node;
      });
    };

    GLTFParser.prototype.loadScene = function () {
      function buildNodeHierachy(nodeId, parentObject, json, parser) {
        var nodeDef = json.nodes[nodeId];
        return parser.getDependency('node', nodeId).then(function (node) {
          if (nodeDef.skin === undefined) return node;
          var skinEntry;
          return parser.getDependency('skin', nodeDef.skin).then(function (skin) {
            skinEntry = skin;
            var pendingJoints = [];

            for (var i = 0, il = skinEntry.joints.length; i < il; i++) {
              pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));
            }

            return Promise.all(pendingJoints);
          }).then(function (jointNodes) {
            node.traverse(function (mesh) {
              if (!mesh.isMesh) return;
              var bones = [];
              var boneInverses = [];

              for (var j = 0, jl = jointNodes.length; j < jl; j++) {
                var jointNode = jointNodes[j];

                if (jointNode) {
                  bones.push(jointNode);
                  var mat = new Matrix4();

                  if (skinEntry.inverseBindMatrices !== undefined) {
                    mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
                  }

                  boneInverses.push(mat);
                } else {
                  console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
                }
              }

              mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
            });
            return node;
          });
        }).then(function (node) {
          parentObject.add(node);
          var pending = [];

          if (nodeDef.children) {
            var children = nodeDef.children;

            for (var i = 0, il = children.length; i < il; i++) {
              var child = children[i];
              pending.push(buildNodeHierachy(child, node, json, parser));
            }
          }

          return Promise.all(pending);
        });
      }

      return function loadScene(sceneIndex) {
        var json = this.json;
        var extensions = this.extensions;
        var sceneDef = this.json.scenes[sceneIndex];
        var parser = this;
        var scene = new Scene();
        if (sceneDef.name !== undefined) scene.name = sceneDef.name;
        assignExtrasToUserData(scene, sceneDef);
        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
        var nodeIds = sceneDef.nodes || [];
        var pending = [];

        for (var i = 0, il = nodeIds.length; i < il; i++) {
          pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));
        }

        return Promise.all(pending).then(function () {
          return scene;
        });
      };
    }();

    return GLTFLoader;
  }();

  function _createLights(shadowCameraHelper) {
    var ambientLight = new AmbientLight(0x111111);
    var directionalLight = new DirectionalLight(0xffffff, 1);
    directionalLight.position.set(4, 18, 3);
    directionalLight.target.position.set(0, 7, 0);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.top = 20;
    directionalLight.shadow.camera.right = 20;
    directionalLight.shadow.camera.bottom = -20;
    directionalLight.shadow.camera.left = -20;
    directionalLight.shadow.camera.far = 32;
    return [ambientLight, directionalLight, directionalLight.target].concat(shadowCameraHelper ? [new CameraHelper(directionalLight.shadow.camera)] : []);
  }

  function load$1(assets, manager, anisotropy) {
    var gltfLoader = new GLTFLoader(manager);
    var sponzaURL = window.location.hostname !== "localhost" ? "https://gitcdn.xyz/repo/vanruesc/postprocessing/master/public/demo/models/sponza/scene.gltf" : "models/sponza/scene.gltf";
    gltfLoader.load(sponzaURL, function (gltf) {
      gltf.scene.traverse(function (object) {
        if (object.isMesh) {
          var _object$material = object.material,
              _object$material$map = _object$material.map,
              _map = _object$material$map === void 0 ? null : _object$material$map,
              _object$material$norm = _object$material.normalMap,
              normalMap = _object$material$norm === void 0 ? null : _object$material$norm;

          if (_map !== null) {
            object.material.map.anisotropy = anisotropy;
          }

          if (normalMap !== null) {
            object.material.normalMap.anisotropy = anisotropy;
          }

          object.castShadow = object.receiveShadow = true;
        }
      });
      assets.set("sponza", gltf.scene);
    });
  }

  var Sponza = function () {
    function Sponza() {
      _classCallCheck(this, Sponza);
    }

    _createClass(Sponza, null, [{
      key: "createLights",
      value: function createLights() {
        var shadowCameraHelper = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return _createLights(shadowCameraHelper);
      }
    }, {
      key: "load",
      value: function load(assets, manager, anisotropy) {
        load$1(assets, manager, anisotropy);
      }
    }]);

    return Sponza;
  }();

  var ColorDepthDemo = function (_PostProcessingDemo3) {
    _inherits(ColorDepthDemo, _PostProcessingDemo3);

    function ColorDepthDemo(composer) {
      var _this57;

      _classCallCheck(this, ColorDepthDemo);

      _this57 = _possibleConstructorReturn(this, _getPrototypeOf(ColorDepthDemo).call(this, "color-depth", composer));
      _this57.effect = null;
      _this57.pass = null;
      return _this57;
    }

    _createClass(ColorDepthDemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var anisotropy = Math.min(this.composer.getRenderer().capabilities.getMaxAnisotropy(), 8);
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            Sponza.load(assets, loadingManager, anisotropy);
            smaaImageLoader.load(function (_ref32) {
              var _ref33 = _slicedToArray(_ref32, 2),
                  search = _ref33[0],
                  area = _ref33[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.5, 2000);
        camera.position.set(-9, 0.5, 0);
        this.camera = camera;
        var target = new Vector3(0, 3, -3.5);
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = true;
        controls.settings.sensitivity.translation = 3.0;
        controls.lookAt(target);
        controls.setOrbitEnabled(false);
        this.controls = controls;
        scene.background = new Color(0xeeeeee);
        scene.add.apply(scene, _toConsumableArray(Sponza.createLights()));
        scene.add(assets.get("sponza"));
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(0.05);
        var colorDepthEffect = new ColorDepthEffect({
          bits: 16
        });
        var pass = new EffectPass(camera, smaaEffect, colorDepthEffect);
        this.effect = colorDepthEffect;
        this.pass = pass;
        composer.addPass(pass);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var pass = this.pass;
        var effect = this.effect;
        var blendMode = effect.blendMode;
        var params = {
          "bits": effect.getBitDepth(),
          "opacity": blendMode.opacity.value,
          "blend mode": blendMode.blendFunction
        };
        menu.add(params, "bits").min(1).max(32).step(1).onChange(function () {
          effect.setBitDepth(params.bits);
        });
        menu.add(params, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          blendMode.opacity.value = params.opacity;
        });
        menu.add(params, "blend mode", BlendFunction).onChange(function () {
          blendMode.blendFunction = Number.parseInt(params["blend mode"]);
          pass.recompile();
        });
      }
    }]);

    return ColorDepthDemo;
  }(PostProcessingDemo);

  var ColorGradingDemo = function (_PostProcessingDemo4) {
    _inherits(ColorGradingDemo, _PostProcessingDemo4);

    function ColorGradingDemo(composer) {
      var _this58;

      _classCallCheck(this, ColorGradingDemo);

      _this58 = _possibleConstructorReturn(this, _getPrototypeOf(ColorGradingDemo).call(this, "color-grading", composer));
      _this58.brightnessContrastEffect = null;
      _this58.colorAverageEffect = null;
      _this58.hueSaturationEffect = null;
      _this58.sepiaEffect = null;
      _this58.pass = null;
      return _this58;
    }

    _createClass(ColorGradingDemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var anisotropy = Math.min(this.composer.getRenderer().capabilities.getMaxAnisotropy(), 8);
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            Sponza.load(assets, loadingManager, anisotropy);
            smaaImageLoader.load(function (_ref34) {
              var _ref35 = _slicedToArray(_ref34, 2),
                  search = _ref35[0],
                  area = _ref35[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.5, 2000);
        camera.position.set(-9, 0.5, 0);
        this.camera = camera;
        var target = new Vector3(0, 3, -3.5);
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = true;
        controls.settings.sensitivity.translation = 3.0;
        controls.lookAt(target);
        controls.setOrbitEnabled(false);
        this.controls = controls;
        scene.background = new Color(0xeeeeee);
        scene.add.apply(scene, _toConsumableArray(Sponza.createLights()));
        scene.add(assets.get("sponza"));
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(0.05);
        var colorAverageEffect = new ColorAverageEffect(BlendFunction.SKIP);
        var sepiaEffect = new SepiaEffect({
          blendFunction: BlendFunction.SKIP
        });
        var brightnessContrastEffect = new BrightnessContrastEffect({
          blendFunction: BlendFunction.SKIP
        });
        var hueSaturationEffect = new HueSaturationEffect({
          hue: 0.0,
          saturation: 0.4
        });
        var pass = new EffectPass(camera, smaaEffect, colorAverageEffect, sepiaEffect, brightnessContrastEffect, hueSaturationEffect);
        pass.dithering = true;
        this.pass = pass;
        this.brightnessContrastEffect = brightnessContrastEffect;
        this.colorAverageEffect = colorAverageEffect;
        this.hueSaturationEffect = hueSaturationEffect;
        this.sepiaEffect = sepiaEffect;
        composer.addPass(pass);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var pass = this.pass;
        var brightnessContrastEffect = this.brightnessContrastEffect;
        var colorAverageEffect = this.colorAverageEffect;
        var hueSaturationEffect = this.hueSaturationEffect;
        var sepiaEffect = this.sepiaEffect;
        var params = {
          colorAverage: {
            "opacity": colorAverageEffect.blendMode.opacity.value,
            "blend mode": colorAverageEffect.blendMode.blendFunction
          },
          sepia: {
            "intensity": sepiaEffect.uniforms.get("intensity").value,
            "opacity": sepiaEffect.blendMode.opacity.value,
            "blend mode": sepiaEffect.blendMode.blendFunction
          },
          brightnessContrast: {
            "brightness": brightnessContrastEffect.uniforms.get("brightness").value,
            "contrast": brightnessContrastEffect.uniforms.get("contrast").value,
            "opacity": brightnessContrastEffect.blendMode.opacity.value,
            "blend mode": brightnessContrastEffect.blendMode.blendFunction
          },
          hueSaturation: {
            "hue": 0.0,
            "saturation": hueSaturationEffect.uniforms.get("saturation").value,
            "opacity": hueSaturationEffect.blendMode.opacity.value,
            "blend mode": hueSaturationEffect.blendMode.blendFunction
          }
        };
        var folder = menu.addFolder("Color Average");
        folder.add(params.colorAverage, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          colorAverageEffect.blendMode.opacity.value = params.colorAverage.opacity;
        });
        folder.add(params.colorAverage, "blend mode", BlendFunction).onChange(function () {
          colorAverageEffect.blendMode.blendFunction = Number.parseInt(params.colorAverage["blend mode"]);
          pass.recompile();
        });
        folder = menu.addFolder("Sepia");
        folder.add(params.sepia, "intensity").min(0.0).max(1.0).step(0.001).onChange(function () {
          sepiaEffect.uniforms.get("intensity").value = params.sepia.intensity;
        });
        folder.add(params.sepia, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          sepiaEffect.blendMode.opacity.value = params.sepia.opacity;
        });
        folder.add(params.sepia, "blend mode", BlendFunction).onChange(function () {
          sepiaEffect.blendMode.blendFunction = Number.parseInt(params.sepia["blend mode"]);
          pass.recompile();
        });
        folder = menu.addFolder("Brightness & Contrast");
        folder.add(params.brightnessContrast, "brightness").min(-1.0).max(1.0).step(0.001).onChange(function () {
          brightnessContrastEffect.uniforms.get("brightness").value = params.brightnessContrast.brightness;
        });
        folder.add(params.brightnessContrast, "contrast").min(-1.0).max(1.0).step(0.001).onChange(function () {
          brightnessContrastEffect.uniforms.get("contrast").value = params.brightnessContrast.contrast;
        });
        folder.add(params.brightnessContrast, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          brightnessContrastEffect.blendMode.opacity.value = params.brightnessContrast.opacity;
        });
        folder.add(params.brightnessContrast, "blend mode", BlendFunction).onChange(function () {
          brightnessContrastEffect.blendMode.blendFunction = Number.parseInt(params.brightnessContrast["blend mode"]);
          pass.recompile();
        });
        folder = menu.addFolder("Hue & Saturation");
        folder.add(params.hueSaturation, "hue").min(-Math.PI).max(Math.PI).step(0.001).onChange(function () {
          hueSaturationEffect.setHue(params.hueSaturation.hue);
        });
        folder.add(params.hueSaturation, "saturation").min(-1.0).max(1.0).step(0.001).onChange(function () {
          hueSaturationEffect.uniforms.get("saturation").value = params.hueSaturation.saturation;
        });
        folder.add(params.hueSaturation, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          hueSaturationEffect.blendMode.opacity.value = params.hueSaturation.opacity;
        });
        folder.add(params.hueSaturation, "blend mode", BlendFunction).onChange(function () {
          hueSaturationEffect.blendMode.blendFunction = Number.parseInt(params.hueSaturation["blend mode"]);
          pass.recompile();
        });
        folder.open();
        menu.add(pass, "dithering");
      }
    }]);

    return ColorGradingDemo;
  }(PostProcessingDemo);

  var DepthOfFieldDemo = function (_PostProcessingDemo5) {
    _inherits(DepthOfFieldDemo, _PostProcessingDemo5);

    function DepthOfFieldDemo(composer) {
      var _this59;

      _classCallCheck(this, DepthOfFieldDemo);

      _this59 = _possibleConstructorReturn(this, _getPrototypeOf(DepthOfFieldDemo).call(this, "depth-of-field", composer));
      _this59.depthEffect = null;
      _this59.vignetteEffect = null;
      _this59.depthOfFieldEffect = null;
      _this59.cocTextureEffect = null;
      _this59.effectPass0 = null;
      _this59.effectPass1 = null;
      return _this59;
    }

    _createClass(DepthOfFieldDemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var anisotropy = Math.min(this.composer.getRenderer().capabilities.getMaxAnisotropy(), 8);
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            Sponza.load(assets, loadingManager, anisotropy);
            smaaImageLoader.load(function (_ref36) {
              var _ref37 = _slicedToArray(_ref36, 2),
                  search = _ref37[0],
                  area = _ref37[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.3, 30);
        camera.position.set(-2.3684, 0.5964, -1.3052);
        this.camera = camera;
        var target = new Vector3(-1.4265, 0.6513, -1.6365);
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = true;
        controls.settings.sensitivity.translation = 3.0;
        controls.lookAt(target);
        controls.setOrbitEnabled(false);
        this.controls = controls;
        scene.background = new Color(0xeeeeee);
        scene.add.apply(scene, _toConsumableArray(Sponza.createLights()));
        scene.add(assets.get("sponza"));
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.setEdgeDetectionThreshold(0.05);
        var depthOfFieldEffect = new DepthOfFieldEffect(camera, {
          focusDistance: 0.0,
          focalLength: 0.048,
          bokehScale: 2.0,
          height: 480
        });
        var depthEffect = new DepthEffect({
          blendFunction: BlendFunction.SKIP
        });
        var vignetteEffect = new VignetteEffect({
          eskil: false,
          offset: 0.35,
          darkness: 0.75
        });
        var cocTextureEffect = new TextureEffect({
          blendFunction: BlendFunction.SKIP,
          texture: depthOfFieldEffect.renderTargetCoC.texture
        });
        var effectPass0 = new EffectPass(camera, depthOfFieldEffect);
        var effectPass1 = new EffectPass(camera, smaaEffect, vignetteEffect, cocTextureEffect, depthEffect);
        this.depthEffect = depthEffect;
        this.vignetteEffect = vignetteEffect;
        this.depthOfFieldEffect = depthOfFieldEffect;
        this.cocTextureEffect = cocTextureEffect;
        this.effectPass0 = effectPass0;
        this.effectPass1 = effectPass1;
        composer.addPass(effectPass0);
        composer.addPass(effectPass1);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var effectPass0 = this.effectPass0;
        var effectPass1 = this.effectPass1;
        var depthEffect = this.depthEffect;
        var vignetteEffect = this.vignetteEffect;
        var depthOfFieldEffect = this.depthOfFieldEffect;
        var cocTextureEffect = this.cocTextureEffect;
        var cocMaterial = depthOfFieldEffect.circleOfConfusionMaterial;
        var blendMode = depthOfFieldEffect.blendMode;
        var RenderMode = {
          DEFAULT: 0,
          DEPTH: 1,
          COC: 2
        };
        var params = {
          "coc": {
            "edge blur kernel": depthOfFieldEffect.blurPass.kernelSize,
            "focus": cocMaterial.uniforms.focusDistance.value,
            "focal length": cocMaterial.uniforms.focalLength.value
          },
          "vignette": {
            "enabled": true,
            "offset": vignetteEffect.uniforms.get("offset").value,
            "darkness": vignetteEffect.uniforms.get("darkness").value
          },
          "render mode": RenderMode.DEFAULT,
          "resolution": depthOfFieldEffect.resolution.height,
          "bokeh scale": depthOfFieldEffect.bokehScale,
          "opacity": blendMode.opacity.value,
          "blend mode": blendMode.blendFunction
        };

        function toggleRenderMode() {
          var mode = Number.parseInt(params["render mode"]);
          depthEffect.blendMode.blendFunction = mode === RenderMode.DEPTH ? BlendFunction.NORMAL : BlendFunction.SKIP;
          cocTextureEffect.blendMode.blendFunction = mode === RenderMode.COC ? BlendFunction.NORMAL : BlendFunction.SKIP;
          vignetteEffect.blendMode.blendFunction = mode === RenderMode.DEFAULT && params.vignette.enabled ? BlendFunction.NORMAL : BlendFunction.SKIP;
          effectPass1.encodeOutput = mode === RenderMode.DEFAULT;
          effectPass0.recompile();
          effectPass1.recompile();
        }

        menu.add(params, "render mode", RenderMode).onChange(toggleRenderMode);
        menu.add(params, "resolution", [240, 360, 480, 720, 1080]).onChange(function () {
          depthOfFieldEffect.resolution.height = Number(params.resolution);
        });
        menu.add(params, "bokeh scale").min(1.0).max(5.0).step(0.001).onChange(function () {
          depthOfFieldEffect.bokehScale = params["bokeh scale"];
        });
        var folder = menu.addFolder("Circle of Confusion");
        folder.add(params.coc, "edge blur kernel", KernelSize).onChange(function () {
          depthOfFieldEffect.blurPass.kernelSize = Number(params.coc["edge blur kernel"]);
        });
        folder.add(params.coc, "focus").min(0.0).max(1.0).step(0.001).onChange(function () {
          cocMaterial.uniforms.focusDistance.value = params.coc.focus;
        });
        folder.add(params.coc, "focal length").min(0.0).max(1.0).step(0.0001).onChange(function () {
          cocMaterial.uniforms.focalLength.value = params.coc["focal length"];
        });
        folder.open();
        folder = menu.addFolder("Vignette");
        folder.add(params.vignette, "enabled").onChange(function () {
          vignetteEffect.blendMode.blendFunction = params.vignette.enabled ? BlendFunction.NORMAL : BlendFunction.SKIP;
          effectPass1.recompile();
        });
        folder.add(vignetteEffect, "eskil").onChange(function () {
          return effectPass0.recompile();
        });
        folder.add(params.vignette, "offset").min(0.0).max(1.0).step(0.001).onChange(function () {
          vignetteEffect.uniforms.get("offset").value = params.vignette.offset;
        });
        folder.add(params.vignette, "darkness").min(0.0).max(1.0).step(0.001).onChange(function () {
          vignetteEffect.uniforms.get("darkness").value = params.vignette.darkness;
        });
        menu.add(params, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          blendMode.opacity.value = params.opacity;
        });
        menu.add(params, "blend mode", BlendFunction).onChange(function () {
          blendMode.blendFunction = Number.parseInt(params["blend mode"]);
          effectPass0.recompile();
        });
      }
    }]);

    return DepthOfFieldDemo;
  }(PostProcessingDemo);

  var GlitchDemo = function (_PostProcessingDemo6) {
    _inherits(GlitchDemo, _PostProcessingDemo6);

    function GlitchDemo(composer) {
      var _this60;

      _classCallCheck(this, GlitchDemo);

      _this60 = _possibleConstructorReturn(this, _getPrototypeOf(GlitchDemo).call(this, "glitch", composer));
      _this60.effect = null;
      _this60.pass = null;
      return _this60;
    }

    _createClass(GlitchDemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var textureLoader = new TextureLoader(loadingManager);
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var anisotropy = Math.min(this.composer.getRenderer().capabilities.getMaxAnisotropy(), 8);
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            Sponza.load(assets, loadingManager, anisotropy);
            textureLoader.load("textures/perturb.jpg", function (t) {
              assets.set("perturbation-map", t);
            });
            smaaImageLoader.load(function (_ref38) {
              var _ref39 = _slicedToArray(_ref38, 2),
                  search = _ref39[0],
                  area = _ref39[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.5, 2000);
        camera.position.set(-9, 0.5, 0);
        this.camera = camera;
        var target = new Vector3(0, 3, -3.5);
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = true;
        controls.settings.sensitivity.translation = 3.0;
        controls.lookAt(target);
        controls.setOrbitEnabled(false);
        this.controls = controls;
        scene.background = new Color(0xeeeeee);
        scene.add.apply(scene, _toConsumableArray(Sponza.createLights()));
        scene.add(assets.get("sponza"));
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(0.05);
        var chromaticAberrationEffect = new ChromaticAberrationEffect();
        var glitchEffect = new GlitchEffect({
          perturbationMap: assets.get("perturbation-map"),
          chromaticAberrationOffset: chromaticAberrationEffect.offset
        });
        var noiseEffect = new NoiseEffect({
          blendFunction: BlendFunction.COLOR_DODGE
        });
        noiseEffect.blendMode.opacity.value = 0.1;
        var smaaPass = new EffectPass(camera, smaaEffect);
        var glitchPass = new EffectPass(camera, glitchEffect, noiseEffect);
        var chromaticAberrationPass = new EffectPass(camera, chromaticAberrationEffect);
        this.effect = glitchEffect;
        composer.addPass(smaaPass);
        composer.addPass(glitchPass);
        composer.addPass(chromaticAberrationPass);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var effect = this.effect;
        var perturbationMap = effect.getPerturbationMap();
        var uniforms = effect.uniforms;
        var delay = effect.delay;
        var duration = effect.duration;
        var strength = effect.strength;
        var params = {
          "glitch mode": effect.mode,
          "custom pattern": true,
          "min delay": delay.x,
          "max delay": delay.y,
          "min duration": duration.x,
          "max duration": duration.y,
          "weak glitches": strength.x,
          "strong glitches": strength.y,
          "glitch ratio": effect.ratio,
          "columns": uniforms.get("columns").value
        };
        menu.add(params, "glitch mode", GlitchMode).onChange(function () {
          effect.mode = Number.parseInt(params["glitch mode"]);
        });
        menu.add(params, "custom pattern").onChange(function () {
          if (params["custom pattern"]) {
            effect.setPerturbationMap(perturbationMap);
          } else {
            effect.setPerturbationMap(effect.generatePerturbationMap(64));
          }
        });
        menu.add(params, "min delay").min(0.0).max(2.0).step(0.001).onChange(function () {
          delay.x = params["min delay"];
        });
        menu.add(params, "max delay").min(2.0).max(4.0).step(0.001).onChange(function () {
          delay.y = params["max delay"];
        });
        menu.add(params, "min duration").min(0.0).max(0.6).step(0.001).onChange(function () {
          duration.x = params["min duration"];
        });
        menu.add(params, "max duration").min(0.6).max(1.8).step(0.001).onChange(function () {
          duration.y = params["max duration"];
        });
        var folder = menu.addFolder("Strength");
        folder.add(params, "weak glitches").min(0.0).max(1.0).step(0.001).onChange(function () {
          strength.x = params["weak glitches"];
        });
        folder.add(params, "strong glitches").min(0.0).max(1.0).step(0.001).onChange(function () {
          strength.y = params["strong glitches"];
        });
        folder.open();
        menu.add(params, "glitch ratio").min(0.0).max(1.0).step(0.001).onChange(function () {
          effect.ratio = Number.parseFloat(params["glitch ratio"]);
        });
        menu.add(params, "columns").min(0.0).max(0.5).step(0.001).onChange(function () {
          uniforms.get("columns").value = params.columns;
        });
      }
    }]);

    return GlitchDemo;
  }(PostProcessingDemo);

  var GodRaysDemo = function (_PostProcessingDemo7) {
    _inherits(GodRaysDemo, _PostProcessingDemo7);

    function GodRaysDemo(composer) {
      var _this61;

      _classCallCheck(this, GodRaysDemo);

      _this61 = _possibleConstructorReturn(this, _getPrototypeOf(GodRaysDemo).call(this, "god-rays", composer));
      _this61.pass = null;
      _this61.effect = null;
      _this61.sun = null;
      _this61.light = null;
      return _this61;
    }

    _createClass(GodRaysDemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var anisotropy = Math.min(this.composer.getRenderer().capabilities.getMaxAnisotropy(), 8);
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            Sponza.load(assets, loadingManager, anisotropy);
            smaaImageLoader.load(function (_ref40) {
              var _ref41 = _slicedToArray(_ref40, 2),
                  search = _ref41[0],
                  area = _ref41[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.5, 2000);
        camera.position.set(6, 1.2, -4);
        this.camera = camera;
        var target = new Vector3(-2.5, 2.0, -3.25);
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = true;
        controls.settings.sensitivity.translation = 3.0;
        controls.lookAt(target);
        controls.setOrbitEnabled(false);
        this.controls = controls;
        scene.background = new Color(0x000000);
        var ambientLight = new AmbientLight(0x101010);
        var mainLight = new PointLight(0xffe3b1);
        mainLight.position.set(-0.5, 3, -0.25);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 1024;
        mainLight.shadow.mapSize.height = 1024;
        this.light = mainLight;
        scene.add(ambientLight, mainLight);
        var sunMaterial = new MeshBasicMaterial({
          color: 0xffddaa,
          transparent: true,
          fog: false
        });
        var sunGeometry = new SphereBufferGeometry(0.75, 32, 32);
        var sun = new Mesh(sunGeometry, sunMaterial);
        sun.frustumCulled = false;
        sun.matrixAutoUpdate = false;
        var group = new Group();
        group.position.copy(this.light.position);
        group.add(sun);
        this.sun = sun;
        scene.add(assets.get("sponza"));
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(0.05);
        var godRaysEffect = new GodRaysEffect(camera, sun, {
          height: 480,
          kernelSize: KernelSize.SMALL,
          density: 0.96,
          decay: 0.92,
          weight: 0.3,
          exposure: 0.54,
          samples: 60,
          clampMax: 1.0
        });
        var pass = new EffectPass(camera, smaaEffect, godRaysEffect);
        this.effect = godRaysEffect;
        this.pass = pass;
        composer.addPass(pass);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var color = new Color();
        var sun = this.sun;
        var light = this.light;
        var pass = this.pass;
        var effect = this.effect;
        var uniforms = effect.godRaysMaterial.uniforms;
        var blendMode = effect.blendMode;
        var params = {
          "resolution": effect.height,
          "blurriness": effect.blurPass.kernelSize + 1,
          "density": uniforms.density.value,
          "decay": uniforms.decay.value,
          "weight": uniforms.weight.value,
          "exposure": uniforms.exposure.value,
          "clampMax": uniforms.clampMax.value,
          "samples": effect.samples,
          "color": color.copyLinearToSRGB(sun.material.color).getHex(),
          "opacity": blendMode.opacity.value,
          "blend mode": blendMode.blendFunction
        };
        menu.add(params, "resolution", [240, 360, 480, 720, 1080]).onChange(function () {
          effect.resolution.height = Number.parseInt(params.resolution);
        });
        menu.add(pass, "dithering");
        menu.add(params, "blurriness").min(KernelSize.VERY_SMALL).max(KernelSize.HUGE + 1).step(1).onChange(function () {
          effect.blur = params.blurriness > 0;
          effect.blurPass.kernelSize = params.blurriness - 1;
        });
        menu.add(params, "density").min(0.0).max(1.0).step(0.01).onChange(function () {
          uniforms.density.value = params.density;
        });
        menu.add(params, "decay").min(0.0).max(1.0).step(0.01).onChange(function () {
          uniforms.decay.value = params.decay;
        });
        menu.add(params, "weight").min(0.0).max(1.0).step(0.01).onChange(function () {
          uniforms.weight.value = params.weight;
        });
        menu.add(params, "exposure").min(0.0).max(1.0).step(0.01).onChange(function () {
          uniforms.exposure.value = params.exposure;
        });
        menu.add(params, "clampMax").min(0.0).max(1.0).step(0.01).onChange(function () {
          uniforms.clampMax.value = params.clampMax;
        });
        menu.add(effect, "samples").min(15).max(200).step(1);
        menu.addColor(params, "color").onChange(function () {
          sun.material.color.setHex(params.color).convertSRGBToLinear();
          light.color.setHex(params.color).convertSRGBToLinear();
        });
        menu.add(params, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          blendMode.opacity.value = params.opacity;
        });
        menu.add(params, "blend mode", BlendFunction).onChange(function () {
          blendMode.blendFunction = Number.parseInt(params["blend mode"]);
          pass.recompile();
        });
      }
    }]);

    return GodRaysDemo;
  }(PostProcessingDemo);

  var mouse$1 = new Vector2();

  var OutlineDemo = function (_PostProcessingDemo8) {
    _inherits(OutlineDemo, _PostProcessingDemo8);

    function OutlineDemo(composer) {
      var _this62;

      _classCallCheck(this, OutlineDemo);

      _this62 = _possibleConstructorReturn(this, _getPrototypeOf(OutlineDemo).call(this, "outline", composer));
      _this62.raycaster = null;
      _this62.selectedObject = null;
      _this62.effect = null;
      _this62.pass = null;
      return _this62;
    }

    _createClass(OutlineDemo, [{
      key: "raycast",
      value: function raycast(event) {
        var raycaster = this.raycaster;
        mouse$1.x = event.clientX / window.innerWidth * 2.0 - 1.0;
        mouse$1.y = -(event.clientY / window.innerHeight) * 2.0 + 1.0;
        raycaster.setFromCamera(mouse$1, this.camera);
        var intersects = raycaster.intersectObjects(this.scene.children);
        this.selectedObject = null;

        if (intersects.length > 0) {
          var _x3 = intersects[0];

          if (_x3.object !== undefined) {
            this.selectedObject = _x3.object;
          } else {
            console.warn("Encountered an undefined object", intersects);
          }
        }
      }
    }, {
      key: "handleSelection",
      value: function handleSelection() {
        var selection = this.effect.selection;
        var selectedObject = this.selectedObject;

        if (selectedObject !== null) {
          if (selection.has(selectedObject)) {
            selection["delete"](selectedObject);
          } else {
            selection.add(selectedObject);
          }
        }
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        switch (event.type) {
          case "mousemove":
            this.raycast(event);
            break;

          case "mousedown":
            this.handleSelection();
            break;
        }
      }
    }, {
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var textureLoader = new TextureLoader(loadingManager);
        var cubeTextureLoader = new CubeTextureLoader(loadingManager);
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var path = "textures/skies/sunset/";
        var format = ".png";
        var urls = [path + "px" + format, path + "nx" + format, path + "py" + format, path + "ny" + format, path + "pz" + format, path + "nz" + format];
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            cubeTextureLoader.load(urls, function (t) {
              t.encoding = sRGBEncoding;
              assets.set("sky", t);
            });
            textureLoader.load("textures/pattern.png", function (t) {
              assets.set("pattern-color", t);
            });
            smaaImageLoader.load(function (_ref42) {
              var _ref43 = _slicedToArray(_ref42, 2),
                  search = _ref43[0],
                  area = _ref43[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 1, 2000);
        camera.position.set(-4, 1.25, -5);
        camera.lookAt(scene.position);
        this.camera = camera;
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = false;
        controls.settings.sensitivity.zoom = 1.0;
        controls.lookAt(scene.position);
        this.controls = controls;
        scene.background = assets.get("sky");
        var ambientLight = new AmbientLight(0x212121);
        var mainLight = new DirectionalLight(0xff7e66, 1.0);
        var backLight = new DirectionalLight(0xff7e66, 0.1);
        mainLight.position.set(14.4, 2, 20);
        backLight.position.copy(mainLight.position).negate();
        scene.add(ambientLight, mainLight, backLight);
        var selection = [];
        var mesh = new Mesh(new SphereBufferGeometry(1, 32, 32), new MeshPhongMaterial({
          color: 0xffff00
        }));
        mesh.position.set(2, 0, -2);
        scene.add(mesh);
        selection.push(mesh);
        mesh = new Mesh(new ConeBufferGeometry(1, 1, 32), new MeshPhongMaterial({
          color: 0x00ff00
        }));
        mesh.position.set(-2, 0, 2);
        scene.add(mesh);
        selection.push(mesh);
        mesh = new Mesh(new OctahedronBufferGeometry(), new MeshPhongMaterial({
          color: 0xff00ff
        }));
        mesh.position.set(2, 0, 2);
        scene.add(mesh);
        selection.push(mesh);
        mesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new MeshPhongMaterial({
          color: 0x00ffff
        }));
        mesh.position.set(-2, 0, -2);
        scene.add(mesh);
        this.raycaster = new Raycaster();
        renderer.domElement.addEventListener("mousemove", this);
        renderer.domElement.addEventListener("mousedown", this);
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.COLOR);
        smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(0.05);
        var outlineEffect = new OutlineEffect(scene, camera, {
          blendFunction: BlendFunction.SCREEN,
          edgeStrength: 2.5,
          pulseSpeed: 0.0,
          visibleEdgeColor: 0xffffff,
          hiddenEdgeColor: 0x22090a,
          height: 480,
          blur: false,
          xRay: true
        });
        outlineEffect.selection.set(selection);
        var smaaPass = new EffectPass(camera, smaaEffect);
        var outlinePass = new EffectPass(camera, outlineEffect);
        this.effect = outlineEffect;
        this.pass = outlinePass;
        composer.addPass(outlinePass);
        composer.addPass(smaaPass);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var color = new Color();
        var assets = this.assets;
        var pass = this.pass;
        var effect = this.effect;
        var uniforms = effect.uniforms;
        var blendMode = effect.blendMode;
        var params = {
          "resolution": effect.height,
          "blurriness": 0,
          "use pattern": false,
          "pattern scale": 60.0,
          "pulse speed": effect.pulseSpeed,
          "edge strength": uniforms.get("edgeStrength").value,
          "visible edge": color.copyLinearToSRGB(uniforms.get("visibleEdgeColor").value).getHex(),
          "hidden edge": color.copyLinearToSRGB(uniforms.get("hiddenEdgeColor").value).getHex(),
          "x-ray": true,
          "opacity": blendMode.opacity.value,
          "blend mode": blendMode.blendFunction
        };
        menu.add(params, "resolution", [240, 360, 480, 720, 1080]).onChange(function () {
          effect.resolution.height = Number.parseInt(params.resolution);
        });
        menu.add(pass, "dithering");
        menu.add(params, "blurriness").min(KernelSize.VERY_SMALL).max(KernelSize.HUGE + 1).step(1).onChange(function () {
          effect.blur = params.blurriness > 0;
          effect.blurPass.kernelSize = params.blurriness - 1;
        });
        menu.add(params, "use pattern").onChange(function () {
          if (params["use pattern"]) {
            effect.setPatternTexture(assets.get("pattern-color"));
            uniforms.get("patternScale").value = params["pattern scale"];
          } else {
            effect.setPatternTexture(null);
          }

          pass.recompile();
        });
        menu.add(params, "pattern scale").min(20.0).max(100.0).step(0.1).onChange(function () {
          if (uniforms.has("patternScale")) {
            uniforms.get("patternScale").value = params["pattern scale"];
          }
        });
        menu.add(params, "edge strength").min(0.0).max(10.0).step(0.01).onChange(function () {
          uniforms.get("edgeStrength").value = params["edge strength"];
        });
        menu.add(params, "pulse speed").min(0.0).max(2.0).step(0.01).onChange(function () {
          effect.pulseSpeed = params["pulse speed"];
        });
        menu.addColor(params, "visible edge").onChange(function () {
          uniforms.get("visibleEdgeColor").value.setHex(params["visible edge"]).convertSRGBToLinear();
        });
        menu.addColor(params, "hidden edge").onChange(function () {
          uniforms.get("hiddenEdgeColor").value.setHex(params["hidden edge"]).convertSRGBToLinear();
        });
        menu.add(effect, "xRay").onChange(function () {
          return pass.recompile();
        });
        menu.add(params, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          blendMode.opacity.value = params.opacity;
        });
        menu.add(params, "blend mode", BlendFunction).onChange(function () {
          blendMode.blendFunction = Number.parseInt(params["blend mode"]);
          pass.recompile();
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        _get(_getPrototypeOf(OutlineDemo.prototype), "reset", this).call(this);

        var dom = this.composer.getRenderer().domElement;
        dom.removeEventListener("mousemove", this);
        dom.removeEventListener("mousedown", this);
        return this;
      }
    }]);

    return OutlineDemo;
  }(PostProcessingDemo);

  var PatternDemo = function (_PostProcessingDemo9) {
    _inherits(PatternDemo, _PostProcessingDemo9);

    function PatternDemo(composer) {
      var _this63;

      _classCallCheck(this, PatternDemo);

      _this63 = _possibleConstructorReturn(this, _getPrototypeOf(PatternDemo).call(this, "pattern", composer));
      _this63.dotScreenEffect = null;
      _this63.gridEffect = null;
      _this63.scanlineEffect = null;
      _this63.pass = null;
      return _this63;
    }

    _createClass(PatternDemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var anisotropy = Math.min(this.composer.getRenderer().capabilities.getMaxAnisotropy(), 8);
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            Sponza.load(assets, loadingManager, anisotropy);
            smaaImageLoader.load(function (_ref44) {
              var _ref45 = _slicedToArray(_ref44, 2),
                  search = _ref45[0],
                  area = _ref45[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.5, 2000);
        camera.position.set(-9, 0.5, 0);
        this.camera = camera;
        var target = new Vector3(0, 3, -3.5);
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = true;
        controls.settings.sensitivity.translation = 3.0;
        controls.lookAt(target);
        controls.setOrbitEnabled(false);
        this.controls = controls;
        scene.background = new Color(0xeeeeee);
        scene.add.apply(scene, _toConsumableArray(Sponza.createLights()));
        scene.add(assets.get("sponza"));
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(0.05);
        var dotScreenEffect = new DotScreenEffect({
          blendFunction: BlendFunction.LIGHTEN,
          scale: 0.24,
          angle: Math.PI * 0.58
        });
        var gridEffect = new GridEffect({
          blendFunction: BlendFunction.SKIP,
          scale: 1.75,
          lineWidth: 0.25
        });
        var scanlineEffect = new ScanlineEffect({
          blendFunction: BlendFunction.MULTIPLY,
          density: 1.0
        });
        scanlineEffect.blendMode.opacity.value = 0.25;
        var pass = new EffectPass(camera, smaaEffect, dotScreenEffect, gridEffect, scanlineEffect);
        this.dotScreenEffect = dotScreenEffect;
        this.gridEffect = gridEffect;
        this.scanlineEffect = scanlineEffect;
        this.pass = pass;
        composer.addPass(pass);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var pass = this.pass;
        var dotScreenEffect = this.dotScreenEffect;
        var gridEffect = this.gridEffect;
        var scanlineEffect = this.scanlineEffect;
        var params = {
          dotScreen: {
            "angle": Math.PI * 0.58,
            "scale": dotScreenEffect.uniforms.get("scale").value,
            "opacity": dotScreenEffect.blendMode.opacity.value,
            "blend mode": dotScreenEffect.blendMode.blendFunction
          },
          grid: {
            "scale": gridEffect.getScale(),
            "line width": gridEffect.getLineWidth(),
            "opacity": gridEffect.blendMode.opacity.value,
            "blend mode": gridEffect.blendMode.blendFunction
          },
          scanline: {
            "density": scanlineEffect.getDensity(),
            "opacity": scanlineEffect.blendMode.opacity.value,
            "blend mode": scanlineEffect.blendMode.blendFunction
          }
        };
        var folder = menu.addFolder("Dot Screen");
        folder.add(params.dotScreen, "angle").min(0.0).max(Math.PI).step(0.001).onChange(function () {
          dotScreenEffect.setAngle(params.dotScreen.angle);
        });
        folder.add(params.dotScreen, "scale").min(0.0).max(1.0).step(0.01).onChange(function () {
          dotScreenEffect.uniforms.get("scale").value = params.dotScreen.scale;
        });
        folder.add(params.dotScreen, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          dotScreenEffect.blendMode.opacity.value = params.dotScreen.opacity;
        });
        folder.add(params.dotScreen, "blend mode", BlendFunction).onChange(function () {
          dotScreenEffect.blendMode.blendFunction = Number.parseInt(params.dotScreen["blend mode"]);
          pass.recompile();
        });
        folder.open();
        folder = menu.addFolder("Grid");
        folder.add(params.grid, "scale").min(0.01).max(3.0).step(0.01).onChange(function () {
          gridEffect.setScale(params.grid.scale);
        });
        folder.add(params.grid, "line width").min(0.0).max(1.0).step(0.01).onChange(function () {
          gridEffect.setLineWidth(params.grid["line width"]);
        });
        folder.add(params.grid, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          gridEffect.blendMode.opacity.value = params.grid.opacity;
        });
        folder.add(params.grid, "blend mode", BlendFunction).onChange(function () {
          gridEffect.blendMode.blendFunction = Number.parseInt(params.grid["blend mode"]);
          pass.recompile();
        });
        folder.open();
        folder = menu.addFolder("Scanline");
        folder.add(params.scanline, "density").min(0.001).max(2.0).step(0.001).onChange(function () {
          scanlineEffect.setDensity(params.scanline.density);
        });
        folder.add(params.scanline, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          scanlineEffect.blendMode.opacity.value = params.scanline.opacity;
        });
        folder.add(params.scanline, "blend mode", BlendFunction).onChange(function () {
          scanlineEffect.blendMode.blendFunction = Number.parseInt(params.scanline["blend mode"]);
          pass.recompile();
        });
        folder.open();
      }
    }]);

    return PatternDemo;
  }(PostProcessingDemo);

  var PixelationDemo = function (_PostProcessingDemo10) {
    _inherits(PixelationDemo, _PostProcessingDemo10);

    function PixelationDemo(composer) {
      var _this64;

      _classCallCheck(this, PixelationDemo);

      _this64 = _possibleConstructorReturn(this, _getPrototypeOf(PixelationDemo).call(this, "pixelation", composer));
      _this64.effect = null;
      return _this64;
    }

    _createClass(PixelationDemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var anisotropy = Math.min(this.composer.getRenderer().capabilities.getMaxAnisotropy(), 8);
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            Sponza.load(assets, loadingManager, anisotropy);
            smaaImageLoader.load(function (_ref46) {
              var _ref47 = _slicedToArray(_ref46, 2),
                  search = _ref47[0],
                  area = _ref47[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.5, 2000);
        camera.position.set(-9, 0.5, 0);
        this.camera = camera;
        var target = new Vector3(0, 3, -3.5);
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = true;
        controls.settings.sensitivity.translation = 3.0;
        controls.lookAt(target);
        controls.setOrbitEnabled(false);
        this.controls = controls;
        scene.background = new Color(0xeeeeee);
        scene.add.apply(scene, _toConsumableArray(Sponza.createLights()));
        scene.add(assets.get("sponza"));
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(0.05);
        var pixelationEffect = new PixelationEffect(5.0);
        var effectPass = new EffectPass(camera, pixelationEffect);
        var smaaPass = new EffectPass(camera, smaaEffect);
        this.effect = pixelationEffect;
        composer.addPass(smaaPass);
        composer.addPass(effectPass);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var effect = this.effect;
        var params = {
          "granularity": effect.getGranularity()
        };
        menu.add(params, "granularity").min(0.0).max(50.0).step(0.1).onChange(function () {
          effect.setGranularity(params.granularity);
        });
      }
    }]);

    return PixelationDemo;
  }(PostProcessingDemo);

  var ShockWaveDemo = function (_PostProcessingDemo11) {
    _inherits(ShockWaveDemo, _PostProcessingDemo11);

    function ShockWaveDemo(composer) {
      var _this65;

      _classCallCheck(this, ShockWaveDemo);

      _this65 = _possibleConstructorReturn(this, _getPrototypeOf(ShockWaveDemo).call(this, "shock-wave", composer));
      _this65.effect = null;
      return _this65;
    }

    _createClass(ShockWaveDemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var anisotropy = Math.min(this.composer.getRenderer().capabilities.getMaxAnisotropy(), 8);
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            Sponza.load(assets, loadingManager, anisotropy);
            smaaImageLoader.load(function (_ref48) {
              var _ref49 = _slicedToArray(_ref48, 2),
                  search = _ref49[0],
                  area = _ref49[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.5, 2000);
        camera.position.set(-8, 1, -0.25);
        this.camera = camera;
        var target = new Vector3(-0.5, 3, -0.25);
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = true;
        controls.settings.sensitivity.translation = 3.0;
        controls.lookAt(target);
        controls.setOrbitEnabled(false);
        this.controls = controls;
        scene.background = new Color(0xeeeeee);
        scene.add.apply(scene, _toConsumableArray(Sponza.createLights()));
        scene.add(assets.get("sponza"));
        var geometry = new SphereBufferGeometry(1, 64, 64);
        var material = new MeshBasicMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.25
        });
        var mesh = new Mesh(geometry, material);
        mesh.position.copy(target);
        scene.add(mesh);
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(0.05);
        var shockWaveEffect = new ShockWaveEffect(camera, mesh.position, {
          speed: 1.25,
          maxRadius: 0.5,
          waveSize: 0.2,
          amplitude: 0.05
        });
        var effectPass = new EffectPass(camera, shockWaveEffect);
        var smaaPass = new EffectPass(camera, smaaEffect);
        this.effect = shockWaveEffect;
        composer.addPass(effectPass);
        composer.addPass(smaaPass);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var effect = this.effect;
        var uniforms = effect.uniforms;
        var params = {
          "size": uniforms.get("size").value,
          "extent": uniforms.get("maxRadius").value,
          "waveSize": uniforms.get("waveSize").value,
          "amplitude": uniforms.get("amplitude").value
        };
        menu.add(effect, "speed").min(0.0).max(10.0).step(0.001);
        menu.add(params, "size").min(0.01).max(2.0).step(0.001).onChange(function () {
          uniforms.get("size").value = params.size;
        });
        menu.add(params, "extent").min(0.0).max(10.0).step(0.001).onChange(function () {
          uniforms.get("maxRadius").value = params.extent;
        });
        menu.add(params, "waveSize").min(0.0).max(2.0).step(0.001).onChange(function () {
          uniforms.get("waveSize").value = params.waveSize;
        });
        menu.add(params, "amplitude").min(0.0).max(0.25).step(0.001).onChange(function () {
          uniforms.get("amplitude").value = params.amplitude;
        });
        menu.add(effect, "explode");
      }
    }]);

    return ShockWaveDemo;
  }(PostProcessingDemo);

  var SMAADemo = function (_PostProcessingDemo12) {
    _inherits(SMAADemo, _PostProcessingDemo12);

    function SMAADemo(composer) {
      var _this66;

      _classCallCheck(this, SMAADemo);

      _this66 = _possibleConstructorReturn(this, _getPrototypeOf(SMAADemo).call(this, "smaa", composer));
      _this66.secondaryRenderer = null;
      _this66.smaaEffect = null;
      _this66.copyPass = null;
      _this66.effectPass = null;
      _this66.edgesTextureEffect = null;
      _this66.weightsTextureEffect = null;
      _this66.object = null;
      _this66.rotate = true;
      return _this66;
    }

    _createClass(SMAADemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var anisotropy = Math.min(this.composer.getRenderer().capabilities.getMaxAnisotropy(), 8);
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            Sponza.load(assets, loadingManager, anisotropy);
            smaaImageLoader.load(function (_ref50) {
              var _ref51 = _slicedToArray(_ref50, 2),
                  search = _ref51[0],
                  area = _ref51[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();

        this.secondaryRenderer = function (primary) {
          var renderer = new WebGLRenderer({
            powerPreference: "high-performance",
            antialias: true
          });
          var size = primary.getSize(new Vector2());
          renderer.setSize(size.width, size.height);
          renderer.setClearColor(primary.getClearColor(), primary.getClearAlpha());
          renderer.setPixelRatio(primary.getPixelRatio());
          renderer.outputEncoding = primary.outputEncoding;
          renderer.shadowMap.type = primary.shadowMap.type;
          renderer.shadowMap.autoUpdate = false;
          renderer.shadowMap.needsUpdate = true;
          renderer.shadowMap.enabled = true;
          return renderer;
        }(renderer);

        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.5, 2000);
        camera.position.set(4, 8, 0.75);
        this.camera = camera;
        var target = new Vector3(-0.5, 6.5, -0.25);
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = true;
        controls.settings.sensitivity.translation = 3.0;
        controls.lookAt(target);
        controls.setOrbitEnabled(false);
        this.controls = controls;
        scene.background = new Color(0xccccff);
        scene.add.apply(scene, _toConsumableArray(Sponza.createLights()));
        scene.add(assets.get("sponza"));
        var cage = Cage.create(0x000000, 1.25, 0.025);
        cage.position.set(-0.5, 6.5, -0.25);
        cage.rotation.x += Math.PI * 0.1;
        cage.rotation.y += Math.PI * 0.3;
        this.object = cage;
        scene.add(cage);
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        var edgesTextureEffect = new TextureEffect({
          blendFunction: BlendFunction.SKIP,
          texture: smaaEffect.renderTargetEdges.texture
        });
        var weightsTextureEffect = new TextureEffect({
          blendFunction: BlendFunction.SKIP,
          texture: smaaEffect.renderTargetWeights.texture
        });
        var copyPass = new ShaderPass(new CopyMaterial());
        var effectPass = new EffectPass(camera, smaaEffect, edgesTextureEffect, weightsTextureEffect);
        this.smaaEffect = smaaEffect;
        this.edgesTextureEffect = edgesTextureEffect;
        this.weightsTextureEffect = weightsTextureEffect;
        this.copyPass = copyPass;
        this.effectPass = effectPass;
        copyPass.enabled = false;
        copyPass.renderToScreen = true;
        effectPass.renderToScreen = true;
        composer.addPass(copyPass);
        composer.addPass(effectPass);
      }
    }, {
      key: "render",
      value: function render(delta) {
        if (this.rotate) {
          var object = this.object;
          var PI2 = 2.0 * Math.PI;
          object.rotation.x += 0.01 * delta;
          object.rotation.y += 0.05 * delta;

          if (object.rotation.x >= PI2) {
            object.rotation.x -= PI2;
          }

          if (object.rotation.y >= PI2) {
            object.rotation.y -= PI2;
          }
        }

        _get(_getPrototypeOf(SMAADemo.prototype), "render", this).call(this, delta);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var scene = this.scene;
        var controls = this.controls;
        var composer = this.composer;
        var renderer1 = composer.getRenderer();
        var renderer2 = this.secondaryRenderer;
        var copyPass = this.copyPass;
        var renderPass = this.renderPass;
        var effectPass = this.effectPass;
        var smaaEffect = this.smaaEffect;
        var edgesTextureEffect = this.edgesTextureEffect;
        var weightsTextureEffect = this.weightsTextureEffect;
        var blendMode = smaaEffect.blendMode;
        var edgeDetectionMaterial = smaaEffect.edgeDetectionMaterial;
        var AAMode = {
          DISABLED: 0,
          BROWSER: 1,
          SMAA_EDGES: 2,
          SMAA_WEIGHTS: 3,
          SMAA: 4
        };
        var params = {
          "AA mode": AAMode.SMAA,
          "preset": SMAAPreset.HIGH,
          "edge detection": EdgeDetectionMode.DEPTH,
          "contrast factor": Number(edgeDetectionMaterial.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR),
          "opacity": this.smaaEffect.blendMode.opacity.value,
          "blend mode": this.smaaEffect.blendMode.blendFunction
        };

        function swapRenderers(browser) {
          var size = composer.getRenderer().getSize(new Vector2());

          if (browser && composer.getRenderer() !== renderer2) {
            scene.background.convertLinearToSRGB();
            renderer2.setSize(size.width, size.height);
            composer.replaceRenderer(renderer2);
            controls.setDom(renderer2.domElement);
          } else {
            scene.background.set(0x777777);
            renderer1.setSize(size.width, size.height);
            composer.replaceRenderer(renderer1);
            controls.setDom(renderer1.domElement);
          }
        }

        function toggleAAMode() {
          var mode = Number(params["AA mode"]);
          renderPass.renderToScreen = mode === AAMode.BROWSER;
          effectPass.enabled = mode === AAMode.SMAA || mode === AAMode.SMAA_EDGES || mode === AAMode.SMAA_WEIGHTS;
          copyPass.enabled = mode === AAMode.DISABLED;
          edgesTextureEffect.blendMode.blendFunction = mode === AAMode.SMAA_EDGES ? BlendFunction.NORMAL : BlendFunction.SKIP;
          weightsTextureEffect.blendMode.blendFunction = mode === AAMode.SMAA_WEIGHTS ? BlendFunction.NORMAL : BlendFunction.SKIP;
          effectPass.encodeOutput = mode !== AAMode.SMAA_EDGES && mode !== AAMode.SMAA_WEIGHTS;
          effectPass.recompile();
          swapRenderers(mode === AAMode.BROWSER);
        }

        menu.add(this, "rotate");
        menu.add(params, "AA mode", AAMode).onChange(toggleAAMode);
        menu.add(params, "preset", SMAAPreset).onChange(function () {
          smaaEffect.applyPreset(Number(params.preset));
        });
        menu.add(params, "edge detection", EdgeDetectionMode).onChange(function () {
          edgeDetectionMaterial.setEdgeDetectionMode(Number(params["edge detection"]));
        });
        menu.add(params, "contrast factor").min(1.0).max(3.0).step(0.01).onChange(function () {
          edgeDetectionMaterial.setLocalContrastAdaptationFactor(Number(params["contrast factor"]));
        });
        menu.add(params, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          blendMode.opacity.value = params.opacity;
        });
        menu.add(params, "blend mode", BlendFunction).onChange(function () {
          blendMode.blendFunction = Number(params["blend mode"]);
          effectPass.recompile();
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        _get(_getPrototypeOf(SMAADemo.prototype), "reset", this).call(this);

        if (this.secondaryRenderer !== null) {
          this.secondaryRenderer.dispose();
          this.secondaryRenderer = null;
        }
      }
    }]);

    return SMAADemo;
  }(PostProcessingDemo);

  var SSAODemo = function (_PostProcessingDemo13) {
    _inherits(SSAODemo, _PostProcessingDemo13);

    function SSAODemo(composer) {
      var _this67;

      _classCallCheck(this, SSAODemo);

      _this67 = _possibleConstructorReturn(this, _getPrototypeOf(SSAODemo).call(this, "ssao", composer));
      _this67.ssaoEffect = null;
      _this67.depthEffect = null;
      _this67.effectPass = null;
      _this67.normalPass = null;
      return _this67;
    }

    _createClass(SSAODemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var anisotropy = Math.min(this.composer.getRenderer().capabilities.getMaxAnisotropy(), 8);
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            Sponza.load(assets, loadingManager, anisotropy);
            smaaImageLoader.load(function (_ref52) {
              var _ref53 = _slicedToArray(_ref52, 2),
                  search = _ref53[0],
                  area = _ref53[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.5, 2000);
        camera.position.set(9.75, 1.72, 0.75);
        this.camera = camera;
        var target = new Vector3(0, 1, -1.25);
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = true;
        controls.settings.sensitivity.translation = 3.0;
        controls.lookAt(target);
        controls.setOrbitEnabled(false);
        this.controls = controls;
        scene.background = new Color(0xeeeeee);
        scene.add.apply(scene, _toConsumableArray(Sponza.createLights()));
        scene.add(assets.get("sponza"));
        var normalPass = new NormalPass(scene, camera);
        var depthEffect = new DepthEffect({
          blendFunction: BlendFunction.SKIP
        });
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.setEdgeDetectionThreshold(0.05);
        var ssaoEffect = new SSAOEffect(camera, normalPass.renderTarget.texture, {
          blendFunction: BlendFunction.MULTIPLY,
          samples: 11,
          rings: 4,
          distanceThreshold: 0.02,
          distanceFalloff: 0.0025,
          rangeThreshold: 0.0003,
          rangeFalloff: 0.0001,
          luminanceInfluence: 0.7,
          radius: 30,
          scale: 1.0,
          bias: 0.05
        });
        var effectPass = new EffectPass(camera, smaaEffect, ssaoEffect, depthEffect);
        this.ssaoEffect = ssaoEffect;
        this.depthEffect = depthEffect;
        this.effectPass = effectPass;
        this.normalPass = normalPass;
        composer.addPass(normalPass);
        composer.addPass(effectPass);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var effectPass = this.effectPass;
        var normalPass = this.normalPass;
        var ssaoEffect = this.ssaoEffect;
        var depthEffect = this.depthEffect;
        var blendMode = ssaoEffect.blendMode;
        var uniforms = ssaoEffect.uniforms;
        var RenderMode = {
          DEFAULT: 0,
          NORMALS: 1,
          DEPTH: 2
        };
        var params = {
          "distance": {
            "threshold": uniforms.get("distanceCutoff").value.x,
            "falloff": uniforms.get("distanceCutoff").value.y - uniforms.get("distanceCutoff").value.x
          },
          "proximity": {
            "threshold": uniforms.get("proximityCutoff").value.x,
            "falloff": uniforms.get("proximityCutoff").value.y - uniforms.get("proximityCutoff").value.x
          },
          "lum influence": uniforms.get("luminanceInfluence").value,
          "scale": uniforms.get("scale").value,
          "bias": uniforms.get("bias").value,
          "render mode": RenderMode.DEFAULT,
          "opacity": blendMode.opacity.value,
          "blend mode": blendMode.blendFunction
        };

        function toggleRenderMode() {
          var mode = Number.parseInt(params["render mode"]);
          effectPass.enabled = mode === RenderMode.DEFAULT || mode === RenderMode.DEPTH;
          normalPass.renderToScreen = mode === RenderMode.NORMALS;
          depthEffect.blendMode.blendFunction = mode === RenderMode.DEPTH ? BlendFunction.NORMAL : BlendFunction.SKIP;
          effectPass.encodeOutput = mode === RenderMode.DEFAULT;
          effectPass.recompile();
        }

        menu.add(params, "render mode", RenderMode).onChange(toggleRenderMode);
        menu.add(ssaoEffect, "samples").min(1).max(32).step(1).onChange(function () {
          return effectPass.recompile();
        });
        menu.add(ssaoEffect, "rings").min(1).max(16).step(1).onChange(function () {
          return effectPass.recompile();
        });
        menu.add(ssaoEffect, "radius").min(0.01).max(50.0).step(0.01);
        menu.add(params, "lum influence").min(0.0).max(1.0).step(0.001).onChange(function () {
          uniforms.get("luminanceInfluence").value = params["lum influence"];
        });
        var f = menu.addFolder("Distance Cutoff");
        f.add(params.distance, "threshold").min(0.0).max(1.0).step(0.0001).onChange(function () {
          ssaoEffect.setDistanceCutoff(params.distance.threshold, params.distance.falloff);
        });
        f.add(params.distance, "falloff").min(0.0).max(1.0).step(0.0001).onChange(function () {
          ssaoEffect.setDistanceCutoff(params.distance.threshold, params.distance.falloff);
        });
        f = menu.addFolder("Proximity Cutoff");
        f.add(params.proximity, "threshold").min(0.0).max(0.05).step(0.0001).onChange(function () {
          ssaoEffect.setProximityCutoff(params.proximity.threshold, params.proximity.falloff);
        });
        f.add(params.proximity, "falloff").min(0.0).max(0.01).step(0.0001).onChange(function () {
          ssaoEffect.setProximityCutoff(params.proximity.threshold, params.proximity.falloff);
        });
        menu.add(params, "bias").min(-1.0).max(1.0).step(0.001).onChange(function () {
          uniforms.get("bias").value = params.bias;
        });
        menu.add(params, "scale").min(0.0).max(2.0).step(0.001).onChange(function () {
          uniforms.get("scale").value = params.scale;
        });
        menu.add(params, "opacity").min(0.0).max(3.0).step(0.01).onChange(function () {
          blendMode.opacity.value = params.opacity;
        });
        menu.add(params, "blend mode", BlendFunction).onChange(function () {
          blendMode.blendFunction = Number.parseInt(params["blend mode"]);
          effectPass.recompile();
        });
      }
    }]);

    return SSAODemo;
  }(PostProcessingDemo);

  var TextureDemo = function (_PostProcessingDemo14) {
    _inherits(TextureDemo, _PostProcessingDemo14);

    function TextureDemo(composer) {
      var _this68;

      _classCallCheck(this, TextureDemo);

      _this68 = _possibleConstructorReturn(this, _getPrototypeOf(TextureDemo).call(this, "texture", composer));
      _this68.effect = null;
      _this68.pass = null;
      return _this68;
    }

    _createClass(TextureDemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var textureLoader = new TextureLoader(loadingManager);
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var anisotropy = Math.min(this.composer.getRenderer().capabilities.getMaxAnisotropy(), 8);
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            Sponza.load(assets, loadingManager, anisotropy);
            textureLoader.load("textures/scratches.jpg", function (t) {
              t.encoding = sRGBEncoding;
              t.wrapS = t.wrapT = RepeatWrapping;
              assets.set("scratches-color", t);
            });
            smaaImageLoader.load(function (_ref54) {
              var _ref55 = _slicedToArray(_ref54, 2),
                  search = _ref55[0],
                  area = _ref55[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.5, 2000);
        camera.position.set(-9, 0.5, 0);
        this.camera = camera;
        var target = new Vector3(0, 3, -3.5);
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = true;
        controls.settings.sensitivity.translation = 3.0;
        controls.lookAt(target);
        controls.setOrbitEnabled(false);
        this.controls = controls;
        scene.background = new Color(0xeeeeee);
        scene.add.apply(scene, _toConsumableArray(Sponza.createLights()));
        scene.add(assets.get("sponza"));
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(0.05);
        var textureEffect = new TextureEffect({
          blendFunction: BlendFunction.COLOR_DODGE,
          texture: assets.get("scratches-color")
        });
        textureEffect.blendMode.opacity.value = 0.8;
        var pass = new EffectPass(camera, smaaEffect, textureEffect);
        this.effect = textureEffect;
        this.pass = pass;
        composer.addPass(pass);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var pass = this.pass;
        var effect = this.effect;
        var blendMode = effect.blendMode;
        var params = {
          "opacity": blendMode.opacity.value,
          "blend mode": blendMode.blendFunction
        };
        menu.add(params, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          blendMode.opacity.value = params.opacity;
        });
        menu.add(params, "blend mode", BlendFunction).onChange(function () {
          blendMode.blendFunction = Number.parseInt(params["blend mode"]);
          pass.recompile();
        });
      }
    }]);

    return TextureDemo;
  }(PostProcessingDemo);

  var ToneMappingDemo = function (_PostProcessingDemo15) {
    _inherits(ToneMappingDemo, _PostProcessingDemo15);

    function ToneMappingDemo(composer) {
      var _this69;

      _classCallCheck(this, ToneMappingDemo);

      _this69 = _possibleConstructorReturn(this, _getPrototypeOf(ToneMappingDemo).call(this, "tone-mapping", composer));
      _this69.effect = null;
      _this69.pass = null;
      return _this69;
    }

    _createClass(ToneMappingDemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var anisotropy = Math.min(this.composer.getRenderer().capabilities.getMaxAnisotropy(), 8);
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            Sponza.load(assets, loadingManager, anisotropy);
            smaaImageLoader.load(function (_ref56) {
              var _ref57 = _slicedToArray(_ref56, 2),
                  search = _ref57[0],
                  area = _ref57[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var renderer = composer.getRenderer();
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.5, 2000);
        camera.position.set(-0.5, 5, -0.5);
        this.camera = camera;
        var target = new Vector3(-0.5, 10, 0);
        var controls = new DeltaControls(camera.position, camera.quaternion, renderer.domElement);
        controls.settings.pointer.lock = false;
        controls.settings.translation.enabled = true;
        controls.settings.sensitivity.translation = 3.0;
        controls.lookAt(target);
        controls.setOrbitEnabled(false);
        this.controls = controls;
        scene.background = new Color(0xeeeeee);
        scene.add.apply(scene, _toConsumableArray(Sponza.createLights()));
        scene.add(assets.get("sponza"));
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.setEdgeDetectionThreshold(0.05);
        var toneMappingEffect = new ToneMappingEffect({
          blendFunction: BlendFunction.NORMAL,
          adaptive: true,
          resolution: 256,
          middleGrey: 0.6,
          maxLuminance: 16.0,
          averageLuminance: 1.0,
          adaptationRate: 2.0
        });
        this.effect = toneMappingEffect;
        var pass = new EffectPass(camera, smaaEffect, toneMappingEffect);
        pass.dithering = true;
        this.pass = pass;
        composer.addPass(pass);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var pass = this.pass;
        var effect = this.effect;
        var blendMode = effect.blendMode;
        var params = {
          "resolution": effect.resolution,
          "adaptation rate": effect.adaptationRate,
          "average lum": effect.uniforms.get("averageLuminance").value,
          "max lum": effect.uniforms.get("maxLuminance").value,
          "middle grey": effect.uniforms.get("middleGrey").value,
          "opacity": blendMode.opacity.value,
          "blend mode": blendMode.blendFunction
        };
        menu.add(params, "resolution", [64, 128, 256, 512, 1024]).onChange(function () {
          effect.resolution = Number.parseInt(params.resolution);
        });
        var f = menu.addFolder("Luminance");
        f.add(effect, "adaptive").onChange(function () {
          pass.recompile();
        });
        f.add(params, "adaptation rate").min(0.0).max(5.0).step(0.01).onChange(function () {
          effect.adaptationRate = params["adaptation rate"];
        });
        f.add(params, "average lum").min(0.01).max(1.0).step(0.01).onChange(function () {
          effect.uniforms.get("averageLuminance").value = params["average lum"];
        });
        f.add(params, "max lum").min(0.0).max(32.0).step(1).onChange(function () {
          effect.uniforms.get("maxLuminance").value = params["max lum"];
        });
        f.add(params, "middle grey").min(0.0).max(1.0).step(0.01).onChange(function () {
          effect.uniforms.get("middleGrey").value = params["middle grey"];
        });
        f.open();
        menu.add(params, "opacity").min(0.0).max(1.0).step(0.01).onChange(function () {
          blendMode.opacity.value = params.opacity;
        });
        menu.add(params, "blend mode", BlendFunction).onChange(function () {
          blendMode.blendFunction = Number.parseInt(params["blend mode"]);
          pass.recompile();
        });
        menu.add(pass, "dithering");
      }
    }]);

    return ToneMappingDemo;
  }(PostProcessingDemo);

  var PerformanceDemo = function (_PostProcessingDemo16) {
    _inherits(PerformanceDemo, _PostProcessingDemo16);

    function PerformanceDemo(composer) {
      var _this70;

      _classCallCheck(this, PerformanceDemo);

      _this70 = _possibleConstructorReturn(this, _getPrototypeOf(PerformanceDemo).call(this, "performance", composer));
      _this70.renderer = null;
      _this70.effects = null;
      _this70.effectPass = null;
      _this70.passes = null;
      _this70.sun = null;
      _this70.light = null;
      _this70.fps = "0";
      _this70.acc0 = 0;
      _this70.acc1 = 0;
      _this70.frames = 0;
      return _this70;
    }

    _createClass(PerformanceDemo, [{
      key: "load",
      value: function load() {
        var assets = this.assets;
        var loadingManager = this.loadingManager;
        var textureLoader = new TextureLoader(loadingManager);
        var cubeTextureLoader = new CubeTextureLoader(loadingManager);
        var smaaImageLoader = new SMAAImageLoader(loadingManager);
        var path = "textures/skies/space-dark/";
        var format = ".jpg";
        var urls = [path + "px" + format, path + "nx" + format, path + "py" + format, path + "ny" + format, path + "pz" + format, path + "nz" + format];
        return new Promise(function (resolve, reject) {
          if (assets.size === 0) {
            loadingManager.onLoad = function () {
              return setTimeout(resolve, 250);
            };

            loadingManager.onProgress = ProgressManager.updateProgress;
            loadingManager.onError = reject;
            cubeTextureLoader.load(urls, function (t) {
              t.encoding = sRGBEncoding;
              assets.set("sky", t);
            });
            textureLoader.load("textures/scratches.jpg", function (t) {
              t.encoding = sRGBEncoding;
              t.wrapS = t.wrapT = RepeatWrapping;
              assets.set("scratches-color", t);
            });
            smaaImageLoader.load(function (_ref58) {
              var _ref59 = _slicedToArray(_ref58, 2),
                  search = _ref59[0],
                  area = _ref59[1];

              assets.set("smaa-search", search);
              assets.set("smaa-area", area);
            });
          } else {
            resolve();
          }
        });
      }
    }, {
      key: "initialize",
      value: function initialize() {
        var scene = this.scene;
        var assets = this.assets;
        var composer = this.composer;
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new PerspectiveCamera(50, aspect, 0.3, 2000);
        camera.position.set(-10, 1.125, 0);
        camera.lookAt(scene.position);
        this.camera = camera;
        scene.background = assets.get("sky");
        var ambientLight = new AmbientLight(0x212121);
        var pointLight = new PointLight(0xffbbaa, 50, 12);
        this.light = pointLight;
        scene.add(ambientLight, pointLight);
        var material = new MeshPhongMaterial({
          envMap: assets.get("sky"),
          color: 0xffaaaa,
          flatShading: true
        });
        var cylinderGeometry = new CylinderBufferGeometry(1, 1, 20, 6);
        var cylinderMesh = new Mesh(cylinderGeometry, material);
        cylinderMesh.rotation.set(0, 0, Math.PI / 2);
        scene.add(cylinderMesh);
        var torusGeometry = new TorusBufferGeometry(1, 0.4, 16, 100);
        var torusMeshes = [new Mesh(torusGeometry, material), new Mesh(torusGeometry, material), new Mesh(torusGeometry, material)];
        torusMeshes[0].position.set(0, 2.5, -5);
        torusMeshes[1].position.set(0, 2.5, 0);
        torusMeshes[2].position.set(0, 2.5, 5);
        scene.add(torusMeshes[0]);
        scene.add(torusMeshes[1]);
        scene.add(torusMeshes[2]);
        var sunMaterial = new MeshBasicMaterial({
          color: 0xffddaa,
          transparent: true,
          fog: false
        });
        var sunGeometry = new SphereBufferGeometry(0.65, 32, 32);
        var sun = new Mesh(sunGeometry, sunMaterial);
        sun.frustumCulled = false;
        this.sun = sun;
        var smaaEffect = new SMAAEffect(assets.get("smaa-search"), assets.get("smaa-area"), SMAAPreset.HIGH, EdgeDetectionMode.DEPTH);
        smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(0.05);
        var bloomEffect = new BloomEffect({
          blendFunction: BlendFunction.ADD,
          kernelSize: KernelSize.MEDIUM,
          luminanceThreshold: 0.825,
          luminanceSmoothing: 0.075,
          height: 480
        });
        var godRaysEffect = new GodRaysEffect(camera, sun, {
          kernelSize: KernelSize.SMALL,
          height: 480,
          density: 0.96,
          decay: 0.92,
          weight: 0.3,
          exposure: 0.55,
          samples: 60,
          clampMax: 1.0
        });
        var dotScreenEffect = new DotScreenEffect({
          blendFunction: BlendFunction.OVERLAY
        });
        var gridEffect = new GridEffect({
          blendFunction: BlendFunction.DARKEN,
          scale: 2.4,
          lineWidth: 0.0
        });
        var scanlineEffect = new ScanlineEffect({
          blendFunction: BlendFunction.OVERLAY,
          density: 1.04
        });
        var textureEffect = new TextureEffect({
          blendFunction: BlendFunction.REFLECT,
          texture: assets.get("scratches-color")
        });
        var colorAverageEffect = new ColorAverageEffect(BlendFunction.COLOR_DODGE);
        var colorDepthEffect = new ColorDepthEffect({
          bits: 56
        });
        var sepiaEffect = new SepiaEffect({
          blendFunction: BlendFunction.NORMAL
        });
        var brightnessContrastEffect = new BrightnessContrastEffect({
          contrast: 0.0
        });
        var hueSaturationEffect = new HueSaturationEffect({
          saturation: 0.125
        });
        var noiseEffect = new NoiseEffect({
          premultiply: true
        });
        var vignetteEffect = new VignetteEffect();
        colorAverageEffect.blendMode.opacity.value = 0.01;
        sepiaEffect.blendMode.opacity.value = 0.01;
        dotScreenEffect.blendMode.opacity.value = 0.01;
        gridEffect.blendMode.opacity.value = 0.01;
        scanlineEffect.blendMode.opacity.value = 0.01;
        textureEffect.blendMode.opacity.value = 0.8;
        noiseEffect.blendMode.opacity.value = 0.25;
        var effects = [smaaEffect, bloomEffect, godRaysEffect, colorAverageEffect, colorDepthEffect, dotScreenEffect, gridEffect, scanlineEffect, brightnessContrastEffect, hueSaturationEffect, sepiaEffect, textureEffect, noiseEffect, vignetteEffect];

        var effectPass = _construct(EffectPass, [camera].concat(effects));

        effectPass.renderToScreen = true;
        var passes = effects.map(function (effect) {
          return new EffectPass(camera, effect);
        });
        passes[passes.length - 1].renderToScreen = true;
        var _iteratorNormalCompletion25 = true;
        var _didIteratorError25 = false;
        var _iteratorError25 = undefined;

        try {
          for (var _iterator25 = passes[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
            var pass = _step25.value;
            pass.enabled = false;
            composer.addPass(pass);
          }
        } catch (err) {
          _didIteratorError25 = true;
          _iteratorError25 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion25 && _iterator25["return"] != null) {
              _iterator25["return"]();
            }
          } finally {
            if (_didIteratorError25) {
              throw _iteratorError25;
            }
          }
        }

        composer.addPass(effectPass);
        this.effectPass = effectPass;
        this.effects = effects;
        this.passes = passes;
      }
    }, {
      key: "render",
      value: function render(delta) {
        this.acc0 += delta;
        this.acc1 += delta;

        if (this.acc0 >= 1.0) {
          this.fps = this.frames.toFixed();
          this.acc0 = 0.0;
          this.frames = 0;
        } else {
          ++this.frames;
        }

        this.sun.position.set(0, 2.5, Math.sin(this.acc1 * 0.4) * 8);
        this.sun.updateWorldMatrix(true, false);
        this.light.position.copy(this.sun.position);

        _get(_getPrototypeOf(PerformanceDemo.prototype), "render", this).call(this, delta);
      }
    }, {
      key: "registerOptions",
      value: function registerOptions(menu) {
        var _this71 = this;

        var infoOptions = [];
        var params = {
          "effects": this.effectPass.effects.length,
          "merge effects": true,
          "firefox": function firefox() {
            return window.open("https://www.google.com/search?q=firefox+layout.frame_rate", "_blank");
          },
          "chrome": function chrome() {
            return window.open("https://www.google.com/search?q=chrome+--disable-frame-rate-limit --disable-gpu-vsync", "_blank");
          }
        };
        infoOptions.push(menu.add(params, "effects"));
        menu.add(params, "merge effects").onChange(function () {
          _this71.effectPass.enabled = params["merge effects"];
          var _iteratorNormalCompletion26 = true;
          var _didIteratorError26 = false;
          var _iteratorError26 = undefined;

          try {
            for (var _iterator26 = _this71.passes[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
              var pass = _step26.value;
              pass.enabled = !params["merge effects"];
            }
          } catch (err) {
            _didIteratorError26 = true;
            _iteratorError26 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion26 && _iterator26["return"] != null) {
                _iterator26["return"]();
              }
            } finally {
              if (_didIteratorError26) {
                throw _iteratorError26;
              }
            }
          }
        });
        infoOptions.push(menu.add(this, "fps").listen());
        var folder = menu.addFolder("Disable VSync");
        folder.add(params, "firefox");
        folder.add(params, "chrome");

        for (var _i5 = 0, _infoOptions = infoOptions; _i5 < _infoOptions.length; _i5++) {
          var option = _infoOptions[_i5];
          option.domElement.style.pointerEvents = "none";
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        _get(_getPrototypeOf(PerformanceDemo.prototype), "reset", this).call(this);

        this.acc0 = 0.0;
        this.acc1 = 0.0;
        this.frames = 0;
      }
    }]);

    return PerformanceDemo;
  }(PostProcessingDemo);

  var cache = new WeakSet();
  var renderer;
  var composer;
  var manager;

  function render(now) {
    requestAnimationFrame(render);
    manager.render(now);
  }

  function onChange(event) {
    var demo = event.demo;
    var size = composer.getRenderer().getSize(new Vector2());
    renderer.setSize(size.width, size.height);
    renderer.shadowMap.needsUpdate = true;
    composer.replaceRenderer(renderer);
    composer.reset();
    composer.addPass(demo.renderPass);
    ProgressManager.reset();
    document.querySelector(".loading").classList.remove("hidden");
  }

  function onLoad(event) {
    var demo = event.demo;

    if (!cache.has(demo)) {
      renderer.compile(demo.scene, demo.camera);
      demo.scene.traverse(function (object) {
        if (object.isMesh) {
          var _object$material2 = object.material,
              _object$material2$map = _object$material2.map,
              _map2 = _object$material2$map === void 0 ? null : _object$material2$map,
              _object$material2$nor = _object$material2.normalMap,
              normalMap = _object$material2$nor === void 0 ? null : _object$material2$nor;

          if (_map2 !== null) {
            renderer.initTexture(object.material.map);
          }

          if (normalMap !== null) {
            renderer.initTexture(object.material.normalMap);
          }
        }
      });
      cache.add(demo);
    }

    demo.renderPass.camera = demo.camera;
    document.querySelector(".loading").classList.add("hidden");
  }

  window.addEventListener("load", function (event) {
    var debug = window.location.href.indexOf("debug") !== -1;
    var viewport = document.getElementById("viewport");
    renderer = new WebGLRenderer({
      powerPreference: "high-performance"
    });
    renderer.outputEncoding = sRGBEncoding;
    renderer.debug.checkShaderErrors = debug;
    renderer.setSize(viewport.clientWidth, viewport.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x000000, 0.0);
    renderer.shadowMap.type = PCFSoftShadowMap;
    renderer.shadowMap.autoUpdate = false;
    renderer.shadowMap.needsUpdate = true;
    renderer.shadowMap.enabled = true;
    composer = new EffectComposer(renderer, {
      frameBufferType: HalfFloatType,
      stencilBuffer: true
    });
    manager = new DemoManager(viewport, {
      aside: document.getElementById("aside"),
      renderer: renderer
    });
    manager.addEventListener("change", onChange);
    manager.addEventListener("load", onLoad);
    var demos = [new BloomDemo(composer), new BlurDemo(composer), new ColorDepthDemo(composer), new ColorGradingDemo(composer), new DepthOfFieldDemo(composer), new GlitchDemo(composer), new GodRaysDemo(composer), new OutlineDemo(composer), new PatternDemo(composer), new PixelationDemo(composer), new ShockWaveDemo(composer), new SMAADemo(composer), new SSAODemo(composer), new TextureDemo(composer), new ToneMappingDemo(composer), new PerformanceDemo(composer)];
    var id = demos.map(function (demo) {
      return demo.id;
    }).indexOf(window.location.hash.slice(1));

    if (id === -1) {
      window.location.hash = "";
    }

    for (var _i6 = 0, _demos = demos; _i6 < _demos.length; _i6++) {
      var demo = _demos[_i6];
      manager.addDemo(demo);
    }

    render();
  });
  window.addEventListener("resize", function () {
    var timeoutId = 0;

    function handleResize(event) {
      var width = event.target.innerWidth;
      var height = event.target.innerHeight;
      manager.setSize(width, height);
      composer.setSize(width, height);
      timeoutId = 0;
    }

    return function onResize(event) {
      if (timeoutId === 0) {
        timeoutId = setTimeout(handleResize, 66, event);
      }
    };
  }());
  document.addEventListener("DOMContentLoaded", function (event) {
    var img = document.querySelector(".info img");
    var div = document.querySelector(".info div");

    if (img !== null && div !== null) {
      img.addEventListener("click", function (event) {
        div.classList.toggle("hidden");
      });
    }

    ProgressManager.initialize();
  });
  document.addEventListener("keydown", function (event) {
    var aside = document.getElementById("aside");

    if (aside !== null && event.key === "h") {
      event.preventDefault();
      aside.classList.toggle("hidden");
    }
  });

}());
