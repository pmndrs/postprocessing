/**
 * postprocessing v0.0.4 build Dec 22 2015
 * https://github.com/vanruesc/postprocessing
 * Copyright 2015 Raoul van RÃ¼schen, Zlib
 */
!function(a,b){"object"==typeof exports&&"undefined"!=typeof module?b(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],b):b(a.POSTPROCESSING={},a.THREE)}(this,function(a,b){"use strict";function c(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null},opacity:{type:"f",value:1}},fragmentShader:C.fragment,vertexShader:C.vertex})}function d(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null}},fragmentShader:D.fragment,vertexShader:D.vertex})}function e(){b.ShaderMaterial.call(this,{defines:{MIP_LEVEL_1X1:0},uniforms:{lastLum:{type:"t",value:null},currentLum:{type:"t",value:null},delta:{type:"f",value:.016},tau:{type:"f",value:1}},fragmentShader:E.fragment,vertexShader:E.vertex})}function f(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null},luminanceMap:{type:"t",value:null},averageLuminance:{type:"f",value:1},maxLuminance:{type:"f",value:16},middleGrey:{type:"f",value:.6}},fragmentShader:F.fragment,vertexShader:F.vertex})}function g(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null},tSize:{type:"v2",value:new b.Vector2(256,256)},center:{type:"v2",value:new b.Vector2(.5,.5)},angle:{type:"f",value:1.57},scale:{type:"f",value:1}},fragmentShader:G.fragment,vertexShader:G.vertex})}function h(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null},tDisp:{type:"t",value:null},byp:{type:"i",value:0},amount:{type:"f",value:.8},angle:{type:"f",value:.02},seed:{type:"f",value:.02},seedX:{type:"f",value:.02},seedY:{type:"f",value:.02},distortionX:{type:"f",value:.5},distortionY:{type:"f",value:.6},colS:{type:"f",value:.05}},fragmentShader:H.fragment,vertexShader:H.vertex})}function i(a,b){return Math.exp(-(a*a)/(2*b*b))}function j(){b.ShaderMaterial.call(this,{defines:{KERNEL_SIZE_FLOAT:25,KERNEL_SIZE_INT:25},uniforms:{tDiffuse:{type:"t",value:null},uImageIncrement:{type:"v2",value:new b.Vector2(.001953125,0)},cKernel:{type:"fv1",value:[]}},fragmentShader:I.fragment,vertexShader:I.vertex})}function k(){b.ShaderMaterial.call(this,{defines:{RINGS:3,SAMPLES:4},uniforms:{textureWidth:{type:"f",value:1},textureHeight:{type:"f",value:1},focalDepth:{type:"f",value:1},focalLength:{type:"f",value:24},fstop:{type:"f",value:.9},tColor:{type:"t",value:null},tDepth:{type:"t",value:null},maxblur:{type:"f",value:1},showFocus:{type:"i",value:0},manualdof:{type:"i",value:0},vignetting:{type:"i",value:0},depthblur:{type:"i",value:0},threshold:{type:"f",value:.5},gain:{type:"f",value:2},bias:{type:"f",value:.5},fringe:{type:"f",value:.7},znear:{type:"f",value:.1},zfar:{type:"f",value:2e3},noise:{type:"i",value:1},dithering:{type:"f",value:1e-4},pentagon:{type:"i",value:0},shaderFocus:{type:"i",value:1},focusCoords:{type:"v2",value:new b.Vector2}},fragmentShader:J.fragment,vertexShader:J.vertex})}function l(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null},time:{type:"f",value:0},nIntensity:{type:"f",value:.5},sIntensity:{type:"f",value:.05},sCount:{type:"f",value:4096},grayscale:{type:"i",value:1}},fragmentShader:K.fragment,vertexShader:K.vertex})}function m(a){b.ShaderMaterial.call(this,{defines:{NUM_SAMPLES:6},uniforms:a===M.COMBINE?{tDiffuse:{type:"t",value:null},tGodRays:{type:"t",value:null},intensity:{type:"f",value:.69}}:{tDiffuse:{type:"t",value:null},stepSize:{type:"f",value:1},decay:{type:"f",value:.93},weight:{type:"f",value:1},exposure:{type:"f",value:1},lightPosition:{type:"v3",value:null}},fragmentShader:a===M.COMBINE?L.fragment.combine:L.fragment.generate,vertexShader:L.vertex})}function n(a,c){this.scene=void 0!==a?a:new b.Scene,this.camera=void 0!==c?c:new b.OrthographicCamera(-1,1,1,-1,0,1),null===this.camera.parent&&this.scene.add(this.camera),this.enabled=!0,this.needsSwap=!1}function o(a){n.call(this),this.material=new c,this.renderTarget=a,void 0===this.renderTarget&&(this.renderTarget=new b.WebGLRenderTarget(window.innerWidth,window.innerHeight,{minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat,stencilBuffer:!1})),this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function p(a,b){n.call(this,a,b),this.inverse=!1,this.clear=!0}function q(){n.call(this,null,null)}function r(a,c){n.call(this),this.textureID=void 0!==c?c:"tDiffuse",this.material=a,this.renderToScreen=!1,this.needsSwap=!0,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function s(a,c,d,e,f){n.call(this,a,c),this.overrideMaterial=d,this.clearColor=e,this.clearAlpha=void 0!==f?f:1,this.oldClearColor=new b.Color,this.oldClearAlpha=1,this.clear=!0}function t(a,d){n.call(this,new b.Scene,new b.OrthographicCamera(-1,1,1,-1,0,1)),this.material=new c,this.material.uniforms.tDiffuse.value=a,this.material.uniforms.opacity.value=void 0!==d?d:1,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function u(a,g){n.call(this),this.resolution=void 0!==g?g:256,this.adaptive=void 0!==a?!1:!0,this.needsInit=!0,this.luminanceRT=null,this.previousLuminanceRT=null,this.currentLuminanceRT=null,this.materialCopy=new c,this.materialCopy.blending=b.NoBlending,this.materialCopy.depthTest=!1,this.materialLuminance=new d,this.materialLuminance.blending=b.NoBlending,this.materialAdaptiveLuminosity=new e,this.materialAdaptiveLuminosity.defines.MIP_LEVEL_1X1=(Math.log(this.resolution)/Math.log(2)).toFixed(1),this.materialAdaptiveLuminosity.blending=b.NoBlending,this.materialToneMapping=new f,this.materialToneMapping.blending=b.NoBlending,this.needsSwap=!0,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function v(a){n.call(this),this.material=new g,void 0!==a&&(void 0!==a.tSize&&this.material.uniforms.tSize.value.copy(a.tSize),void 0!==a.center&&this.material.uniforms.center.value.copy(a.center),void 0!==a.angle&&(this.material.uniforms.angle.value=a.angle),void 0!==a.scale&&(this.material.uniforms.scale.value=a.scale)),this.renderToScreen=!1,this.needsSwap=!0,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function w(a){n.call(this),void 0===a&&(a=64),this.material=new h,this.generateHeightmap(a),this.renderToScreen=!1,this.needsSwap=!0,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),this.material),this.scene.add(this.quad),this.goWild=!1,this.curF=0,this.generateTrigger()}function x(a){n.call(this),void 0===a&&(a={});var d=void 0!==a.kernelSize?a.kernelSize:25;this.resolutionScale=void 0===a.resolution?.25:b.Math.clamp(a.resolution,0,1),this.blurX=new b.Vector2(N,0),this.blurY=new b.Vector2,this.renderTargetX=new b.WebGLRenderTarget(1,1,{minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat}),this.renderTargetY=this.renderTargetX.clone(),this.copyMaterial=new c,this.copyMaterial.blending=b.AdditiveBlending,this.copyMaterial.transparent=!0,void 0!==a.strength&&(this.copyMaterial.uniforms.opacity.value=a.strength),this.convolutionMaterial=new j,this.convolutionMaterial.buildKernel(void 0!==a.sigma?a.sigma:4),this.convolutionMaterial.defines.KERNEL_SIZE_FLOAT=d.toFixed(1),this.convolutionMaterial.defines.KERNEL_SIZE_INT=d.toFixed(0),this.clear=!1,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function y(a,c,d){n.call(this,a,c),void 0===d&&(d={});var e=void 0!==d.resolution?e:256;this.renderTargetColor=new b.WebGLRenderTarget(e,e,{minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat}),this.renderTargetDepth=this.renderTargetColor.clone(),this.depthMaterial=new b.MeshDepthMaterial,this.bokehMaterial=new k,this.bokehMaterial.uniforms.tDepth.value=this.renderTargetDepth,void 0!==d.focus&&(this.bokehMaterial.uniforms.focus.value=d.focus),void 0!==d.aspect&&(this.bokehMaterial.uniforms.aspect.value=d.aspect),void 0!==d.aperture&&(this.bokehMaterial.uniforms.aperture.value=d.aperture),void 0!==d.maxBlur&&(this.bokehMaterial.uniforms.maxBlur.value=d.maxBlur),this.renderToScreen=!1,this.scene2=new b.Scene,this.camera2=new b.OrthographicCamera(-1,1,1,-1,0,1),this.scene2.add(this.camera2),this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene2.add(this.quad)}function z(a){n.call(this),this.material=new l,void 0!==a&&(void 0!==a.grayscale&&(this.material.uniforms.grayscale.value=a.grayscale),void 0!==a.noiseIntensity&&(this.material.uniforms.nIntensity.value=a.noiseIntensity),void 0!==a.scanlinesIntensity&&(this.material.uniforms.sIntensity.value=a.scanlinesIntensity),void 0!==a.scanlinesCount&&(this.material.uniforms.sCount.value=a.scanlinesCount)),this.renderToScreen=!1,this.needsSwap=!0,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function A(a,c,d,e){n.call(this,a,c),void 0===e&&(e={}),this.resolutionScale=void 0===e.resolution?.25:b.Math.clamp(e.resolution,0,1),this.lightSource=void 0!==d?d:new b.Object3D,this.screenLightPos=new b.Vector3,this.renderTargetX=new b.WebGLRenderTarget(1,1,{minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat}),this.renderTargetY=this.renderTargetX.clone(),this.godRaysGenerateMaterial=new m(M.GENERATE),this.godRaysGenerateMaterial.uniforms.lightPosition.value=this.screenLightPos,void 0!==e.samples&&(this.godRaysGenerateMaterial.defines.NUM_SAMPLES=e.samples),void 0!==e.decay&&(this.godRaysGenerateMaterial.uniforms.decay.value=e.decay),void 0!==e.weight&&(this.godRaysGenerateMaterial.uniforms.weight.value=e.weight),void 0!==e.exposure&&(this.godRaysGenerateMaterial.uniforms.exposure.value=e.exposure),this.exposure=this.godRaysGenerateMaterial.uniforms.exposure.value,this.godRaysCombineMaterial=new m(M.COMBINE),void 0!==e.intensity&&(this.godRaysCombineMaterial.uniforms.intensity.value=e.intensity),this.maskMaterial=new b.MeshBasicMaterial({color:0});var f=void 0!==e.rayLength?b.Math.clamp(e.rayLength,0,1):1,g=this.godRaysGenerateMaterial.defines.NUM_SAMPLES;this.stepSizes=new Float32Array(3),this.stepSizes[0]=f*Math.pow(g,-1),this.stepSizes[1]=f*Math.pow(g,-2),this.stepSizes[2]=f*Math.pow(g,-3),this.renderToScreen=!1,this.scene2=new b.Scene,this.camera2=new b.OrthographicCamera(-1,1,1,-1,0,1),this.scene2.add(this.camera2),this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene2.add(this.quad)}function B(a,d){var e,f,g;this.renderer=a,this.renderer.autoClear=!1,void 0===d&&(e=a.getPixelRatio(),f=Math.floor(a.context.canvas.width/e)||1,g=Math.floor(a.context.canvas.height/e)||1,d=new b.WebGLRenderTarget(f,g,{minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat,stencilBuffer:!1})),this.renderTarget1=d,this.renderTarget2=d.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.passes=[],this.copyPass=new r(new c)}b="default"in b?b["default"]:b;var C={fragment:"uniform sampler2D tDiffuse;\nuniform float opacity;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec4 texel = texture2D(tDiffuse, vUv);\n	gl_FragColor = opacity * texel;\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};c.prototype=Object.create(b.ShaderMaterial.prototype),c.prototype.constructor=c;var D={fragment:"uniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec4 texel = texture2D(tDiffuse, vUv);\n	vec3 luma = vec3(0.299, 0.587, 0.114);\n	float v = dot(texel.rgb, luma);\n\n	gl_FragColor = vec4(v, v, v, texel.a);\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};d.prototype=Object.create(b.ShaderMaterial.prototype),d.prototype.constructor=d;var E={fragment:"uniform sampler2D lastLum;\nuniform sampler2D currentLum;\nuniform float delta;\nuniform float tau;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec4 lastLum = texture2D(lastLum, vUv, MIP_LEVEL_1X1);\n	vec4 currentLum = texture2D(currentLum, vUv, MIP_LEVEL_1X1);\n\n	float fLastLum = lastLum.r;\n	float fCurrentLum = currentLum.r;\n\n	// Better results with squared input luminance.\n	fCurrentLum *= fCurrentLum;\n\n	// Adapt the luminance using Pattanaik's technique.\n	float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\n	// fAdaptedLum = sqrt(fAdaptedLum);\n\n	gl_FragColor = vec4(fAdaptedLum, fAdaptedLum, fAdaptedLum, 1.0);\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};e.prototype=Object.create(b.ShaderMaterial.prototype),e.prototype.constructor=e;var F={fragment:"uniform sampler2D tDiffuse;\nuniform float middleGrey;\nuniform float maxLuminance;\n\n#ifdef ADAPTED_LUMINANCE\n\n	uniform sampler2D luminanceMap;\n\n#else\n\n	uniform float averageLuminance;\n\n#endif\n\nvarying vec2 vUv;\n\nconst vec3 LUM_CONVERT = vec3(0.299, 0.587, 0.114);\n\nvec3 toneMap(vec3 vColor) {\n\n	#ifdef ADAPTED_LUMINANCE\n\n		// Get the calculated average luminance.\n		float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;\n\n	#else\n\n		float fLumAvg = averageLuminance;\n\n	#endif\n\n	// Calculate the luminance of the current pixel.\n	float fLumPixel = dot(vColor, LUM_CONVERT);\n\n	// Apply the modified operator (Eq. 4).\n	float fLumScaled = (fLumPixel * middleGrey) / fLumAvg;\n\n	float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\n	return fLumCompressed * vColor;\n\n}\n\nvoid main() {\n\n	vec4 texel = texture2D(tDiffuse, vUv);\n	gl_FragColor = vec4(toneMap(texel.rgb), texel.a);\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};f.prototype=Object.create(b.ShaderMaterial.prototype),f.prototype.constructor=f;var G={fragment:"uniform sampler2D tDiffuse;\nuniform vec2 center;\nuniform vec2 tSize;\nuniform float angle;\nuniform float scale;\n\nvarying vec2 vUv;\n\nfloat pattern() {\n\n	float s = sin(angle);\n	float c = cos(angle);\n\n	vec2 tex = vUv * tSize - center;\n	vec2 point = vec2(c * tex.x - s * tex.y, s * tex.x + c * tex.y) * scale;\n\n	return (sin(point.x) * sin(point.y)) * 4.0;\n\n}\n\nvoid main() {\n\n	vec4 color = texture2D(tDiffuse, vUv);\n	float average = (color.r + color.g + color.b) / 3.0;\n\n	gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};g.prototype=Object.create(b.ShaderMaterial.prototype),g.prototype.constructor=g;var H={fragment:"uniform sampler2D tDiffuse;\nuniform sampler2D tDisp;\nuniform int byp;\nuniform float amount;\nuniform float angle;\nuniform float seed;\nuniform float seedX;\nuniform float seedY;\nuniform float distortionX;\nuniform float distortionY;\nuniform float colS;\n\nvarying vec2 vUv;\n\nfloat rand(vec2 co) {\n\n	return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n\n}\n\nvoid main() {\n\n	vec2 coord = vUv;\n\n	float xs, ys;\n	vec4 normal;\n\n	vec2 offset;\n	vec4 cr, cga, cb;\n	vec4 snow, color;\n\n	if(byp < 1) {\n\n		xs = floor(gl_FragCoord.x / 0.5);\n		ys = floor(gl_FragCoord.y / 0.5);\n\n		normal = texture2D(tDisp, coord * seed * seed);\n\n		if(coord.y < distortionX + colS && coord.y > distortionX - colS * seed) {\n\n			if(seedX > 0.0){\n\n				coord.y = 1.0 - (coord.y + distortionY);\n\n			} else {\n\n				coord.y = distortionY;\n\n			}\n\n		}\n\n		if(coord.x < distortionY + colS && coord.x > distortionY - colS * seed) {\n\n			if(seedY > 0.0){\n\n				coord.x = distortionX;\n\n			} else {\n\n				coord.x = 1. - (coord.x + distortionX);\n\n			}\n\n		}\n\n		coord.x += normal.x * seedX * (seed / 5.0);\n		coord.y += normal.y * seedY * (seed / 5.0);\n\n		// Adopted from RGB shift shader.\n		offset = amount * vec2(cos(angle), sin(angle));\n		cr = texture2D(tDiffuse, coord + offset);\n		cga = texture2D(tDiffuse, coord);\n		cb = texture2D(tDiffuse, coord - offset);\n		color = vec4(cr.r, cga.g, cb.b, cga.a);\n		snow = 200.0 * amount * vec4(rand(vec2(xs * seed,ys * seed * 50.0)) * 0.2);\n		color += snow;\n\n	} else {\n\n		color = texture2D(tDiffuse, vUv);\n\n	}\n\n	gl_FragColor = color;\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};h.prototype=Object.create(b.ShaderMaterial.prototype),h.prototype.constructor=h;var I={fragment:"uniform sampler2D tDiffuse;\nuniform vec2 uImageIncrement;\nuniform float cKernel[KERNEL_SIZE_INT];\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec2 coord = vUv;\n	vec4 sum = vec4(0.0, 0.0, 0.0, 0.0);\n\n	for(int i = 0; i < KERNEL_SIZE_INT; ++i) {\n\n		sum += texture2D(tDiffuse, coord) * cKernel[i];\n		coord += uImageIncrement;\n\n	}\n\n	gl_FragColor = sum;\n\n}\n",vertex:"uniform vec2 uImageIncrement;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv - ((KERNEL_SIZE_FLOAT - 1.0) / 2.0) * uImageIncrement;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};j.prototype=Object.create(b.ShaderMaterial.prototype),j.prototype.constructor=j,j.prototype.buildKernel=function(a){var b,c,d,e,f=25,g=2*Math.ceil(3*a)+1;for(g>f&&(g=f),e=.5*(g-1),c=this.uniforms.cKernel.value,c.length=0,d=0,b=0;g>b;++b)c[b]=i(b-e,a),d+=c[b];for(b=0;g>b;++b)c[b]/=d};var J={fragment:"uniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float textureWidth;\nuniform float textureHeight;\n\nuniform float focalDepth;\nuniform float focalLength;\nuniform float fstop;\nuniform bool showFocus;\n\nuniform float znear;\nuniform float zfar;\n\nuniform bool manualdof;\nuniform bool vignetting;\nuniform bool shaderFocus;\nuniform bool noise;\nuniform bool depthblur;\nuniform bool pentagon;\n\nuniform vec2 focusCoords;\nuniform float maxblur;\nuniform float threshold;\nuniform float gain;\nuniform float bias;\nuniform float fringe;\nuniform float dithering;\n\nvarying vec2 vUv;\n\nconst float PI = 3.14159265;\nconst float TWO_PI = PI * 2.0;\nconst int samples = SAMPLES; // Samples on the first ring.\nconst int rings = RINGS;\nconst int maxringsamples = rings * samples;\n\nfloat ndofstart = 1.0; \nfloat ndofdist = 2.0;\nfloat fdofstart = 1.0;\nfloat fdofdist = 3.0;\n\nfloat CoC = 0.03; // Circle of Confusion size in mm (35mm film = 0.03mm).\n\nfloat vignout = 1.3;\nfloat vignin = 0.0;\nfloat vignfade = 22.0; \n\nfloat dbsize = 1.25;\nfloat feather = 0.4;\n\n/**\n * Pentagonal shape creation.\n */\n\nfloat penta(vec2 coords) {\n\n	float scale = float(rings) - 1.3;\n\n	vec4  HS0 = vec4( 1.0,          0.0,         0.0,  1.0);\n	vec4  HS1 = vec4( 0.309016994,  0.951056516, 0.0,  1.0);\n	vec4  HS2 = vec4(-0.809016994,  0.587785252, 0.0,  1.0);\n	vec4  HS3 = vec4(-0.809016994, -0.587785252, 0.0,  1.0);\n	vec4  HS4 = vec4( 0.309016994, -0.951056516, 0.0,  1.0);\n	vec4  HS5 = vec4( 0.0        ,  0.0        , 1.0,  1.0);\n\n	vec4  one = vec4(1.0);\n\n	vec4 P = vec4((coords), vec2(scale, scale));\n\n	vec4 dist = vec4(0.0);\n	float inorout = -4.0;\n\n	dist.x = dot(P, HS0);\n	dist.y = dot(P, HS1);\n	dist.z = dot(P, HS2);\n	dist.w = dot(P, HS3);\n\n	dist = smoothstep(-feather, feather, dist);\n\n	inorout += dot(dist, one);\n\n	dist.x = dot(P, HS4);\n	dist.y = HS5.w - abs(P.z);\n\n	dist = smoothstep(-feather, feather, dist);\n	inorout += dist.x;\n\n	return clamp(inorout, 0.0, 1.0);\n\n}\n\n/**\n * Depth buffer blur.\n */\n\nfloat bdepth(vec2 coords) {\n\n	float d = 0.0;\n	float kernel[9];\n	vec2 offset[9];\n\n	vec2 wh = vec2(1.0 / textureWidth,1.0 / textureHeight) * dbsize;\n\n	offset[0] = vec2(-wh.x, -wh.y);\n	offset[1] = vec2(0.0, -wh.y);\n	offset[2] = vec2(wh.x -wh.y);\n\n	offset[3] = vec2(-wh.x,  0.0);\n	offset[4] = vec2(0.0,   0.0);\n	offset[5] = vec2(wh.x,  0.0);\n\n	offset[6] = vec2(-wh.x, wh.y);\n	offset[7] = vec2(0.0, wh.y);\n	offset[8] = vec2(wh.x, wh.y);\n\n	kernel[0] = 1.0 / 16.0; kernel[1] = 2.0 / 16.0; kernel[2] = 1.0 / 16.0;\n	kernel[3] = 2.0 / 16.0; kernel[4] = 4.0 / 16.0; kernel[5] = 2.0 / 16.0;\n	kernel[6] = 1.0 / 16.0; kernel[7] = 2.0 / 16.0; kernel[8] = 1.0 / 16.0;\n\n	for(int i = 0; i < 9; ++i) {\n\n		float tmp = texture2D(tDepth, coords + offset[i]).r;\n		d += tmp * kernel[i];\n\n	}\n\n	return d;\n\n}\n\n/**\n * Processing the sample.\n */\n\nvec3 color(vec2 coords, float blur) {\n\n	vec3 col = vec3(0.0);\n	vec2 texel = vec2(1.0 / textureWidth, 1.0 / textureHeight);\n\n	col.r = texture2D(tColor, coords + vec2(0.0, 1.0) * texel * fringe * blur).r;\n	col.g = texture2D(tColor, coords + vec2(-0.866, -0.5) * texel * fringe * blur).g;\n	col.b = texture2D(tColor, coords + vec2(0.866, -0.5) * texel * fringe * blur).b;\n\n	vec3 lumcoeff = vec3(0.299, 0.587, 0.114);\n	float lum = dot(col.rgb, lumcoeff);\n	float thresh = max((lum - threshold) * gain, 0.0);\n\n	return col + mix(vec3(0.0), col, thresh * blur);\n\n}\n\n/**\n * Generating noise/pattern texture for dithering.\n */\n\nvec2 rand(vec2 coord) {\n\n	float noiseX = ((fract(1.0 - coord.s * (textureWidth / 2.0)) * 0.25) + (fract(coord.t * (textureHeight / 2.0)) * 0.75)) * 2.0 - 1.0;\n	float noiseY = ((fract(1.0 - coord.s * (textureWidth / 2.0)) * 0.75) + (fract(coord.t * (textureHeight / 2.0)) * 0.25)) * 2.0 - 1.0;\n\n	if(noise) {\n\n		noiseX = clamp(fract(sin(dot(coord, vec2(12.9898, 78.233))) * 43758.5453), 0.0, 1.0) * 2.0 - 1.0;\n		noiseY = clamp(fract(sin(dot(coord, vec2(12.9898, 78.233) * 2.0)) * 43758.5453), 0.0, 1.0) * 2.0 - 1.0;\n\n	}\n\n	return vec2(noiseX, noiseY);\n\n}\n\n/**\n * Distance based edge smoothing.\n */\n\nvec3 debugFocus(vec3 col, float blur, float depth) {\n\n	float edge = 0.002 * depth;\n	float m = clamp(smoothstep(0.0, edge, blur), 0.0, 1.0);\n	float e = clamp(smoothstep(1.0 - edge, 1.0, blur), 0.0, 1.0);\n\n	col = mix(col, vec3(1.0, 0.5, 0.0), (1.0 - m) * 0.6);\n	col = mix(col, vec3(0.0, 0.5, 1.0), ((1.0 - e) - (1.0 - m)) * 0.2);\n\n	return col;\n\n}\n\nfloat linearize(float depth) {\n\n	return -zfar * znear / (depth * (zfar - znear) - zfar);\n\n}\n\nfloat vignette() {\n\n	float dist = distance(vUv.xy, vec2(0.5, 0.5));\n	dist = smoothstep(vignout + (fstop / vignfade), vignin + (fstop / vignfade), dist);\n\n	return clamp(dist, 0.0, 1.0);\n\n}\n\nfloat gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\n\n	float rings2 = float(rings);\n	float step = TWO_PI / float(ringsamples);\n	float pw = cos(j * step) * i;\n	float ph = sin(j * step) * i;\n	float p = 1.0;\n\n	if(pentagon) {\n\n		p = penta(vec2(pw,ph));\n\n	}\n\n	col += color(vUv.xy + vec2(pw * w, ph * h), blur) * mix(1.0, i / rings2, bias) * p;\n\n	return 1.0 * mix(1.0, i / rings2, bias) * p;\n\n}\n\nvoid main() {\n\n	// Scene depth calculation.\n\n	float depth = linearize(texture2D(tDepth, vUv.xy).x);\n\n	if(depthblur) { depth = linearize(bdepth(vUv.xy)); }\n\n	// Focal plane calculation.\n\n	float fDepth = focalDepth;\n\n	if(shaderFocus) { fDepth = linearize(texture2D(tDepth, focusCoords).x); }\n\n	// Dof blur factor calculation.\n\n	float blur = 0.0;\n\n	float a, b, c, d, o;\n\n	if(manualdof) {\n\n		a = depth - fDepth; // Focal plane.\n		b = (a - fdofstart) / fdofdist; // Far DoF.\n		c = (-a - ndofstart) / ndofdist; // Near Dof.\n		blur = (a > 0.0) ? b : c;\n\n	} else {\n\n		f = focalLength; // Focal length in mm.\n		d = fDepth * 1000.0; // Focal plane in mm.\n		o = depth * 1000.0; // Depth in mm.\n\n		a = (o * f) / (o - f);\n		b = (d * f) / (d - f);\n		c = (d - f) / (d * fstop * CoC);\n\n		blur = abs(a - b) * c;\n	}\n\n	blur = clamp(blur, 0.0, 1.0);\n\n	// Calculation of pattern for dithering.\n\n	vec2 noise = rand(vUv.xy) * dithering * blur;\n\n	// Getting blur x and y step factor.\n\n	float w = (1.0 / textureWidth) * blur * maxblur + noise.x;\n	float h = (1.0 / textureHeight) * blur * maxblur + noise.y;\n\n	// Calculation of final color.\n\n	vec3 col = vec3(0.0);\n\n	if(blur < 0.05) {\n\n		// Some optimization thingy.\n		col = texture2D(tColor, vUv.xy).rgb;\n\n	} else {\n\n		col = texture2D(tColor, vUv.xy).rgb;\n		float s = 1.0;\n		int ringsamples;\n\n		for(int i = 1; i <= rings; ++i) {\n\n			// Unboxing.\n			ringsamples = i * samples;\n\n			for(int j = 0; j < maxringsamples; ++j) {\n\n				if(j >= ringsamples) { break; }\n\n				s += gather(float(i), float(j), ringsamples, col, w, h, blur);\n\n			}\n\n		}\n\n		col /= s; // Divide by sample count.\n\n	}\n\n	if(showFocus) { col = debugFocus(col, blur, depth); }\n\n	if(vignetting) { col *= vignette(); }\n\n	gl_FragColor.rgb = col;\n	gl_FragColor.a = 1.0;\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};k.prototype=Object.create(b.ShaderMaterial.prototype),k.prototype.constructor=k;var K={fragment:"uniform sampler2D tDiffuse;\nuniform float time;\nuniform bool grayscale;\nuniform float nIntensity;\nuniform float sIntensity;\nuniform float sCount;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec4 cTextureScreen = texture2D(tDiffuse, vUv);\n\n	// Noise.\n\n	float x = vUv.x * vUv.y * time * 1000.0;\n	x = mod(x, 13.0) * mod(x, 123.0);\n	float dx = mod(x, 0.01);\n\n	vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp(0.1 + dx * 100.0, 0.0, 1.0);\n\n	vec2 sc = vec2(sin(vUv.y * sCount), cos(vUv.y * sCount));\n\n	// Scanlines.\n\n	cResult += cTextureScreen.rgb * vec3(sc.x, sc.y, sc.x) * sIntensity;\n\n	cResult = cTextureScreen.rgb + clamp(nIntensity, 0.0, 1.0) * (cResult - cTextureScreen.rgb);\n\n	if(grayscale) {\n\n		cResult = vec3(cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11);\n\n	}\n\n	gl_FragColor =  vec4(cResult, cTextureScreen.a);\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};l.prototype=Object.create(b.ShaderMaterial.prototype),l.prototype.constructor=l;var L={fragment:{generate:"uniform sampler2D tDiffuse;\nuniform float stepSize;\nuniform float decay;\nuniform float weight;\nuniform float exposure;\nuniform vec3 lightPosition;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec2 texCoord = vUv;\n	float numSamples = float(NUM_SAMPLES);\n\n	// Calculate vector from pixel to light source in screen space.\n	vec2 deltaTexCoord = texCoord - lightPosition.st;\n	float distance = length(deltaTexCoord);\n\n	// Step vector (uv space).\n	vec2 step = stepSize * deltaTexCoord / distance;\n\n	// Number of iterations between pixel and sun.\n	int iterations = int(distance / stepSize);\n\n	// Set up illumination decay factor.\n	float illuminationDecay = 1.0;\n\n	// Sample color.\n	vec4 sample;\n\n	// Color accumulator.\n	vec4 color = vec4(0.0);\n\n	// Estimate the probability of occlusion at each pixel by summing samples along a ray to the light source.\n	for(int i = 0; i < NUM_SAMPLES; ++i) {\n\n		// Don't do more than necessary.\n		if(i <= iterations && texCoord.y < 1.0) {\n\n			sample = texture2D(tDiffuse, texCoord);\n\n			// Apply sample attenuation scale/decay factors.\n			sample *= illuminationDecay * weight;\n\n			color += sample;\n\n			// Update exponential decay factor.\n			illuminationDecay *= decay;\n\n		}\n\n		texCoord -= step;\n\n	}\n\n	// Output final color with a further scale control factor.\n	gl_FragColor = (color / numSamples) * exposure;\n\n}\n",combine:"uniform sampler2D tDiffuse;\nuniform sampler2D tGodRays;\nuniform float intensity;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	gl_FragColor = texture2D(tDiffuse, vUv) + intensity * texture2D(tGodRays, vUv);\n\n}\n"},vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"},M=Object.freeze({GENERATE:0,COMBINE:1});m.prototype=Object.create(b.ShaderMaterial.prototype),m.prototype.constructor=m,n.prototype.render=function(a,b,c,d){throw new Error("Render method not implemented!")},n.prototype.setSize=function(a,b){},o.prototype=Object.create(n.prototype),o.prototype.constructor=o,o.prototype.render=function(a,b,c,d){this.material.uniforms.tDiffuse.value=c,this.quad.material=this.material,a.render(this.scene,this.camera,this.renderTarget,this.clear)},p.prototype=Object.create(n.prototype),p.prototype.constructor=p,p.prototype.render=function(a,b,c,d,e){var f,g,h=a.context;h.colorMask(!1,!1,!1,!1),h.depthMask(!1),this.inverse?(f=0,g=1):(f=1,g=0),h.enable(h.STENCIL_TEST),h.stencilOp(h.REPLACE,h.REPLACE,h.REPLACE),h.stencilFunc(h.ALWAYS,f,4294967295),h.clearStencil(g),a.render(this.scene,this.camera,c,this.clear),a.render(this.scene,this.camera,b,this.clear),h.colorMask(!0,!0,!0,!0),h.depthMask(!0),h.stencilFunc(h.EQUAL,1,4294967295),h.stencilOp(h.KEEP,h.KEEP,h.KEEP)},q.prototype=Object.create(n.prototype),q.prototype.constructor=q,q.prototype.render=function(a,b,c,d,e){a.context.disable(context.STENCIL_TEST)},r.prototype=Object.create(n.prototype),r.prototype.constructor=r,r.prototype.render=function(a,b,c,d){void 0!==this.material.uniforms[this.textureID]&&(this.material.uniforms[this.textureID].value=c),this.quad.material=this.material,this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,b,this.clear)},s.prototype=Object.create(n.prototype),s.prototype.constructor=s,s.prototype.render=function(a,b,c,d){var e=void 0!==this.clearColor;this.scene.overrideMaterial=this.overrideMaterial,e&&(this.oldClearColor.copy(a.getClearColor()),this.oldClearAlpha=a.getClearAlpha(),a.setClearColor(this.clearColor,this.clearAlpha)),a.render(this.scene,this.camera,c,this.clear),e&&a.setClearColor(this.oldClearColor,this.oldClearAlpha),this.scene.overrideMaterial=null},t.prototype=Object.create(n.prototype),t.prototype.constructor=t,t.prototype.render=function(a,b,c,d){this.quad.material=this.material,a.render(this.scene,this.camera,c)},u.prototype=Object.create(n.prototype),u.prototype.constructor=u,u.prototype.render=function(a,b,c,d){this.needsInit&&(this.reset(a),this.luminanceRT.texture.type=c.texture.type,this.previousLuminanceRT.texture.type=c.texture.type,this.currentLuminanceRT.texture.type=c.texture.type,this.needsInit=!1),this.adaptive&&(this.quad.material=this.materialLuminance,this.materialLuminance.uniforms.tDiffuse.value=c,a.render(this.scene,this.camera,this.currentLuminanceRT),this.quad.material=this.materialAdaptiveLuminosity,this.materialAdaptiveLuminosity.uniforms.delta.value=d,this.materialAdaptiveLuminosity.uniforms.lastLum.value=this.previousLuminanceRT,this.materialAdaptiveLuminosity.uniforms.currentLum.value=this.currentLuminanceRT,a.render(this.scene,this.camera,this.luminanceRT),this.quad.material=this.materialCopy,this.materialCopy.uniforms.tDiffuse.value=this.luminanceRT,a.render(this.scene,this.camera,this.previousLuminanceRT)),this.quad.material=this.materialToneMapping,this.materialToneMapping.uniforms.tDiffuse.value=c,a.render(this.scene,this.camera,b,this.clear)},u.prototype.reset=function(a){null!==this.luminanceRT&&this.luminanceRT.dispose(),null!==this.currentLuminanceRT&&this.currentLuminanceRT.dispose(),null!==this.previousLuminanceRT&&this.previousLuminanceRT.dispose();var c={minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat};this.luminanceRT=new b.WebGLRenderTarget(this.resolution,this.resolution,c),this.luminanceRT.texture.generateMipmaps=!1,this.previousLuminanceRT=new b.WebGLRenderTarget(this.resolution,this.resolution,c),this.previousLuminanceRT.texture.generateMipmaps=!1,c.minFilter=b.LinearMipMapLinearFilter,this.currentLuminanceRT=new b.WebGLRenderTarget(this.resolution,this.resolution,c),this.adaptive&&(this.materialToneMapping.defines.ADAPTED_LUMINANCE=1,this.materialToneMapping.uniforms.luminanceMap.value=this.luminanceRT),this.quad.material=new b.MeshBasicMaterial({color:7829367}),this.materialLuminance.needsUpdate=!0,this.materialAdaptiveLuminosity.needsUpdate=!0,this.materialToneMapping.needsUpdate=!0},u.prototype.setAdaptive=function(a){a?(this.adaptive=!0,this.materialToneMapping.defines.ADAPTED_LUMINANCE=1,this.materialToneMapping.uniforms.luminanceMap.value=this.luminanceRT):(this.adaptive=!1,delete this.materialToneMapping.defines.ADAPTED_LUMINANCE,this.materialToneMapping.uniforms.luminanceMap.value=void 0),
this.materialToneMapping.needsUpdate=!0},u.prototype.setAdaptionRate=function(a){void 0!==a&&(this.materialAdaptiveLuminosity.uniforms.tau.value=Math.abs(a))},u.prototype.setMaxLuminance=function(a){void 0!==a&&(this.materialToneMapping.uniforms.maxLuminance.value=a)},u.prototype.setAverageLuminance=function(a){void 0!==a&&(this.materialToneMapping.uniforms.averageLuminance.value=a)},u.prototype.setMiddleGrey=function(a){void 0!==a&&(this.materialToneMapping.uniforms.middleGrey.value=a)},u.prototype.dispose=function(){this.luminanceRT&&this.luminanceRT.dispose(),this.previousLuminanceRT&&this.previousLuminanceRT.dispose(),this.currentLuminanceRT&&this.currentLuminanceRT.dispose(),this.materialLuminance&&this.materialLuminance.dispose(),this.materialAdaptiveLuminosity&&this.materialAdaptiveLuminosity.dispose(),this.materialCopy&&this.materialCopy.dispose(),this.materialToneMapping&&this.materialToneMapping.dispose()},v.prototype=Object.create(n.prototype),v.prototype.constructor=v,v.prototype.render=function(a,b,c,d){this.material.uniforms.tDiffuse.value=c,this.material.uniforms.tSize.value.set(c.width,c.height),this.quad.material=this.material,this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,b,!1)},w.prototype=Object.create(n.prototype),w.prototype.constructor=w,w.prototype.render=function(a,c,d){var e=this.material.uniforms;e.tDiffuse.value=d,e.seed.value=Math.random(),e.byp.value=0,this.curF%this.randX===0||this.goWild?(e.amount.value=Math.random()/30,e.angle.value=b.Math.randFloat(-Math.PI,Math.PI),e.seedX.value=b.Math.randFloat(-1,1),e.seedY.value=b.Math.randFloat(-1,1),e.distortionX.value=b.Math.randFloat(0,1),e.distortionY.value=b.Math.randFloat(0,1),this.curF=0,this.generateTrigger()):this.curF%this.randX<this.randX/5?(e.amount.value=Math.random()/90,e.angle.value=b.Math.randFloat(-Math.PI,Math.PI),e.distortionX.value=b.Math.randFloat(0,1),e.distortionY.value=b.Math.randFloat(0,1),e.seedX.value=b.Math.randFloat(-.3,.3),e.seedY.value=b.Math.randFloat(-.3,.3)):this.goWild||(e.byp.value=1),++this.curF,this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,c,!1)},w.prototype.generateTrigger=function(){this.randX=b.Math.randInt(120,240)},w.prototype.generateHeightmap=function(a){var c,d,e,f=a*a,g=new Float32Array(3*f);for(c=0;f>c;++c)d=b.Math.randFloat(0,1),g[3*c]=d,g[3*c+1]=d,g[3*c+2]=d;e=new b.DataTexture(g,a,a,b.RGBFormat,b.FloatType),e.needsUpdate=!0,this.material.uniforms.tDisp.value=e};var N=.001953125;x.prototype=Object.create(n.prototype),x.prototype.constructor=x,x.prototype.render=function(a,b,c,d,e){e&&a.context.disable(a.context.STENCIL_TEST),this.quad.material=this.convolutionMaterial,this.convolutionMaterial.uniforms.tDiffuse.value=c,this.convolutionMaterial.uniforms.uImageIncrement.value.copy(this.blurX),a.render(this.scene,this.camera,this.renderTargetX,!0),this.convolutionMaterial.uniforms.tDiffuse.value=this.renderTargetX,this.convolutionMaterial.uniforms.uImageIncrement.value.copy(this.blurY),a.render(this.scene,this.camera,this.renderTargetY,!0),this.quad.material=this.copyMaterial,this.copyMaterial.uniforms.tDiffuse.value=this.renderTargetY,e&&a.context.enable(a.context.STENCIL_TEST),a.render(this.scene,this.camera,c,this.clear)},x.prototype.setSize=function(a,b){this.renderTargetX.setSize(Math.floor(a*this.resolutionScale),Math.floor(b*this.resolutionScale)),this.renderTargetX.width<=0&&(this.renderTargetX.width=1),this.renderTargetX.height<=0&&(this.renderTargetX.height=1),this.renderTargetY.setSize(this.renderTargetX.width,this.renderTargetX.height),this.blurY.set(0,a/b*N)},y.prototype=Object.create(n.prototype),y.prototype.constructor=y,y.prototype.render=function(a,b,c,d,e){this.scene.overrideMaterial=this.depthMaterial,a.render(this.scene,this.camera,this.renderTargetDepth,!0),this.scene.overrideMaterial=null,this.quad.material=this.bokehMaterial,this.bokehMaterial.uniforms.tColor.value=c,this.renderToScreen?a.render(this.scene2,this.camera2):a.render(this.scene2,this.camera2,b,this.clear)},z.prototype=Object.create(n.prototype),z.prototype.constructor=z,z.prototype.render=function(a,b,c,d){this.material.uniforms.tDiffuse.value=c,this.material.uniforms.time.value+=d,this.quad.material=this.material,this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,b,!1)},A.prototype=Object.create(n.prototype),A.prototype.constructor=A,A.prototype.render=function(a,c,d){var e;this.screenLightPos.copy(this.lightSource.position).project(this.camera),this.screenLightPos.x=b.Math.clamp(.5*(this.screenLightPos.x+1),0,1),this.screenLightPos.y=b.Math.clamp(.55*(this.screenLightPos.y+1),0,1),this.godRaysGenerateMaterial.uniforms.exposure.value=this.computeAngleScalar()*this.exposure,this.scene.overrideMaterial=this.maskMaterial,e=a.getClearColor().getHex(),a.setClearColor(16777215),a.render(this.scene,this.camera,this.renderTargetX,!0),a.setClearColor(e),this.scene.overrideMaterial=null,this.quad.material=this.godRaysGenerateMaterial,this.godRaysGenerateMaterial.uniforms.stepSize.value=this.stepSizes[0],this.godRaysGenerateMaterial.uniforms.tDiffuse.value=this.renderTargetX,a.render(this.scene2,this.camera2,this.renderTargetY),this.godRaysGenerateMaterial.uniforms.stepSize.value=this.stepSizes[1],this.godRaysGenerateMaterial.uniforms.tDiffuse.value=this.renderTargetY,a.render(this.scene2,this.camera2,this.renderTargetX),this.godRaysGenerateMaterial.uniforms.stepSize.value=this.stepSizes[2],this.godRaysGenerateMaterial.uniforms.tDiffuse.value=this.renderTargetX,a.render(this.scene2,this.camera2,this.renderTargetY),this.quad.material=this.godRaysCombineMaterial,this.godRaysCombineMaterial.uniforms.tDiffuse.value=d,this.godRaysCombineMaterial.uniforms.tGodRays.value=this.renderTargetY,this.renderToScreen?a.render(this.scene2,this.camera2):a.render(this.scene2,this.camera2,c)};var O=.5*Math.PI,P=new b.Vector3(0,0,-1),Q=new b.Vector3,R=new b.Vector3;A.prototype.computeAngleScalar=function(){return R.copy(P),Q.copy(P.applyMatrix4(this.camera.matrixWorld)),P.copy(R),R.copy(Q),Q.sub(this.camera.position),R.sub(this.lightSource.position),b.Math.clamp(Q.angleTo(R)-O,0,1)},A.prototype.setSize=function(a,b){this.renderTargetX.setSize(Math.floor(a*this.resolutionScale),Math.floor(b*this.resolutionScale)),this.renderTargetX.width<=0&&(this.renderTargetX.width=1),this.renderTargetX.height<=0&&(this.renderTargetX.height=1),this.renderTargetY.setSize(this.renderTargetX.width,this.renderTargetX.height)},B.prototype.swapBuffers=function(){var a=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=a},B.prototype.addPass=function(a){a.setSize(this.renderTarget1.width,this.renderTarget1.height),this.passes.push(a)},B.prototype.insertPass=function(a,b){a.setSize(this.renderTarget1.width,this.renderTarget1.height),this.passes.splice(b,0,a)},B.prototype.render=function(a){this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2;var b,c,d,e,f=!1;for(b=0,c=this.passes.length;c>b;++b)d=this.passes[b],d.enabled&&(d.render(this.renderer,this.writeBuffer,this.readBuffer,a,f),d.needsSwap&&(f&&(e=this.renderer.context,e.stencilFunc(e.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,a),e.stencilFunc(e.EQUAL,1,4294967295)),this.swapBuffers()),d instanceof p?f=!0:d instanceof q&&(f=!1))},B.prototype.reset=function(a){var b,c,d;void 0===a?(a=this.renderTarget1.clone(),b=this.renderer.getPixelRatio(),c=Math.floor(this.renderer.context.canvas.width/b),d=Math.floor(this.renderer.context.canvas.height/b)):(c=a.width,d=a.height),this.renderTarget1.dispose(),this.renderTarget1=a,this.renderTarget2.dispose(),this.renderTarget2=a.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.setSize(c,d)},B.prototype.setSize=function(a,b){var c,d;for(this.renderTarget1.setSize(a,b),this.renderTarget2.setSize(a,b),c=0,d=this.passes.length;d>c;++c)this.passes[c].setSize(a,b)},a.EffectComposer=B,a.Pass=n,a.SavePass=o,a.MaskPass=p,a.ClearMaskPass=q,a.ShaderPass=r,a.RenderPass=s,a.TexturePass=t,a.AdaptiveToneMappingPass=u,a.DotScreenPass=v,a.GlitchPass=w,a.BloomPass=x,a.BokehPass=y,a.FilmPass=z,a.GodRaysPass=A,a.CopyMaterial=c,a.LuminosityMaterial=d,a.AdaptiveLuminosityMaterial=e,a.ToneMappingMaterial=f,a.DotScreenMaterial=g,a.GlitchMaterial=h,a.ConvolutionMaterial=j,a.BokehMaterial=k,a.FilmMaterial=l,a.GodRaysMaterial=m});